module fermat where
open import Agda.Primitive
open import bigops
open import bool
open import cong
open import connectives
open import div_mod
open import exp
open import fact
open import gcd
open import logic
open import nat
open import permutation
open import primes
open import sigma_pi
prime::to::not::divides::fact : _
prime::to::not::divides::fact = \(p : nat.nat) -> \(primep : primes.prime p) -> (\(n : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> (nat.lt ::x::365 p) -> connectives.Not (primes.divides p (fact.fact ::x::365)))) ((((fact.sym::eq::fact) (nat.O)) (\(y : nat.nat) -> (nat.lt nat.O p) -> connectives.Not (primes.divides p y))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat)) (fact.fact::body)) (\(y : nat.nat) -> (nat.lt nat.O p) -> connectives.Not (primes.divides p y))) (((fact.sym::eq::fact::body::O) (\(y : nat.nat) -> (nat.lt nat.O p) -> connectives.Not (primes.divides p y))) (\(:::: : nat.le (nat.S nat.O) p) -> (((connectives.nmk) (primes.divides p (nat.S nat.O))) (\(divp : primes.divides p (nat.S nat.O)) -> ((((logic.absurd) (nat.le p (nat.S nat.O))) (((((primes.divides::to::le) (p)) (nat.S nat.O)) ((nat.lt::O::S) (nat.O))) (divp))) ((((nat.lt::to::not::le) (nat.S nat.O)) (p)) (((primes.prime::to::lt::SO) (p)) (primep))))))))))) (\(n1 : nat.nat) -> (((fact.sym::eq::fact) (nat.S n1)) (\(y : nat.nat) -> ((nat.lt n1 p) -> connectives.Not (primes.divides p (fact.fact n1))) -> (nat.lt (nat.S n1) p) -> connectives.Not (primes.divides p y))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat)) (fact.fact::body)) (n1)) (\(y : nat.nat) -> ((nat.lt n1 p) -> connectives.Not (primes.divides p (fact.fact n1))) -> (nat.lt (nat.S n1) p) -> connectives.Not (primes.divides p y))) ((((fact.sym::eq::fact::body::S) (n1)) (\(y : nat.nat) -> ((nat.lt n1 p) -> connectives.Not (primes.divides p (fact.fact n1))) -> (nat.lt (nat.S n1) p) -> connectives.Not (primes.divides p y))) (\(Hind : (nat.lt n1 p) -> connectives.Not (primes.divides p (fact.fact n1))) -> (\(ltn1 : nat.lt (nat.S n1) p) -> (((connectives.nmk) (primes.divides p (nat.times (fact.fact n1) (nat.S n1)))) (\(Hdiv : primes.divides p (nat.times (fact.fact n1) (nat.S n1))) -> (((((((connectives.match::Or::prop) (primes.divides p (fact.fact n1))) (primes.divides p (nat.S n1))) (connectives.False)) (\(Hdiv0 : primes.divides p (fact.fact n1)) -> ((((logic.absurd) (primes.divides p (fact.fact n1))) (Hdiv0)) ((Hind) ((((nat.lt::to::le) (nat.S n1)) (p)) (ltn1)))))) (\(Hdiv0 : primes.divides p (nat.S n1)) -> ((((logic.absurd) (nat.le p (nat.S n1))) (((((primes.divides::to::le) (p)) (nat.S n1)) ((nat.lt::O::S) (n1))) (Hdiv0))) ((((nat.lt::to::not::le) (nat.S n1)) (p)) (ltn1))))) ((((((gcd.divides::times::to::divides) (p)) (fact.fact n1)) (nat.S n1)) (primep)) (Hdiv))))))))))) (n))

permut::mod : _
permut::mod = \(p : nat.nat) -> \(a : nat.nat) -> \(primep : primes.prime p) -> (\(ndiv : connectives.Not (primes.divides p a)) -> (((((connectives.conj) (forall (x : nat.nat) -> (nat.le x (nat.pred p)) -> nat.le (div_mod.mod (nat.times a x) p) (nat.pred p))) (permutation.injn (\(n : nat.nat) -> div_mod.mod (nat.times a n) p) (nat.pred p))) (\(i : nat.nat) -> \(lei : nat.le i (nat.pred p)) -> ((((nat.le::S::S::to::le) (div_mod.mod (nat.times a i) p)) (nat.pred p)) ((((((nat.transitive::le) (nat.S (div_mod.mod (nat.times a i) p))) (p)) (nat.S (nat.pred p))) ((((div_mod.lt::mod::m::m) (nat.times a i)) (p)) (((primes.prime::to::lt::O) (p)) (primep)))) (((((((logic.eq::ind::r) (nat.nat)) (p)) (\(x : nat.nat) -> nat.le p x)) ((nat.le::n) (p))) (nat.S (nat.pred p))) (((nat.S::pred) (p)) (((primes.prime::to::lt::O) (p)) (primep)))))))) (\(i : nat.nat) -> \(j : nat.nat) -> \(lei : nat.le i (nat.pred p)) -> (\(lej : nat.le j (nat.pred p)) -> (\(H : logic.eq (nat.nat) (div_mod.mod (nat.times a i) p) (div_mod.mod (nat.times a j) p)) -> (((((((connectives.match::Or::prop) (nat.lt i j)) (connectives.Not (nat.lt i j))) (logic.eq (nat.nat) i j)) (\(ltij : nat.lt i j) -> (((connectives.falsity) (logic.eq (nat.nat) i j)) ((((logic.absurd) (nat.lt (nat.minus j i) p)) (((((((logic.eq::ind) (nat.nat)) (nat.S (nat.pred p))) (\(x::1 : nat.nat) -> nat.lt (nat.minus j i) x::1)) ((((nat.le::S::S) (nat.minus j i)) (nat.pred p)) (((((nat.le::plus::to::minus) (j)) (i)) (nat.pred p)) ((((((nat.transitive::le) (j)) (nat.pred p)) (nat.plus (nat.pred p) i)) (lej)) (((nat.le::plus::n::r) (i)) (nat.pred p)))))) (p)) (((nat.S::pred) (p)) (((primes.prime::to::lt::O) (p)) (primep))))) ((((nat.le::to::not::lt) (p)) (nat.minus j i)) (((((primes.divides::to::le) (p)) (nat.minus j i)) (((((nat.lt::plus::to::minus::r) (nat.O)) (i)) (j)) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y i)) j)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y i)) j)) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y i)) j)) (ltij)))))) (((((((connectives.match::Or::prop) (primes.divides p a)) (primes.divides p (nat.minus j i))) (primes.divides p (nat.minus j i))) (\(Hdiv : primes.divides p a) -> (((connectives.falsity) (primes.divides p (nat.minus j i))) ((((logic.absurd) (primes.divides p a)) (Hdiv)) (ndiv))))) (\(auto : primes.divides p (nat.minus j i)) -> (auto))) ((((((gcd.divides::times::to::divides) (p)) (a)) (nat.minus j i)) (primep)) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus (nat.times a j) (nat.times a i))) (\(x : nat.nat) -> primes.divides p x)) ((((((primes.eq::mod::to::divides) (nat.times a j)) (nat.times a i)) (p)) (((primes.prime::to::lt::O) (p)) (primep))) (((((((logic.rewrite::l) (nat.nat)) (div_mod.mod (nat.times a i) p)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (div_mod.mod (nat.times a i) p))) (((logic.refl) (nat.nat)) (div_mod.mod (nat.times a i) p))) (div_mod.mod (nat.times a j) p)) (H)))) (nat.times a (nat.minus j i))) ((((nat.distributive::times::minus) (a)) (j)) (i))))))))))) (\(Hij : connectives.Not (nat.lt i j)) -> (((((((connectives.match::Or::prop) (nat.lt j i)) (logic.eq (nat.nat) j i)) (logic.eq (nat.nat) i j)) (\(Hij0 : nat.lt j i) -> (((connectives.falsity) (logic.eq (nat.nat) i j)) ((((logic.absurd) (nat.lt (nat.minus i j) p)) (((((((logic.eq::ind) (nat.nat)) (nat.S (nat.pred p))) (\(x::1 : nat.nat) -> nat.lt (nat.minus i j) x::1)) ((((nat.le::S::S) (nat.minus i j)) (nat.pred p)) (((((nat.le::plus::to::minus) (i)) (j)) (nat.pred p)) ((((((nat.transitive::le) (i)) (nat.pred p)) (nat.plus (nat.pred p) j)) (lei)) (((nat.le::plus::n::r) (j)) (nat.pred p)))))) (p)) (((nat.S::pred) (p)) (((primes.prime::to::lt::O) (p)) (primep))))) ((((nat.le::to::not::lt) (p)) (nat.minus i j)) (((((primes.divides::to::le) (p)) (nat.minus i j)) (((((nat.lt::plus::to::minus::r) (nat.O)) (j)) (i)) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y j)) i)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y j)) i)) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y j)) i)) (Hij0)))))) (((((((connectives.match::Or::prop) (primes.divides p a)) (primes.divides p (nat.minus i j))) (primes.divides p (nat.minus i j))) (\(Hdiv : primes.divides p a) -> (((connectives.falsity) (primes.divides p (nat.minus i j))) ((((logic.absurd) (primes.divides p a)) (Hdiv)) (ndiv))))) (\(auto : primes.divides p (nat.minus i j)) -> (auto))) ((((((gcd.divides::times::to::divides) (p)) (a)) (nat.minus i j)) (primep)) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus (nat.times a i) (nat.times a j))) (\(x : nat.nat) -> primes.divides p x)) ((((((primes.eq::mod::to::divides) (nat.times a i)) (nat.times a j)) (p)) (((primes.prime::to::lt::O) (p)) (primep))) (((((((logic.rewrite::l) (nat.nat)) (div_mod.mod (nat.times a i) p)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (div_mod.mod (nat.times a i) p) ::::)) (((logic.refl) (nat.nat)) (div_mod.mod (nat.times a i) p))) (div_mod.mod (nat.times a j) p)) (H)))) (nat.times a (nat.minus i j))) ((((nat.distributive::times::minus) (a)) (i)) (j))))))))))) (\(Hij0 : logic.eq (nat.nat) j i) -> (((((((logic.rewrite::r) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) i ::::)) (((logic.refl) (nat.nat)) (i))) (j)) (Hij0)))) ((((nat.le::to::or::lt::eq) (j)) (i)) ((((nat.not::lt::to::le) (i)) (j)) (Hij)))))) (((nat.decidable::lt) (i)) (j))))))))

eq::fact::pi::p : _
eq::fact::pi::p = \(n : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> logic.eq (nat.nat) (fact.fact ::x::365) (bigops.bigop (nat.nat) (nat.minus (nat.S ::x::365) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus) (nat.S nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) (y (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.minus::body)) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) (y (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus::body::S) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) (y (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.S nat.O)) (\(q : nat.nat) -> nat.minus nat.O q)) (nat.O)) (\(y : nat.nat) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) (y nat.O) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.minus::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) (y nat.O) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((nat.sym::eq::minus::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (bigops.bigop (nat.nat) (y nat.O) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((bigops.sym::eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((bigops.sym::eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (fact.fact nat.O) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((fact.eq::fact::body::O) (\(y : nat.nat) -> logic.eq (nat.nat) (fact.fact nat.O) y)) (((((nat.eq::filter::nat::type::O) (nat.nat)) (fact.fact::body)) (\(y : nat.nat) -> logic.eq (nat.nat) (fact.fact nat.O) y)) ((((fact.eq::fact) (nat.O)) (\(y : nat.nat) -> logic.eq (nat.nat) (fact.fact nat.O) y)) (((logic.refl) (nat.nat)) (fact.fact nat.O))))))))))))))) (\(n1 : nat.nat) -> (((fact.sym::eq::fact) (nat.S n1)) (\(y : nat.nat) -> (logic.eq (nat.nat) (fact.fact n1) (bigops.bigop (nat.nat) (nat.minus (nat.S n1) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) -> logic.eq (nat.nat) y (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.S n1)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat)) (fact.fact::body)) (n1)) (\(y : nat.nat) -> (logic.eq (nat.nat) (fact.fact n1) (bigops.bigop (nat.nat) (nat.minus (nat.S n1) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) -> logic.eq (nat.nat) y (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.S n1)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((fact.sym::eq::fact::body::S) (n1)) (\(y : nat.nat) -> (logic.eq (nat.nat) (fact.fact n1) (bigops.bigop (nat.nat) (nat.minus (nat.S n1) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) -> logic.eq (nat.nat) y (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.S n1)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (\(Hind : logic.eq (nat.nat) (fact.fact n1) (bigops.bigop (nat.nat) (nat.minus (nat.S n1) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (nat.S n1) (fact.fact n1))) (\(x : nat.nat) -> logic.eq (nat.nat) x (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.S n1)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus) (nat.S (nat.S n1))) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) (y (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.minus::body)) (nat.S n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) (y (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus::body::S) (nat.S n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) (y (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.S (nat.S n1))) (\(q : nat.nat) -> nat.minus (nat.S n1) q)) (nat.O)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus) (nat.S n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) (y nat.O) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.minus::body)) (n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) (y nat.O) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((nat.sym::eq::minus::body::S) (n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) (y nat.O) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) ((((((nat.sym::eq::match::nat::type::O) (nat.nat)) (nat.S n1)) (\(q : nat.nat) -> nat.minus n1 q)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (bigops.bigop (nat.nat) y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (nat.plus n1 (nat.S nat.O)) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) x)) (((((((logic.eq::ind) (nat.nat)) (nat.S (nat.plus n1 nat.O))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (nat.times x::1 (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))))) (((((((logic.eq::ind) (nat.nat)) (n1)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.times (nat.S n1) (fact.fact n1)) (nat.times (nat.S x::1) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))))) (((((((logic.eq::f) (nat.nat)) (nat.nat)) (nat.times (nat.S n1))) (fact.fact n1)) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (((((((logic.eq::ind) (nat.nat)) (nat.minus (nat.S n1) (nat.S nat.O))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (fact.fact n1) (bigops.bigop (nat.nat) x::1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (Hind)) (n1)) ((((nat.sym::eq::minus) (nat.S n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y (nat.S nat.O)) n1)) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.minus::body)) (n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y (nat.S nat.O)) n1)) ((((nat.sym::eq::minus::body::S) (n1)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y (nat.S nat.O)) n1)) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.S n1)) (\(q : nat.nat) -> nat.minus n1 q)) (nat.O)) (\(y : nat.nat) -> logic.eq (nat.nat) y n1)) (((((((logic.rewrite::l) (nat.nat)) (n1)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: n1)) (((logic.refl) (nat.nat)) (n1))) (nat.minus n1 nat.O)) ((nat.minus::n::O) (n1)))))))))) (nat.plus n1 nat.O)) ((nat.plus::n::O) (n1)))) (nat.plus n1 (nat.S nat.O))) (((nat.plus::n::Sm) (n1)) (nat.O)))) (bigops.bigop (nat.nat) (nat.S n1) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) ((((((((bigops.bigop::Strue) (nat.nat)) (n1)) (\(:::: : nat.nat) -> bool.true)) (nat.S nat.O)) (nat.times)) (\(:::: : nat.nat) -> nat.plus :::: (nat.S nat.O))) (((logic.refl) (bool.bool)) (bool.true))))))))))))) (nat.times (fact.fact n1) (nat.S n1))) (((nat.commutative::times) (fact.fact n1)) (nat.S n1)))))))) (n)

congruent::pi : _
congruent::pi = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (p : nat.nat) -> (nat.lt nat.O p) -> cong.congruent (bigops.bigop (nat.nat) ::x::365 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) (bigops.bigop (nat.nat) ::x::365 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p)) (\(p : nat.nat) -> (((bigops.sym::eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.lt nat.O p) -> cong.congruent (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p)) ((((bigops.sym::eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.lt nat.O p) -> cong.congruent (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p)) ((((bigops.eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.lt nat.O p) -> cong.congruent (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) p)) ((((bigops.eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.lt nat.O p) -> cong.congruent (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) p)) (\(auto : nat.lt nat.O p) -> (((cong.congruent::n::n) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (p)))))))) (\(n1 : nat.nat) -> \(Hind : forall (p : nat.nat) -> (nat.lt nat.O p) -> cong.congruent (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p) -> (\(p : nat.nat) -> \(posp : nat.lt nat.O p) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f n1) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (\(x : nat.nat) -> cong.congruent x (bigops.bigop (nat.nat) (nat.S n1) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p)) (((((bigops.sym::eq::bigop::S) (nat.nat)) (n1)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> cong.congruent (nat.times (f n1) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p)) (((((bigops.sym::eq::bigop::body::S) (nat.nat)) (n1)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> cong.congruent (nat.times (f n1) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)) p)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (nat.times (div_mod.mod (f n1) p) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p)))) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p))) (\(y : nat.nat) -> cong.congruent (nat.times (f n1) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) y p)) (((((((((cong.congruent::times) (f n1)) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (div_mod.mod (f n1) p)) (bigops.bigop (nat.nat) n1 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (f i) p))) (p)) (posp)) ((((cong.congruent::n::mod::n) (f n1)) (p)) (posp))) (((Hind) (p)) (posp))))))) (bigops.bigop (nat.nat) (nat.S n1) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) ((((((((bigops.bigop::Strue) (nat.nat)) (n1)) (\(:::: : nat.nat) -> bool.true)) (nat.S nat.O)) (nat.times)) (f)) (((logic.refl) (bool.bool)) (bool.true))))))) (n)

congruent::exp::pred::SO : _
congruent::exp::pred::SO = \(p : nat.nat) -> \(a : nat.nat) -> \(primep : primes.prime p) -> (\(ndiv : connectives.Not (primes.divides p a)) -> (((((((cong.divides::to::congruent) (exp.exp a (nat.pred p))) (nat.S nat.O)) (p)) (((primes.prime::to::lt::O) (p)) (primep))) ((((exp.lt::O::exp) (a)) (nat.pred p)) ((((((nat.match::nat::prop) (\(:::: : nat.nat) -> (connectives.Not (primes.divides p ::::)) -> nat.lt nat.O ::::)) (\(::clearme : connectives.Not (primes.divides p nat.O)) -> (((((connectives.Not::ind) (primes.divides p nat.O)) (nat.lt nat.O nat.O)) (\(div0 : (primes.divides p nat.O) -> connectives.False) -> (((connectives.falsity) (nat.lt nat.O nat.O)) ((div0) (((((primes.quotient) (p)) (nat.O)) (nat.O)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) nat.O ::::)) (((logic.refl) (nat.nat)) (nat.O))) (nat.times p nat.O)) ((nat.times::n::O) (p)))))))) (::clearme)))) (\(auto : nat.nat) -> \(auto' : connectives.Not (primes.divides p (nat.S auto))) -> ((nat.lt::O::S) (auto)))) (a)) (ndiv)))) (((((((connectives.match::Or::prop) (primes.divides p (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O)))) (primes.divides p (fact.fact (nat.pred p)))) (primes.divides p (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O)))) (\(auto : primes.divides p (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O))) -> (auto))) (\(Hdiv : primes.divides p (fact.fact (nat.pred p))) -> (((connectives.falsity) (primes.divides p (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O)))) ((((logic.absurd) (primes.divides p (fact.fact (nat.pred p)))) (Hdiv)) (((((prime::to::not::divides::fact) (p)) (primep)) (nat.pred p)) ((((nat.le::S::S::to::le) (nat.S (nat.pred p))) (p)) (((((((logic.eq::ind::r) (nat.nat)) (p)) (\(x : nat.nat) -> nat.le (nat.S x) (nat.S p))) ((nat.le::n) (nat.S p))) (nat.S (nat.pred p))) (((nat.S::pred) (p)) (((primes.prime::to::lt::O) (p)) (primep)))))))))) ((((((gcd.divides::times::to::divides) (p)) (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O))) (fact.fact (nat.pred p))) (primep)) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (fact.fact (nat.pred p)) (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O)))) (\(x : nat.nat) -> primes.divides p x)) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus (nat.times (fact.fact (nat.pred p)) (exp.exp a (nat.pred p))) (nat.times (fact.fact (nat.pred p)) (nat.S nat.O)))) (\(x : nat.nat) -> primes.divides p x)) (((((((logic.eq::ind) (nat.nat)) (fact.fact (nat.pred p))) (\(x::1 : nat.nat) -> primes.divides p (nat.minus (nat.times (fact.fact (nat.pred p)) (exp.exp a (nat.pred p))) x::1))) (((((((logic.eq::ind::r) (nat.nat)) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (\(x : nat.nat) -> primes.divides p (nat.minus (nat.times x (exp.exp a (nat.pred p))) x))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (exp.exp a (nat.pred p)) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (\(x : nat.nat) -> primes.divides p (nat.minus x (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O))) (\(x : nat.nat) -> primes.divides p (nat.minus (nat.times (exp.exp a x) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))))) (((((((logic.eq::ind::r) (nat.nat)) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (nat.plus i (nat.S nat.O))))) (\(x : nat.nat) -> primes.divides p (nat.minus x (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))))) ((((((cong.congruent::to::divides) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (nat.plus i (nat.S nat.O))))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (p)) (((primes.prime::to::lt::O) (p)) (primep))) (((((((cong.transitive::congruent) (p)) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (nat.plus i (nat.S nat.O))))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (nat.times a (nat.plus i (nat.S nat.O))) p))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (((((congruent::pi) (\(m : nat.nat) -> nat.times a (nat.plus m (nat.S nat.O)))) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O))) (p)) (((primes.prime::to::lt::O) (p)) (primep)))) (((((((logic.eq::ind) (nat.nat)) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (\(x::1 : nat.nat) -> cong.congruent x::1 (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))) p)) (((cong.congruent::n::n) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (p))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (nat.times a (nat.plus i (nat.S nat.O))) p))) (((((((logic.eq::ind::r) (nat.nat)) (bigops.bigop (nat.nat) (nat.S (nat.pred p)) (\(i : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) i) bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> i))) (\(x : nat.nat) -> logic.eq (nat.nat) x (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (nat.times a (nat.plus i (nat.S nat.O))) p)))) (((((((logic.eq::ind::r) (nat.nat)) (bigops.bigop (nat.nat) (nat.S (nat.pred p)) (\(i : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) i) bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (nat.times a i) p))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigops.bigop (nat.nat) (nat.S (nat.pred p)) (\(i : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) i) bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> i)) x)) (((((logic.sym::eq) (nat.nat)) (bigops.bigop (nat.nat) (nat.S (nat.pred p)) (\(i : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) i) bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (nat.times a i) p))) (bigops.bigop (nat.nat) (nat.S (nat.pred p)) (\(i : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) i) bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> i))) ((((((((bigops.bigop::iso) (nat.S (nat.pred p))) (nat.S (nat.pred p))) (\(:::: : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::::) bool.true)) (\(:::: : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::::) bool.true)) (\(:::: : nat.nat) -> div_mod.mod (nat.times a ::::) p)) (\(:::: : nat.nat) -> ::::)) (((((connectives.ex::intro) (nat.nat -> nat.nat)) (\(x : (nat.nat -> nat.nat)) -> connectives.ex (nat.nat -> nat.nat) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i (nat.S (nat.pred p))) -> (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) i) bool.true) bool.true) -> logic.eq (nat.nat) (div_mod.mod (nat.times a i) p) (x i)) (bigops.sub::hk x k (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p) (\(::0 : nat.nat) -> ::0))) (bigops.sub::hk k x (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> ::0) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p))))) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p)) (((((connectives.ex::intro) (nat.nat -> nat.nat)) (\(y : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i (nat.S (nat.pred p))) -> (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) i) bool.true) bool.true) -> logic.eq (nat.nat) (div_mod.mod (nat.times a i) p) (div_mod.mod (nat.times a i) p)) (bigops.sub::hk (\(i : nat.nat) -> div_mod.mod (nat.times a i) p) y (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p) (\(::0 : nat.nat) -> ::0))) (bigops.sub::hk y (\(i : nat.nat) -> div_mod.mod (nat.times a i) p) (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> ::0) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p)))) (permutation.invert::permut (nat.pred p) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p))) (((((connectives.conj) (connectives.And (forall (i : nat.nat) -> (nat.lt i (nat.S (nat.pred p))) -> (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) i) bool.true) bool.true) -> logic.eq (nat.nat) (div_mod.mod (nat.times a i) p) (div_mod.mod (nat.times a i) p)) (bigops.sub::hk (\(i : nat.nat) -> div_mod.mod (nat.times a i) p) (permutation.invert::permut (nat.pred p) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p)) (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p) (\(::0 : nat.nat) -> ::0)))) (bigops.sub::hk (permutation.invert::permut (nat.pred p) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p)) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p) (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> ::0) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p))) (((((connectives.conj) (forall (x : nat.nat) -> (nat.lt x (nat.S (nat.pred p))) -> (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) x) bool.true) bool.true) -> logic.eq (nat.nat) (div_mod.mod (nat.times a x) p) (div_mod.mod (nat.times a x) p))) (bigops.sub::hk (\(i : nat.nat) -> div_mod.mod (nat.times a i) p) (permutation.invert::permut (nat.pred p) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p)) (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p) (\(::0 : nat.nat) -> ::0))) (\(i : nat.nat) -> \(lti : nat.lt i (nat.S (nat.pred p))) -> (\(:::: : logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) i) bool.true) bool.true) -> (((logic.refl) (nat.nat)) (div_mod.mod (nat.times a i) p))))) (\(i : nat.nat) -> \(lti : nat.lt i (nat.S (nat.pred p))) -> (\(posi : logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) i) bool.true) bool.true) -> (((((connectives.conj) (connectives.And (nat.lt (div_mod.mod (nat.times a i) p) (nat.S (nat.pred p))) (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) (div_mod.mod (nat.times a i) p)) bool.true) bool.true))) (logic.eq (nat.nat) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) (div_mod.mod (nat.times a i) p)) i)) (((((connectives.conj) (nat.lt (div_mod.mod (nat.times a i) p) (nat.S (nat.pred p)))) (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) (div_mod.mod (nat.times a i) p)) bool.true) bool.true)) (((((((logic.eq::ind::r) (nat.nat)) (p)) (\(x : nat.nat) -> nat.lt (div_mod.mod (nat.times a i) p) x)) ((((div_mod.lt::mod::m::m) (nat.times a i)) (p)) (((primes.prime::to::lt::O) (p)) (primep)))) (nat.S (nat.pred p))) (((nat.S::pred) (p)) (((primes.prime::to::lt::O) (p)) (primep))))) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb x bool.true) bool.true)) ((((((bool.eq::match::bool::type::true) (bool.bool)) (bool.true)) (bool.false)) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.andb bool.true bool.true) y)) (((logic.refl) (bool.bool)) (bool.andb bool.true bool.true)))) (nat.leb (nat.S nat.O) (div_mod.mod (nat.times a i) p))) ((((nat.le::to::leb::true) (nat.S nat.O)) (div_mod.mod (nat.times a i) p)) (((((((connectives.match::Or::prop) (nat.lt nat.O (div_mod.mod (nat.times a i) p))) (logic.eq (nat.nat) nat.O (div_mod.mod (nat.times a i) p))) (nat.le (nat.S nat.O) (div_mod.mod (nat.times a i) p))) (\(auto : nat.lt nat.O (div_mod.mod (nat.times a i) p)) -> (auto))) (\(H : logic.eq (nat.nat) nat.O (div_mod.mod (nat.times a i) p)) -> (((connectives.falsity) (nat.le (nat.S nat.O) (div_mod.mod (nat.times a i) p))) ((((logic.absurd) (primes.divides p (nat.times a i))) (((((primes.mod::O::to::divides) (p)) (nat.times a i)) (((primes.prime::to::lt::O) (p)) (primep))) (((((logic.sym::eq) (nat.nat)) (nat.O)) (div_mod.mod (nat.times a i) p)) (H)))) (((((logic.not::to::not) (primes.divides p (nat.times a i))) (primes.divides p a)) (\(Hdiv : primes.divides p (nat.times a i)) -> (((((((connectives.match::Or::prop) (primes.divides p a)) (primes.divides p i)) (primes.divides p a)) (\(auto : primes.divides p a) -> (auto))) (\(divpi : primes.divides p i) -> (((connectives.falsity) (primes.divides p a)) ((((logic.absurd) (nat.lt i (nat.S (nat.pred p)))) (lti)) ((((nat.le::to::not::lt) (nat.S (nat.pred p))) (i)) (((((((logic.eq::ind::r) (nat.nat)) (p)) (\(x : nat.nat) -> nat.le x i)) (((((primes.divides::to::le) (p)) (i)) ((((nat.leb::true::to::le) (nat.S nat.O)) (i)) ((((bool.andb::true::l) (nat.leb (nat.S nat.O) i)) (bool.true)) (posi)))) (divpi))) (nat.S (nat.pred p))) (((nat.S::pred) (p)) (((primes.prime::to::lt::O) (p)) (primep))))))))) ((((((gcd.divides::times::to::divides) (p)) (a)) (i)) (primep)) (Hdiv))))) (ndiv)))))) ((((nat.le::to::or::lt::eq) (nat.O)) (div_mod.mod (nat.times a i) p)) ((nat.le::O::n) (div_mod.mod (nat.times a i) p)))))))) ((((((permutation.invert::permut::f) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p)) (nat.pred p)) (i)) ((((nat.le::S::S::to::le) (i)) (nat.pred p)) (lti))) ((((((connectives.match::And::prop) (forall (i1 : nat.nat) -> (nat.le i1 (nat.pred p)) -> nat.le (div_mod.mod (nat.times a i1) p) (nat.pred p))) (permutation.injn (\(n : nat.nat) -> div_mod.mod (nat.times a n) p) (nat.pred p))) (permutation.injn (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) (nat.pred p))) (\(auto : forall (i0 : nat.nat) -> (nat.le i0 (nat.pred p)) -> nat.le (div_mod.mod (nat.times a i0) p) (nat.pred p)) -> (\(auto' : permutation.injn (\(n : nat.nat) -> div_mod.mod (nat.times a n) p) (nat.pred p)) -> (auto')))) (((((permut::mod) (p)) (a)) (primep)) (ndiv))))))))) ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.le i (nat.pred p)) -> nat.le (permutation.invert::permut (nat.pred p) (\(n : nat.nat) -> div_mod.mod (nat.times a n) p) i) (nat.pred p))) (permutation.injn (permutation.invert::permut (nat.pred p) (\(n : nat.nat) -> div_mod.mod (nat.times a n) p)) (nat.pred p))) (bigops.sub::hk (permutation.invert::permut (nat.pred p) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p)) (\(i : nat.nat) -> div_mod.mod (nat.times a i) p) (nat.S (nat.pred p)) (nat.S (nat.pred p)) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> bool.andb (nat.leb (nat.S nat.O) ::0) bool.true) (\(::0 : nat.nat) -> ::0) (\(::0 : nat.nat) -> div_mod.mod (nat.times a ::0) p))) (\(le::invert::permut : forall (i : nat.nat) -> (nat.le i (nat.pred p)) -> nat.le (permutation.invert::permut (nat.pred p) (\(n : nat.nat) -> div_mod.mod (nat.times a n) p) i) (nat.pred p)) -> (\(inj::inv::permut : permutation.injn (permutation.invert::permut (nat.pred p) (\(n : nat.nat) -> div_mod.mod (nat.times a n) p)) (nat.pred p)) -> (\(i : nat.nat) -> \(lti : nat.lt i (nat.S (nat.pred p))) -> (\(posi : logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) i) bool.true) bool.true) -> (((((connectives.conj) (connectives.And (nat.lt (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i) (nat.S (nat.pred p))) (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) bool.true) bool.true))) (logic.eq (nat.nat) (div_mod.mod (nat.times a (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) p) i)) (((((connectives.conj) (nat.lt (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i) (nat.S (nat.pred p)))) (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) bool.true) bool.true)) ((((nat.le::S::S) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) (nat.pred p)) (((le::invert::permut) (i)) ((((nat.le::S::S::to::le) (i)) (nat.pred p)) (lti))))) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb x bool.true) bool.true)) ((((((bool.eq::match::bool::type::true) (bool.bool)) (bool.true)) (bool.false)) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.andb bool.true bool.true) y)) (((logic.refl) (bool.bool)) (bool.andb bool.true bool.true)))) (nat.leb (nat.S nat.O) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i))) ((((nat.le::to::leb::true) (nat.S nat.O)) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) (((((((connectives.match::Or::prop) (nat.lt nat.O (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i))) (logic.eq (nat.nat) nat.O (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i))) (nat.le (nat.S nat.O) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i))) (\(auto : nat.lt nat.O (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) -> (auto))) (\(H : logic.eq (nat.nat) nat.O (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) -> (((connectives.falsity) (nat.le (nat.S nat.O) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i))) ((((((((logic.eq::ind::r) (nat.nat)) (nat.O)) (\(x : nat.nat) -> (logic.eq (nat.nat) x (div_mod.mod (nat.times a (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) p)) -> connectives.False)) (((((((logic.eq::ind::r) (nat.nat)) (i)) (\(x : nat.nat) -> (logic.eq (nat.nat) nat.O x) -> connectives.False)) (\(eq0i : logic.eq (nat.nat) nat.O i) -> ((((((((logic.eq::ind) (nat.nat)) (nat.O)) (\(x::1 : nat.nat) -> (logic.eq (bool.bool) (bool.andb (nat.leb (nat.S nat.O) x::1) bool.true) bool.true) -> connectives.False)) ((((nat.sym::eq::leb) (nat.S nat.O)) (\(y : (nat.nat -> bool.bool)) -> (logic.eq (bool.bool) (bool.andb (y nat.O) bool.true) bool.true) -> connectives.False)) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> bool.bool)) (nat.leb::body)) (nat.O)) (\(y : (nat.nat -> bool.bool)) -> (logic.eq (bool.bool) (bool.andb (y nat.O) bool.true) bool.true) -> connectives.False)) ((((nat.sym::eq::leb::body::S) (nat.O)) (\(y : (nat.nat -> bool.bool)) -> (logic.eq (bool.bool) (bool.andb (y nat.O) bool.true) bool.true) -> connectives.False)) ((((((nat.sym::eq::match::nat::type::O) (bool.bool)) (bool.false)) (\(q : nat.nat) -> nat.leb nat.O q)) (\(y : bool.bool) -> (logic.eq (bool.bool) (bool.andb y bool.true) bool.true) -> connectives.False)) ((((((bool.sym::eq::match::bool::type::false) (bool.bool)) (bool.true)) (bool.false)) (\(y : bool.bool) -> (logic.eq (bool.bool) y bool.true) -> connectives.False)) (\(H0 : logic.eq (bool.bool) bool.false bool.true) -> (((((((bool.eq::match::bool::type::true) (Set)) (forall (P : Set) -> P)) (forall (P : Set) -> P -> P)) (\(y : Set) -> y)) ((((((bool.eq::match::bool::type::false) (Set)) (bool.match::bool::type (Set) (forall (P : Set) -> P -> P) (forall (P : Set) -> P) bool.true)) (bool.match::bool::type (Set) (forall (P : Set) -> P) (forall (P : Set) -> P -> P) bool.true)) (\(y : Set) -> y)) ((((bool.bool::discr) (bool.false)) (bool.true)) (H0)))) (connectives.False))))))))) (i)) (eq0i)) (posi)))) (div_mod.mod (nat.times a (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) p)) ((((((permutation.f::invert::permut) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p)) (nat.pred p)) (i)) ((((nat.le::S::S::to::le) (i)) (nat.pred p)) (lti))) (((((permut::mod) (p)) (a)) (primep)) (ndiv))))) (div_mod.mod (nat.times a nat.O) p)) (((((((logic.eq::ind) (nat.nat)) (nat.O)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (div_mod.mod x::1 p) nat.O)) (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: nat.O)) (((logic.refl) (nat.nat)) (nat.O))) (div_mod.mod nat.O p)) ((div_mod.mod::O::n) (p)))) (nat.times a nat.O)) ((nat.times::n::O) (a)))) (((((((logic.eq::f) (nat.nat)) (nat.nat)) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p)) (nat.O)) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) nat.O ::::)) (((logic.refl) (nat.nat)) (nat.O))) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) (H))))))) ((((nat.le::to::or::lt::eq) (nat.O)) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)) ((nat.le::O::n) (permutation.invert::permut (nat.pred p) (\(i0 : nat.nat) -> div_mod.mod (nat.times a i0) p) i)))))))) ((((((permutation.f::invert::permut) (\(:::: : nat.nat) -> div_mod.mod (nat.times a ::::) p)) (nat.pred p)) (i)) ((((nat.le::S::S::to::le) (i)) (nat.pred p)) (lti))) (((((permut::mod) (p)) (a)) (primep)) (ndiv))))))))) ((((permutation.permut::invert::permut) (\(n : nat.nat) -> div_mod.mod (nat.times a n) p)) (nat.pred p)) (((((permut::mod) (p)) (a)) (primep)) (ndiv)))))))))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> div_mod.mod (nat.times a (nat.plus i (nat.S nat.O))) p))) ((((((bigops.bigop::I::gen) (nat.S nat.O)) (nat.S (nat.pred p))) (\(:::: : nat.nat) -> bool.true)) (\(:::: : nat.nat) -> div_mod.mod (nat.times a ::::) p)) ((nat.lt::O::S) (nat.pred p))))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) ((((((bigops.bigop::I::gen) (nat.S nat.O)) (nat.S (nat.pred p))) (\(:::: : nat.nat) -> bool.true)) (\(:::: : nat.nat) -> ::::)) ((nat.lt::O::S) (nat.pred p)))))))) (nat.times (exp.exp a (nat.minus (nat.S (nat.pred p)) (nat.S nat.O))) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))))) (((((sigma_pi.exp::pi::bc) (a)) (nat.S nat.O)) (nat.S (nat.pred p))) (\(:::: : nat.nat) -> ::::)))) (nat.pred p)) (((((((logic.rewrite::r) (nat.nat)) (nat.minus (nat.pred p) nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.pred p) ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.pred p)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.pred p) ::::)) (((logic.refl) (nat.nat)) (nat.pred p))) (nat.minus (nat.pred p) nat.O)) ((nat.minus::n::O) (nat.pred p)))) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O))) (((nat.minus::S::S) (nat.pred p)) (nat.O))))) (nat.times (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O))) (exp.exp a (nat.pred p)))) (((nat.commutative::times) (bigops.bigop (nat.nat) (nat.minus (nat.S (nat.pred p)) (nat.S nat.O)) (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.plus i (nat.S nat.O)))) (exp.exp a (nat.pred p))))) (fact.fact (nat.pred p))) ((eq::fact::pi::p) (nat.pred p)))) (nat.times (fact.fact (nat.pred p)) (nat.S nat.O))) ((nat.times::n::1) (fact.fact (nat.pred p))))) (nat.times (fact.fact (nat.pred p)) (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O)))) ((((nat.distributive::times::minus) (fact.fact (nat.pred p))) (exp.exp a (nat.pred p))) (nat.S nat.O)))) (nat.times (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O)) (fact.fact (nat.pred p)))) (((nat.commutative::times) (nat.minus (exp.exp a (nat.pred p)) (nat.S nat.O))) (fact.fact (nat.pred p))))))))

