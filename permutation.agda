module permutation where
open import Agda.Primitive
open import bool
open import connectives
open import leibniz
open import logic
open import nat
open import relations
injn : _
injn = \(f : (nat.nat -> nat.nat)) -> \(n : nat.nat) -> forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i n) -> (nat.le j n) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j

injn::Sn::n : _
injn::Sn::n = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(H : injn f (nat.S n)) -> (\(i : nat.nat) -> \(j : nat.nat) -> \(lei : nat.le i n) -> (\(lej : nat.le j n) -> (\(eqf : logic.eq (nat.nat) (f i) (f j)) -> ((((((H) (i)) (j)) ((((nat.le::S) (i)) (n)) (lei))) ((((nat.le::S) (j)) (n)) (lej))) (((((((logic.rewrite::l) (nat.nat)) (f i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f i) ::::)) (((logic.refl) (nat.nat)) (f i))) (f j)) (eqf))))))

permut : _
permut = \(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> connectives.And (forall (i : nat.nat) -> (nat.le i m) -> nat.le (f i) m) (injn f m)

transpose : _
transpose = \(i : nat.nat) -> \(j : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) (nat.eqb n i)

transpose::i::j::i : _
transpose::i::j::i = \(i : nat.nat) -> \(j : nat.nat) -> ((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i i (nat.eqb i j)) x) j)) ((((((bool.eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i i (nat.eqb i j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i i (nat.eqb i j)) bool.true) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i i (nat.eqb i j)) bool.true)))) (nat.eqb i i)) ((nat.eqb::n::n) (i))

transpose::i::j::j : _
transpose::i::j::j = \(i : nat.nat) -> \(j : nat.nat) -> ((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb j i) bool.true)) (logic.eq (bool.bool) (nat.eqb j i) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j (nat.eqb j j)) (nat.eqb j i)) i)) (\(Hc : logic.eq (bool.bool) (nat.eqb j i) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j (nat.eqb j j)) x) i)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i j (nat.eqb j j))) (\(y : nat.nat) -> logic.eq (nat.nat) y i)) (((((((logic.eq::ind::r) (nat.nat)) (i)) (\(x : nat.nat) -> logic.eq (nat.nat) x i)) (((logic.refl) (nat.nat)) (i))) (j)) ((((nat.eqb::true::to::eq) (j)) (i)) (Hc))))) (nat.eqb j i)) (Hc)))) (\(Hc : logic.eq (bool.bool) (nat.eqb j i) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j (nat.eqb j j)) x) i)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j x) bool.false) i)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i j bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) y i)) ((((((bool.eq::match::bool::type::true) (nat.nat)) (i)) (j)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) i j bool.true) y)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i j bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) i j bool.true) y)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i j bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) y (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j bool.true) bool.false))) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j bool.true) bool.false))))))) (nat.eqb j j)) ((nat.eqb::n::n) (j)))) (nat.eqb j i)) (Hc)))) ((bool.true::or::false) (nat.eqb j i))

transpose::i::j::j::i : _
transpose::i::j::j::i = \(i : nat.nat) -> \(j : nat.nat) -> \(n : nat.nat) -> ((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb n i) bool.true)) (logic.eq (bool.bool) (nat.eqb n i) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) (nat.eqb n i)) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n (nat.eqb n i)) (nat.eqb n j)))) (\(Hni : logic.eq (bool.bool) (nat.eqb n i) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n x) (nat.eqb n j)))) (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb n j) bool.true)) (logic.eq (bool.bool) (nat.eqb n j) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.true) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.true) (nat.eqb n j)))) (\(Hnj : logic.eq (bool.bool) (nat.eqb n j) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n x) bool.true) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.true) x))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) y (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.true) bool.true))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (bool.match::bool::type (nat.nat) j n bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) j y)) (((((((logic.eq::ind) (nat.nat)) (n)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) j x::1)) (((((((logic.eq::ind) (nat.nat)) (n)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) x::1 n)) (((logic.refl) (nat.nat)) (n))) (j)) ((((nat.eqb::true::to::eq) (n)) (j)) (Hnj)))) (i)) ((((nat.eqb::true::to::eq) (n)) (i)) (Hni)))))) (nat.eqb n j)) (Hnj)))) (\(Hnj : logic.eq (bool.bool) (nat.eqb n j) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n x) bool.true) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.true) x))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j y bool.true) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.true) bool.false))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (bool.match::bool::type (nat.nat) j n bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j n bool.true) y)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j n bool.true) y)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) y j)) (((logic.refl) (nat.nat)) (j))))))) (nat.eqb n j)) (Hnj)))) ((bool.true::or::false) (nat.eqb n j)))) (nat.eqb n i)) (Hni)))) (\(Hni : logic.eq (bool.bool) (nat.eqb n i) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n x) (nat.eqb n j)))) (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb n j) bool.true)) (logic.eq (bool.bool) (nat.eqb n j) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.false) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.false) (nat.eqb n j)))) (\(Hnj : logic.eq (bool.bool) (nat.eqb n j) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n x) bool.false) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.false) x))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) y (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.false) bool.true))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) i n bool.true) (bool.match::bool::type (nat.nat) i y bool.true))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) i n bool.true) y)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) y i)) (((logic.refl) (nat.nat)) (i))))))) (nat.eqb n j)) (Hnj)))) (\(Hnj : logic.eq (bool.bool) (nat.eqb n j) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n x) bool.false) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.false) x))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j y bool.false) (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j n bool.false) bool.false))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j n bool.false) (bool.match::bool::type (nat.nat) i y bool.false))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) y (bool.match::bool::type (nat.nat) i n bool.false))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) n y)) (((logic.refl) (nat.nat)) (n))))))) (nat.eqb n j)) (Hnj)))) ((bool.true::or::false) (nat.eqb n j)))) (nat.eqb n i)) (Hni)))) ((bool.true::or::false) (nat.eqb n i))

transpose::transpose : _
transpose::transpose = \(i : nat.nat) -> \(j : nat.nat) -> \(n : nat.nat) -> ((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb n i) bool.true)) (logic.eq (bool.bool) (nat.eqb n i) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) (nat.eqb n i)) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) (nat.eqb n i)) j)) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) (nat.eqb n i)) i)) n)) (\(Hni : logic.eq (bool.bool) (nat.eqb n i) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) j)) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) i)) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n (nat.eqb n j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.true) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.true) j)) (nat.eqb y i)) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n (nat.eqb n j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.true) (nat.eqb y j)) (nat.eqb j i)) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n (nat.eqb n j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i y (nat.eqb j j)) (nat.eqb j i)) n)) (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb j i) bool.true)) (logic.eq (bool.bool) (nat.eqb j i) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j (nat.eqb j j)) (nat.eqb j i)) n)) (\(Hji : logic.eq (bool.bool) (nat.eqb j i) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j (nat.eqb j j)) x) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i j (nat.eqb j j))) (\(y : nat.nat) -> logic.eq (nat.nat) y n)) (((((((logic.eq::ind::r) (nat.nat)) (i)) (\(x : nat.nat) -> logic.eq (nat.nat) j x)) ((((nat.eqb::true::to::eq) (j)) (i)) (Hji))) (n)) ((((nat.eqb::true::to::eq) (n)) (i)) (Hni))))) (nat.eqb j i)) (Hji)))) (\(Hji : logic.eq (bool.bool) (nat.eqb j i) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i j (nat.eqb j j)) x) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i j (nat.eqb j j))) (\(y : nat.nat) -> logic.eq (nat.nat) y n)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) i j x) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (j)) (\(y : nat.nat) -> logic.eq (nat.nat) y n)) (((((logic.sym::eq) (nat.nat)) (n)) (i)) ((((nat.eqb::true::to::eq) (n)) (i)) (Hni))))) (nat.eqb j j)) ((nat.eqb::n::n) (j))))) (nat.eqb j i)) (Hji)))) ((bool.true::or::false) (nat.eqb j i))))))) (nat.eqb n i)) (Hni)))) (\(Hni : logic.eq (bool.bool) (nat.eqb n i) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) j)) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) i)) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n (nat.eqb n j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.false) (nat.eqb (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.false) j)) (nat.eqb y i)) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n (nat.eqb n j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) bool.false) (nat.eqb y j)) (nat.eqb (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) i)) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n (nat.eqb n j))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i y (nat.eqb (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) j)) (nat.eqb (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) i)) n)) (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb n j) bool.true)) (logic.eq (bool.bool) (nat.eqb n j) bool.false)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) (nat.eqb (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) j)) (nat.eqb (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) i)) n)) (\(Hnj : logic.eq (bool.bool) (nat.eqb n j) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n x) (nat.eqb (bool.match::bool::type (nat.nat) i n x) j)) (nat.eqb (bool.match::bool::type (nat.nat) i n x) i)) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n bool.true) (nat.eqb (bool.match::bool::type (nat.nat) i n bool.true) j)) (nat.eqb y i)) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n bool.true) (nat.eqb y j)) (nat.eqb i i)) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i y (nat.eqb i j)) (nat.eqb i i)) n)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i i (nat.eqb i j)) x) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i i (nat.eqb i j))) (\(y : nat.nat) -> logic.eq (nat.nat) y n)) (((((logic.sym::eq) (nat.nat)) (n)) (j)) ((((nat.eqb::true::to::eq) (n)) (j)) (Hnj))))) (nat.eqb i i)) ((nat.eqb::n::n) (i))))))) (nat.eqb n j)) (Hnj)))) (\(Hnj : logic.eq (bool.bool) (nat.eqb n j) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n x) (nat.eqb (bool.match::bool::type (nat.nat) i n x) j)) (nat.eqb (bool.match::bool::type (nat.nat) i n x) i)) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n bool.false) (nat.eqb (bool.match::bool::type (nat.nat) i n bool.false) j)) (nat.eqb y i)) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i (bool.match::bool::type (nat.nat) i n bool.false) (nat.eqb y j)) (nat.eqb n i)) n)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i y (nat.eqb n j)) (nat.eqb n i)) n)) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n (nat.eqb n j)) x) n)) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n x) bool.false) n)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (i)) (n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n bool.false) bool.false) y)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i n bool.false)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n bool.false) bool.false) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i n bool.false) bool.false))))) (nat.eqb n j)) (Hnj))) (nat.eqb n i)) (Hni)))))) (nat.eqb n j)) (Hnj)))) ((bool.true::or::false) (nat.eqb n j))))))) (nat.eqb n i)) (Hni)))) ((bool.true::or::false) (nat.eqb n i))

injective::transpose : _
injective::transpose = \(i : nat.nat) -> \(j : nat.nat) -> \(x : nat.nat) -> \(y : nat.nat) -> \(auto : logic.eq (nat.nat) (transpose i j x) (transpose i j y)) -> (((((((logic.rewrite::r) (nat.nat)) (y)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: y)) (((logic.refl) (nat.nat)) (y))) (x)) (((((((logic.rewrite::l) (nat.nat)) (transpose i j (transpose i j x))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: y)) (((((((logic.rewrite::r) (nat.nat)) (transpose i j y)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (transpose i j ::::) y)) ((((transpose::transpose) (i)) (j)) (y))) (transpose i j x)) (auto))) (x)) ((((transpose::transpose) (i)) (j)) (x))))

permut::S::to::permut::transpose : _
permut::S::to::permut::transpose = \(f : nat.nat -> nat.nat) -> \(m : nat.nat) -> \(::clearme : permut f (nat.S m)) -> ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.le i (nat.S m)) -> nat.le (f i) (nat.S m))) (injn f (nat.S m))) (permut (\(n : nat.nat) -> transpose (f (nat.S m)) (nat.S m) (f n)) m)) (\(permf1 : forall (i : nat.nat) -> (nat.le i (nat.S m)) -> nat.le (f i) (nat.S m)) -> (\(permf2 : injn f (nat.S m)) -> (((((connectives.conj) (forall (x : nat.nat) -> (nat.le x m) -> nat.le (transpose (f (nat.S m)) (nat.S m) (f x)) m)) (injn (\(n : nat.nat) -> transpose (f (nat.S m)) (nat.S m) (f n)) m)) (\(i : nat.nat) -> \(leim : nat.le i m) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> nat.le (bool.match::bool::type (nat.nat) (nat.S m) (bool.match::bool::type (nat.nat) (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m))) x) m)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (nat.S m)) (bool.match::bool::type (nat.nat) (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))) (\(y : nat.nat) -> nat.le y m)) (((((((connectives.match::Or::prop) (nat.lt (f i) (nat.S m))) (logic.eq (nat.nat) (f i) (nat.S m))) (nat.le (bool.match::bool::type (nat.nat) (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m))) m)) (\(Hfi : nat.lt (f i) (nat.S m)) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> nat.le (bool.match::bool::type (nat.nat) (f (nat.S m)) (f i) x) m)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (f (nat.S m))) (f i)) (\(y : nat.nat) -> nat.le y m)) ((((nat.le::S::S::to::le) (f i)) (m)) (Hfi)))) (nat.eqb (f i) (nat.S m))) ((((nat.not::eq::to::eqb::false) (f i)) (nat.S m)) ((((nat.lt::to::not::eq) (f i)) (nat.S m)) (Hfi)))))) (\(Hfi : logic.eq (nat.nat) (f i) (nat.S m)) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> nat.le (bool.match::bool::type (nat.nat) (f (nat.S m)) (f i) x) m)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (f (nat.S m))) (f i)) (\(y : nat.nat) -> nat.le y m)) (((((((connectives.match::Or::prop) (nat.lt (f (nat.S m)) (nat.S m))) (logic.eq (nat.nat) (f (nat.S m)) (nat.S m))) (nat.le (f (nat.S m)) m)) (\(H : nat.lt (f (nat.S m)) (nat.S m)) -> ((((nat.le::S::S::to::le) (f (nat.S m))) (m)) (H)))) (\(H : logic.eq (nat.nat) (f (nat.S m)) (nat.S m)) -> (((connectives.falsity) (nat.le (f (nat.S m)) m)) ((((logic.absurd) (logic.eq (nat.nat) i (nat.S m))) ((((((permf2) (i)) (nat.S m)) ((((nat.le::S) (i)) (m)) (leim))) ((nat.le::n) (nat.S m))) (((((((logic.rewrite::l) (nat.nat)) (f i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f i) (f ::::))) (((((((logic.rewrite::r) (nat.nat)) (f i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f i) ::::)) (((logic.refl) (nat.nat)) (f i))) (f (f i))) (((((((logic.rewrite::r) (nat.nat)) (nat.S m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f (f i)) ::::)) (((((((logic.rewrite::r) (nat.nat)) (nat.S m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f ::::) (nat.S m))) (H)) (f i)) (Hfi))) (f i)) (Hfi)))) (nat.S m)) (Hfi)))) (((((logic.not::to::not) (logic.eq (nat.nat) i (nat.S m))) (nat.le (nat.S m) m)) (\(auto : logic.eq (nat.nat) i (nat.S m)) -> (((((logic.eq::coerc) (nat.le i m)) (nat.le (nat.S m) m)) (leim)) (((((((logic.rewrite::l) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le i m) (nat.le :::: m))) (((logic.refl) (Set)) (nat.le i m))) (nat.S m)) (auto))))) ((((nat.lt::to::not::le) (m)) (nat.S m)) ((nat.le::n) (nat.S m)))))))) ((((nat.le::to::or::lt::eq) (f (nat.S m))) (nat.S m)) (((permf1) (nat.S m)) ((nat.le::n) (nat.S m))))))) (nat.eqb (f i) (nat.S m))) ((((nat.eq::to::eqb::true) (f i)) (nat.S m)) (Hfi))))) ((((nat.le::to::or::lt::eq) (f i)) (nat.S m)) (((permf1) (i)) ((((nat.le::S) (i)) (m)) (leim))))))) (nat.eqb (f i) (f (nat.S m)))) ((((nat.not::eq::to::eqb::false) (f i)) (f (nat.S m))) (((connectives.nmk) (logic.eq (nat.nat) (f i) (f (nat.S m)))) (\(H : logic.eq (nat.nat) (f i) (f (nat.S m))) -> ((((logic.absurd) (logic.eq (nat.nat) i (nat.S m))) ((((((permf2) (i)) (nat.S m)) ((((nat.le::S) (i)) (m)) (leim))) ((nat.le::n) (nat.S m))) (H))) ((((nat.lt::to::not::eq) (i)) (nat.S m)) ((((nat.le::S::S) (i)) (m)) (leim)))))))))) (\(a : nat.nat) -> \(b : nat.nat) -> \(leam : nat.le a m) -> (\(lebm : nat.le b m) -> (\(H : logic.eq (nat.nat) (transpose (f (nat.S m)) (nat.S m) (f a)) (transpose (f (nat.S m)) (nat.S m) (f b))) -> ((((((permf2) (a)) (b)) ((((nat.le::S) (a)) (m)) (leam))) ((((nat.le::S) (b)) (m)) (lebm))) ((((((injective::transpose) (f (nat.S m))) (nat.S m)) (f a)) (f b)) (H)))))))))) (::clearme))

bijn : _
bijn = \(f : (nat.nat -> nat.nat)) -> \(n : nat.nat) -> forall (m : nat.nat) -> (nat.le m n) -> connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f p) m))

eq::to::bijn : _
eq::to::bijn = \(f : nat.nat -> nat.nat) -> \(g : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(H : forall (i : nat.nat) -> (nat.le i n) -> logic.eq (nat.nat) (f i) (g i)) -> (\(bijf : bijn f n) -> (\(i : nat.nat) -> \(lein : nat.le i n) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f p) i))) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (g p) i)))) (\(a : nat.nat) -> \(::clearme : connectives.And (nat.le a n) (logic.eq (nat.nat) (f a) i)) -> ((((((connectives.match::And::prop) (nat.le a n)) (logic.eq (nat.nat) (f a) i)) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (g p) i)))) (\(lean : nat.le a n) -> (\(fa : logic.eq (nat.nat) (f a) i) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x n) (logic.eq (nat.nat) (g x) i))) (a)) (((((connectives.conj) (nat.le a n)) (logic.eq (nat.nat) (g a) i)) (lean)) (((((((logic.eq::ind) (nat.nat)) (f a)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (g a) x::1)) (((((logic.sym::eq) (nat.nat)) (f a)) (g a)) (((H) (a)) (lean)))) (i)) (fa))))))) (::clearme)))) (((bijf) (i)) (lein)))))

bijn::n::Sn : _
bijn::n::Sn = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(bijf : bijn f n) -> (\(fS : logic.eq (nat.nat) (f (nat.S n)) (nat.S n)) -> (\(i : nat.nat) -> \(lein : nat.le i (nat.S n)) -> (((((((connectives.match::Or::prop) (nat.lt i (nat.S n))) (logic.eq (nat.nat) i (nat.S n))) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p (nat.S n)) (logic.eq (nat.nat) (f p) i)))) (\(Hi : nat.lt i (nat.S n)) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f p) i))) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p (nat.S n)) (logic.eq (nat.nat) (f p) i)))) (\(a : nat.nat) -> \(::clearme : connectives.And (nat.le a n) (logic.eq (nat.nat) (f a) i)) -> ((((((connectives.match::And::prop) (nat.le a n)) (logic.eq (nat.nat) (f a) i)) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p (nat.S n)) (logic.eq (nat.nat) (f p) i)))) (\(lean : nat.le a n) -> (\(fa : logic.eq (nat.nat) (f a) i) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x (nat.S n)) (logic.eq (nat.nat) (f x) i))) (a)) (((((connectives.conj) (nat.le a (nat.S n))) (logic.eq (nat.nat) (f a) i)) ((((nat.le::S) (a)) (n)) (lean))) (((((((logic.rewrite::r) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: i)) (((logic.refl) (nat.nat)) (i))) (f a)) (fa))))))) (::clearme)))) (((bijf) (i)) ((((nat.le::S::S::to::le) (i)) (n)) (Hi)))))) (\(Hi : logic.eq (nat.nat) i (nat.S n)) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x (nat.S n)) (logic.eq (nat.nat) (f x) i))) (i)) (((((connectives.conj) (nat.le i (nat.S n))) (logic.eq (nat.nat) (f i) i)) (((((logic.eq::coerc) (nat.le i i)) (nat.le i (nat.S n))) ((nat.le::n) (i))) (((((((logic.rewrite::l) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le i i) (nat.le i ::::))) (((logic.refl) (Set)) (nat.le i i))) (nat.S n)) (Hi)))) (((((((logic.rewrite::r) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: i)) (((logic.refl) (nat.nat)) (i))) (f i)) (((((((logic.rewrite::r) (nat.nat)) (nat.S n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f i) ::::)) (((((((logic.rewrite::r) (nat.nat)) (nat.S n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f ::::) (nat.S n))) (fS)) (i)) (Hi))) (i)) (Hi))))))) ((((nat.le::to::or::lt::eq) (i)) (nat.S n)) (lein)))))

bijn::fg : _
bijn::fg = \(f : nat.nat -> nat.nat) -> \(g : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(bijf : bijn f n) -> (\(bijg : bijn g n) -> (\(i : nat.nat) -> \(lein : nat.le i n) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f p) i))) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f (g p)) i)))) (\(a : nat.nat) -> \(::clearme : connectives.And (nat.le a n) (logic.eq (nat.nat) (f a) i)) -> ((((((connectives.match::And::prop) (nat.le a n)) (logic.eq (nat.nat) (f a) i)) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f (g p)) i)))) (\(lean : nat.le a n) -> (\(ga : logic.eq (nat.nat) (f a) i) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (g p) a))) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f (g p)) i)))) (\(b : nat.nat) -> \(::clearme0 : connectives.And (nat.le b n) (logic.eq (nat.nat) (g b) a)) -> ((((((connectives.match::And::prop) (nat.le b n)) (logic.eq (nat.nat) (g b) a)) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f (g p)) i)))) (\(lebn : nat.le b n) -> (\(gb : logic.eq (nat.nat) (g b) a) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x n) (logic.eq (nat.nat) (f (g x)) i))) (b)) (((((connectives.conj) (nat.le b n)) (logic.eq (nat.nat) (f (g b)) i)) (lebn)) (((((((logic.rewrite::r) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f ::::) i)) (((((((logic.rewrite::r) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: i)) (((logic.refl) (nat.nat)) (i))) (f a)) (ga))) (g b)) (gb))))))) (::clearme0)))) (((bijg) (a)) (lean)))))) (::clearme)))) (((bijf) (i)) (lein)))))

bijn::transpose : _
bijn::transpose = \(n : nat.nat) -> \(i : nat.nat) -> \(j : nat.nat) -> \(lein : nat.le i n) -> (\(lejn : nat.le j n) -> (\(a : nat.nat) -> \(lean : nat.le a n) -> (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb a i) bool.true)) (logic.eq (bool.bool) (nat.eqb a i) bool.false)) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (transpose i j p) a)))) (\(Hi : logic.eq (bool.bool) (nat.eqb a i) bool.true) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x n) (logic.eq (nat.nat) (transpose i j x) a))) (j)) (((((connectives.conj) (nat.le j n)) (logic.eq (nat.nat) (transpose i j j) a)) (lejn)) (((((((logic.eq::ind::r) (nat.nat)) (i)) (\(x : nat.nat) -> logic.eq (nat.nat) x a)) (((((logic.sym::eq) (nat.nat)) (a)) (i)) ((((nat.eqb::true::to::eq) (a)) (i)) (Hi)))) (transpose i j j)) (((transpose::i::j::j) (i)) (j))))))) (\(Hi : logic.eq (bool.bool) (nat.eqb a i) bool.false) -> (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (nat.eqb a j) bool.true)) (logic.eq (bool.bool) (nat.eqb a j) bool.false)) (connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (transpose i j p) a)))) (\(Hj : logic.eq (bool.bool) (nat.eqb a j) bool.true) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x n) (logic.eq (nat.nat) (transpose i j x) a))) (i)) (((((connectives.conj) (nat.le i n)) (logic.eq (nat.nat) (transpose i j i) a)) (lein)) (((((((logic.eq::ind::r) (nat.nat)) (j)) (\(x : nat.nat) -> logic.eq (nat.nat) x a)) (((((logic.sym::eq) (nat.nat)) (a)) (j)) ((((nat.eqb::true::to::eq) (a)) (j)) (Hj)))) (transpose i j i)) (((transpose::i::j::i) (i)) (j))))))) (\(Hj : logic.eq (bool.bool) (nat.eqb a j) bool.false) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x n) (logic.eq (nat.nat) (transpose i j x) a))) (a)) (((((connectives.conj) (nat.le a n)) (logic.eq (nat.nat) (transpose i j a) a)) (lean)) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i a (nat.eqb a j)) x) a)) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i a x) bool.false) a)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (i)) (a)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i a bool.false) bool.false) y)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (j)) (bool.match::bool::type (nat.nat) i a bool.false)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i a bool.false) bool.false) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) j (bool.match::bool::type (nat.nat) i a bool.false) bool.false))))) (nat.eqb a j)) (Hj))) (nat.eqb a i)) (Hi)))))) ((bool.true::or::false) (nat.eqb a j))))) ((bool.true::or::false) (nat.eqb a i)))))

permut::to::bijn : _
permut::to::bijn = \(n : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (f : (nat.nat -> nat.nat)) -> (permut f ::x::365) -> bijn f ::x::365)) (\(f : nat.nat -> nat.nat) -> \(::clearme : connectives.And (forall (i : nat.nat) -> (nat.le i nat.O) -> nat.le (f i) nat.O) (forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i nat.O) -> (nat.le j nat.O) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j)) -> ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.le i nat.O) -> nat.le (f i) nat.O)) (forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i nat.O) -> (nat.le j nat.O) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j)) (forall (m : nat.nat) -> (nat.le m nat.O) -> connectives.ex (nat.nat) (\(p : nat.nat) -> connectives.And (nat.le p nat.O) (logic.eq (nat.nat) (f p) m)))) (\(H : forall (i : nat.nat) -> (nat.le i nat.O) -> nat.le (f i) nat.O) -> (\(H1 : forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i nat.O) -> (nat.le j nat.O) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j) -> (\(m : nat.nat) -> \(lem0 : nat.le m nat.O) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.And (nat.le x nat.O) (logic.eq (nat.nat) (f x) m))) (nat.O)) (((((connectives.conj) (nat.le nat.O nat.O)) (logic.eq (nat.nat) (f nat.O) m)) ((nat.le::O::n) (nat.O))) (((((nat.le::n::O::elim) (m)) (lem0)) (logic.eq (nat.nat) (f nat.O))) (((((logic.sym::eq) (nat.nat)) (nat.O)) (f nat.O)) (((nat.le::n::O::to::eq) (f nat.O)) (((H) (nat.O)) ((nat.le::O::n) (nat.O)))))))))))) (::clearme)))) (\(m : nat.nat) -> \(Hind : forall (f : (nat.nat -> nat.nat)) -> (permut f m) -> bijn f m) -> (\(f : nat.nat -> nat.nat) -> \(permf : permut f (nat.S m)) -> ((((((eq::to::bijn) (\(p : nat.nat) -> transpose (f (nat.S m)) (nat.S m) (transpose (f (nat.S m)) (nat.S m) (f p)))) (f)) (nat.S m)) (\(i : nat.nat) -> \(lei : nat.le i (nat.S m)) -> ((((transpose::transpose) (f (nat.S m))) (nat.S m)) (f i)))) ((((((bijn::fg) (transpose (f (nat.S m)) (nat.S m))) (\(:::: : nat.nat) -> transpose (f (nat.S m)) (nat.S m) (f ::::))) (nat.S m)) ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.le i (nat.S m)) -> nat.le (f i) (nat.S m))) (injn f (nat.S m))) (bijn (transpose (f (nat.S m)) (nat.S m)) (nat.S m))) (\(lef : forall (i : nat.nat) -> (nat.le i (nat.S m)) -> nat.le (f i) (nat.S m)) -> (\(:::: : injn f (nat.S m)) -> ((((((bijn::transpose) (nat.S m)) (f (nat.S m))) (nat.S m)) (((lef) (nat.S m)) ((nat.le::n) (nat.S m)))) ((nat.le::n) (nat.S m)))))) (permf))) (((((bijn::n::Sn) (\(:::: : nat.nat) -> transpose (f (nat.S m)) (nat.S m) (f ::::))) (m)) (((Hind) (\(:::: : nat.nat) -> transpose (f (nat.S m)) (nat.S m) (f ::::))) ((((permut::S::to::permut::transpose) (f)) (m)) (permf)))) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (nat.S m) (bool.match::bool::type (nat.nat) (f (nat.S m)) (f (nat.S m)) (nat.eqb (f (nat.S m)) (nat.S m))) x) (nat.S m))) ((((((bool.eq::match::bool::type::true) (nat.nat)) (nat.S m)) (bool.match::bool::type (nat.nat) (f (nat.S m)) (f (nat.S m)) (nat.eqb (f (nat.S m)) (nat.S m)))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (nat.S m) (bool.match::bool::type (nat.nat) (f (nat.S m)) (f (nat.S m)) (nat.eqb (f (nat.S m)) (nat.S m))) bool.true) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) (nat.S m) (bool.match::bool::type (nat.nat) (f (nat.S m)) (f (nat.S m)) (nat.eqb (f (nat.S m)) (nat.S m))) bool.true)))) (nat.eqb (f (nat.S m)) (f (nat.S m)))) ((nat.eqb::n::n) (f (nat.S m)))))))))) (n)

postulate invert::permut : nat.nat -> (nat.nat -> nat.nat) -> nat.nat -> nat.nat
postulate invert::permut::body : nat.nat -> (nat.nat -> nat.nat) -> nat.nat -> nat.nat
postulate axiom::invert::permut : forall (n : nat.nat) -> connectives.equal ((nat.nat -> nat.nat) -> nat.nat -> nat.nat) (invert::permut n) (nat.filter::nat::type ((nat.nat -> nat.nat) -> nat.nat -> nat.nat) invert::permut::body n)
eq::invert::permut : {j : Level} -> _
eq::invert::permut {j} = \(n : nat.nat) -> ((((connectives.equal::leibniz {_} {j}) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut n)) (nat.filter::nat::type ((nat.nat -> nat.nat) -> nat.nat -> nat.nat) invert::permut::body n)) ((axiom::invert::permut) (n))

sym::eq::invert::permut : {j : Level} -> _
sym::eq::invert::permut {j} = \(n : nat.nat) -> ((((leibniz.sym::leibniz {_} {j}) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut n)) (nat.filter::nat::type ((nat.nat -> nat.nat) -> nat.nat -> nat.nat) invert::permut::body n)) ((eq::invert::permut) (n))

postulate axiom::invert::permut::body::O : connectives.equal ((nat.nat -> nat.nat) -> nat.nat -> nat.nat) (invert::permut::body nat.O) (\(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) nat.O nat.O (nat.eqb m (f nat.O)))
eq::invert::permut::body::O : {j : Level} -> _
eq::invert::permut::body::O {j} = ((((connectives.equal::leibniz {_} {j}) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body nat.O)) (\(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) nat.O nat.O (nat.eqb m (f nat.O)))) (axiom::invert::permut::body::O)

sym::eq::invert::permut::body::O : {j : Level} -> _
sym::eq::invert::permut::body::O {j} = ((((leibniz.sym::leibniz {_} {j}) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body nat.O)) (\(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) nat.O nat.O (nat.eqb m (f nat.O)))) (eq::invert::permut::body::O)

postulate axiom::invert::permut::body::S : forall (n : nat.nat) -> connectives.equal ((nat.nat -> nat.nat) -> nat.nat -> nat.nat) (invert::permut::body (nat.S n)) (\(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) (nat.S n) (invert::permut n f m) (nat.eqb m (f (nat.S n))))
eq::invert::permut::body::S : {j : Level} -> _
eq::invert::permut::body::S {j} = \(n : nat.nat) -> ((((connectives.equal::leibniz {_} {j}) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body (nat.S n))) (\(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) (nat.S n) (invert::permut n f m) (nat.eqb m (f (nat.S n))))) ((axiom::invert::permut::body::S) (n))

sym::eq::invert::permut::body::S : {j : Level} -> _
sym::eq::invert::permut::body::S {j} = \(n : nat.nat) -> ((((leibniz.sym::leibniz {_} {j}) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body (nat.S n))) (\(f : (nat.nat -> nat.nat)) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) (nat.S n) (invert::permut n f m) (nat.eqb m (f (nat.S n))))) ((eq::invert::permut::body::S) (n))

invert::permut::f : _
invert::permut::f = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(m : nat.nat) -> \(lenm : nat.le m n) -> (((((((nat.le::ind) (m)) (\(x::417 : nat.nat) -> (injn f x::417) -> logic.eq (nat.nat) (invert::permut x::417 f (f m)) m)) (((((nat.match::nat::prop) (\(:::: : nat.nat) -> (injn f ::::) -> logic.eq (nat.nat) (invert::permut :::: f (f ::::)) ::::)) ((((sym::eq::invert::permut) (nat.O)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (injn f nat.O) -> logic.eq (nat.nat) (y f (f nat.O)) nat.O)) (((((nat.sym::eq::filter::nat::type::O) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (injn f nat.O) -> logic.eq (nat.nat) (y f (f nat.O)) nat.O)) (((sym::eq::invert::permut::body::O) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (injn f nat.O) -> logic.eq (nat.nat) (y f (f nat.O)) nat.O)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> (forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i nat.O) -> (nat.le j nat.O) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) nat.O nat.O x) nat.O)) (\(auto : forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i nat.O) -> (nat.le j nat.O) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j) -> ((((((bool.eq::match::bool::type::true) (nat.nat)) (nat.O)) (nat.O)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) nat.O nat.O bool.true) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) nat.O nat.O bool.true))))) (nat.eqb (f nat.O) (f nat.O))) ((nat.eqb::n::n) (f nat.O))))))) (\(a : nat.nat) -> (((sym::eq::invert::permut) (nat.S a)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (injn f (nat.S a)) -> logic.eq (nat.nat) (y f (f (nat.S a))) (nat.S a))) ((((((nat.sym::eq::filter::nat::type::S) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body)) (a)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (injn f (nat.S a)) -> logic.eq (nat.nat) (y f (f (nat.S a))) (nat.S a))) ((((sym::eq::invert::permut::body::S) (a)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (injn f (nat.S a)) -> logic.eq (nat.nat) (y f (f (nat.S a))) (nat.S a))) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> (forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i (nat.S a)) -> (nat.le j (nat.S a)) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (nat.S a) (invert::permut a f (f (nat.S a))) x) (nat.S a))) (\(auto : forall (i : nat.nat) -> forall (j : nat.nat) -> (nat.le i (nat.S a)) -> (nat.le j (nat.S a)) -> (logic.eq (nat.nat) (f i) (f j)) -> logic.eq (nat.nat) i j) -> ((((((bool.eq::match::bool::type::true) (nat.nat)) (nat.S a)) (invert::permut a f (f (nat.S a)))) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (nat.S a) (invert::permut a f (f (nat.S a))) bool.true) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) (nat.S a) (invert::permut a f (f (nat.S a))) bool.true))))) (nat.eqb (f (nat.S a)) (f (nat.S a)))) ((nat.eqb::n::n) (f (nat.S a)))))))) (m))) (\(m0 : nat.nat) -> (((sym::eq::invert::permut) (nat.S m0)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (nat.le m m0) -> ((injn f m0) -> logic.eq (nat.nat) (invert::permut m0 f (f m)) m) -> (injn f (nat.S m0)) -> logic.eq (nat.nat) (y f (f m)) m)) ((((((nat.sym::eq::filter::nat::type::S) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body)) (m0)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (nat.le m m0) -> ((injn f m0) -> logic.eq (nat.nat) (invert::permut m0 f (f m)) m) -> (injn f (nat.S m0)) -> logic.eq (nat.nat) (y f (f m)) m)) ((((sym::eq::invert::permut::body::S) (m0)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (nat.le m m0) -> ((injn f m0) -> logic.eq (nat.nat) (invert::permut m0 f (f m)) m) -> (injn f (nat.S m0)) -> logic.eq (nat.nat) (y f (f m)) m)) (\(lem : nat.le m m0) -> (\(H : (injn f m0) -> logic.eq (nat.nat) (invert::permut m0 f (f m)) m) -> (\(H1 : injn f (nat.S m0)) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (nat.S m0) (invert::permut m0 f (f m)) x) m)) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (nat.S m0)) (invert::permut m0 f (f m))) (\(y : nat.nat) -> logic.eq (nat.nat) y m)) ((H) ((((injn::Sn::n) (f)) (m0)) (H1))))) (nat.eqb (f m) (f (nat.S m0)))) ((((nat.not::eq::to::eqb::false) (f m)) (f (nat.S m0))) (((connectives.nmk) (logic.eq (nat.nat) (f m) (f (nat.S m0)))) (\(eqf : logic.eq (nat.nat) (f m) (f (nat.S m0))) -> ((((logic.absurd) (logic.eq (nat.nat) m (nat.S m0))) ((((((H1) (m)) (nat.S m0)) ((((nat.le::S) (m)) (m0)) (lem))) ((nat.le::n) (nat.S m0))) (((((((logic.rewrite::l) (nat.nat)) (f m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (f m) ::::)) (((logic.refl) (nat.nat)) (f m))) (f (nat.S m0))) (eqf)))) ((((nat.lt::to::not::eq) (m)) (nat.S m0)) ((((nat.le::S::S) (m)) (m0)) (lem))))))))))))))) (n)) (lenm))

let::clause::1063 : _
let::clause::1063 = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(permf : permut f n) -> (\(i : nat.nat) -> \(j : nat.nat) -> \(lein : nat.le i n) -> (\(lejn : nat.le j n) -> (\(a : nat.nat) -> \(::clearme : connectives.And (nat.le a n) (logic.eq (nat.nat) (f a) i)) -> (\(lean : nat.le a n) -> (\(fa : logic.eq (nat.nat) (f a) i) -> (\(b : nat.nat) -> \(::clearme0 : connectives.And (nat.le b n) (logic.eq (nat.nat) (f b) j)) -> (\(lebn : nat.le b n) -> (\(fb : logic.eq (nat.nat) (f b) j) -> (\(:::: : forall (i0 : nat.nat) -> (nat.le i0 n) -> nat.le (f i0) n) -> (\(injf : injn f n) -> (\(auto : logic.eq (nat.nat) a b) -> (((((((logic.rewrite::r) (nat.nat)) (b)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) (f ::::1) j)) (fb)) (a)) (auto)))))))))))))

let::clause::1068 : _
let::clause::1068 = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(permf : permut f n) -> (\(i : nat.nat) -> \(j : nat.nat) -> \(lein : nat.le i n) -> (\(lejn : nat.le j n) -> (\(a : nat.nat) -> \(::clearme : connectives.And (nat.le a n) (logic.eq (nat.nat) (f a) i)) -> (\(lean : nat.le a n) -> (\(fa : logic.eq (nat.nat) (f a) i) -> (\(b : nat.nat) -> \(::clearme0 : connectives.And (nat.le b n) (logic.eq (nat.nat) (f b) j)) -> (\(lebn : nat.le b n) -> (\(fb : logic.eq (nat.nat) (f b) j) -> (\(:::: : forall (i0 : nat.nat) -> (nat.le i0 n) -> nat.le (f i0) n) -> (\(injf : injn f n) -> (\(auto : logic.eq (nat.nat) a b) -> (((((((logic.rewrite::l) (nat.nat)) (j)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) (f a) ::::1)) (((((((((((((((((((let::clause::1063) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (::clearme)) (lean)) (fa)) (b)) (::clearme0)) (lebn)) (fb)) (::::)) (injf)) (auto))) (i)) (((((((logic.rewrite::l) (nat.nat)) (f a)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) ::::1 i)) (fa)) (j)) (((((((((((((((((((let::clause::1063) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (::clearme)) (lean)) (fa)) (b)) (::clearme0)) (lebn)) (fb)) (::::)) (injf)) (auto)))))))))))))))

injective::invert::permut : _
injective::invert::permut = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(permf : permut f n) -> (\(i : nat.nat) -> \(j : nat.nat) -> \(lein : nat.le i n) -> (\(lejn : nat.le j n) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f p) i))) ((logic.eq (nat.nat) (invert::permut n f i) (invert::permut n f j)) -> logic.eq (nat.nat) i j)) (\(a : nat.nat) -> \(::clearme : connectives.And (nat.le a n) (logic.eq (nat.nat) (f a) i)) -> ((((((connectives.match::And::prop) (nat.le a n)) (logic.eq (nat.nat) (f a) i)) ((logic.eq (nat.nat) (invert::permut n f i) (invert::permut n f j)) -> logic.eq (nat.nat) i j)) (\(lean : nat.le a n) -> (\(fa : logic.eq (nat.nat) (f a) i) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(p : nat.nat) -> connectives.And (nat.le p n) (logic.eq (nat.nat) (f p) j))) ((logic.eq (nat.nat) (invert::permut n f i) (invert::permut n f j)) -> logic.eq (nat.nat) i j)) (\(b : nat.nat) -> \(::clearme0 : connectives.And (nat.le b n) (logic.eq (nat.nat) (f b) j)) -> ((((((connectives.match::And::prop) (nat.le b n)) (logic.eq (nat.nat) (f b) j)) ((logic.eq (nat.nat) (invert::permut n f i) (invert::permut n f j)) -> logic.eq (nat.nat) i j)) (\(lebn : nat.le b n) -> (\(fb : logic.eq (nat.nat) (f b) j) -> ((((((connectives.match::And::prop) (forall (i1 : nat.nat) -> (nat.le i1 n) -> nat.le (f i1) n)) (injn f n)) ((logic.eq (nat.nat) (invert::permut n f i) (invert::permut n f j)) -> logic.eq (nat.nat) i j)) (\(:::: : forall (i0 : nat.nat) -> (nat.le i0 n) -> nat.le (f i0) n) -> (\(injf : injn f n) -> (((((((logic.eq::ind) (nat.nat)) (f a)) (\(x::1 : nat.nat) -> (logic.eq (nat.nat) (invert::permut n f x::1) (invert::permut n f j)) -> logic.eq (nat.nat) x::1 j)) (((((((logic.eq::ind) (nat.nat)) (f b)) (\(x::1 : nat.nat) -> (logic.eq (nat.nat) (invert::permut n f (f a)) (invert::permut n f x::1)) -> logic.eq (nat.nat) (f a) x::1)) (((((((logic.eq::ind::r) (nat.nat)) (a)) (\(x : nat.nat) -> (logic.eq (nat.nat) x (invert::permut n f (f b))) -> logic.eq (nat.nat) (f a) (f b))) (((((((logic.eq::ind::r) (nat.nat)) (b)) (\(x : nat.nat) -> (logic.eq (nat.nat) a x) -> logic.eq (nat.nat) (f a) (f b))) (\(auto : logic.eq (nat.nat) a b) -> (((((((logic.rewrite::r) (nat.nat)) (i)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) ::::1 (f b))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) i (f ::::1))) (((((((logic.rewrite::r) (nat.nat)) (i)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) i ::::1)) (((logic.refl) (nat.nat)) (i))) (f a)) (((((((((((((((((((let::clause::1068) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (::clearme)) (lean)) (fa)) (b)) (::clearme0)) (lebn)) (fb)) (::::)) (injf)) (auto)))) (b)) (auto))) (f a)) (((((((((((((((((((let::clause::1068) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (::clearme)) (lean)) (fa)) (b)) (::clearme0)) (lebn)) (fb)) (::::)) (injf)) (auto))))) (invert::permut n f (f b))) ((((((invert::permut::f) (f)) (n)) (b)) (lebn)) (injf)))) (invert::permut n f (f a))) ((((((invert::permut::f) (f)) (n)) (a)) (lean)) (injf)))) (j)) (fb))) (i)) (fa))))) (permf))))) (::clearme0)))) ((((((permut::to::bijn) (n)) (f)) (permf)) (j)) (lejn)))))) (::clearme)))) ((((((permut::to::bijn) (n)) (f)) (permf)) (i)) (lein)))))

permut::invert::permut : _
permut::invert::permut = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(permf : permut f n) -> (((((connectives.conj) (forall (x : nat.nat) -> (nat.le x n) -> nat.le (invert::permut n f x) n)) (injn (invert::permut n f) n)) (\(i : nat.nat) -> \(lein : nat.le i n) -> (((((nat.nat::ind) (\(::x::365 : nat.nat) -> nat.le (invert::permut ::x::365 f i) ::x::365)) ((((sym::eq::invert::permut) (nat.O)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> nat.le (y f i) nat.O)) (((((nat.sym::eq::filter::nat::type::O) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> nat.le (y f i) nat.O)) (((sym::eq::invert::permut::body::O) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> nat.le (y f i) nat.O)) (((((bool.match::bool::prop) (\(:::: : bool.bool) -> nat.le (bool.match::bool::type (nat.nat) nat.O nat.O ::::) nat.O)) ((((((bool.eq::match::bool::type::true) (nat.nat)) (nat.O)) (nat.O)) (\(y : nat.nat) -> nat.le (bool.match::bool::type (nat.nat) nat.O nat.O bool.true) y)) ((nat.le::n) (bool.match::bool::type (nat.nat) nat.O nat.O bool.true)))) ((((((bool.eq::match::bool::type::false) (nat.nat)) (nat.O)) (nat.O)) (\(y : nat.nat) -> nat.le (bool.match::bool::type (nat.nat) nat.O nat.O bool.false) y)) ((nat.le::n) (bool.match::bool::type (nat.nat) nat.O nat.O bool.false)))) (nat.eqb i (f nat.O))))))) (\(n1 : nat.nat) -> (((sym::eq::invert::permut) (nat.S n1)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (nat.le (invert::permut n1 f i) n1) -> nat.le (y f i) (nat.S n1))) ((((((nat.sym::eq::filter::nat::type::S) ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) (invert::permut::body)) (n1)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (nat.le (invert::permut n1 f i) n1) -> nat.le (y f i) (nat.S n1))) ((((sym::eq::invert::permut::body::S) (n1)) (\(y : ((nat.nat -> nat.nat) -> nat.nat -> nat.nat)) -> (nat.le (invert::permut n1 f i) n1) -> nat.le (y f i) (nat.S n1))) (\(Hind : nat.le (invert::permut n1 f i) n1) -> (((((bool.match::bool::prop) (\(:::: : bool.bool) -> nat.le (bool.match::bool::type (nat.nat) (nat.S n1) (invert::permut n1 f i) ::::) (nat.S n1))) ((((((bool.eq::match::bool::type::true) (nat.nat)) (nat.S n1)) (invert::permut n1 f i)) (\(y : nat.nat) -> nat.le (bool.match::bool::type (nat.nat) (nat.S n1) (invert::permut n1 f i) bool.true) y)) ((nat.le::n) (bool.match::bool::type (nat.nat) (nat.S n1) (invert::permut n1 f i) bool.true)))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (nat.S n1)) (invert::permut n1 f i)) (\(y : nat.nat) -> nat.le y (nat.S n1))) ((((nat.le::S) (invert::permut n1 f i)) (n1)) (Hind)))) (nat.eqb i (f (nat.S n1))))))))) (n)))) ((((injective::invert::permut) (f)) (n)) (permf)))

f::invert::permut : _
f::invert::permut = \(f : nat.nat -> nat.nat) -> \(n : nat.nat) -> \(m : nat.nat) -> \(lemn : nat.le m n) -> (\(permf : permut f n) -> ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.le i n) -> nat.le (invert::permut n f i) n)) (injn (invert::permut n f) n)) (logic.eq (nat.nat) (f (invert::permut n f m)) m)) (\(Hle : forall (i : nat.nat) -> (nat.le i n) -> nat.le (invert::permut n f i) n) -> (\(Hinj : injn (invert::permut n f) n) -> ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.le i n) -> nat.le (f i) n)) (injn f n)) (logic.eq (nat.nat) (f (invert::permut n f m)) m)) (\(lef : forall (i : nat.nat) -> (nat.le i n) -> nat.le (f i) n) -> (\(injf : injn f n) -> (((((((((injective::invert::permut) (f)) (n)) (permf)) (f (invert::permut n f m))) (m)) (((lef) (invert::permut n f m)) (((Hle) (m)) (lemn)))) (lemn)) ((((((invert::permut::f) (f)) (n)) (invert::permut n f m)) (((Hle) (m)) (lemn))) (injf)))))) (permf))))) ((((permut::invert::permut) (f)) (n)) (permf))))

