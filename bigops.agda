module bigops where
open import Agda.Primitive
import bool
import connectives
import div::mod
import logic
import nat
sameF::upto : (A : Set) -> nat.nat -> (nat.nat -> A) -> (nat.nat -> A) -> Set
sameF::upto = \(A : Set) -> \(k : nat.nat) -> \(f : (nat.nat -> A)) -> \(g : (nat.nat -> A)) -> forall (i : nat.nat) -> (nat.lt i k) -> logic.eq (A) (f i) (g i)

sameF::p : (A : Set) -> nat.nat -> (nat.nat -> bool.bool) -> (nat.nat -> A) -> (nat.nat -> A) -> Set
sameF::p = \(A : Set) -> \(k : nat.nat) -> \(p : (nat.nat -> bool.bool)) -> \(f : (nat.nat -> A)) -> \(g : (nat.nat -> A)) -> forall (i : nat.nat) -> (nat.lt i k) -> (logic.eq (bool.bool) (p i) bool.true) -> logic.eq (A) (f i) (g i)

sameF::upto::le : (A : Set) -> forall (f : (nat.nat -> A)) -> forall (g : (nat.nat -> A)) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n m) -> (sameF::upto (A) m f g) -> sameF::upto (A) n f g
sameF::upto::le = \(A : Set) -> \(f : nat.nat -> A) -> \(g : nat.nat -> A) -> \(n : nat.nat) -> \(m : nat.nat) -> \(lenm : nat.le n m) -> (\(samef : sameF::upto (A) m f g) -> (\(i : nat.nat) -> \(ltin : nat.lt i n) -> (((samef) (i)) ((((((nat.lt::to::le::to::lt) (i)) (n)) (m)) (ltin)) (lenm)))))

sameF::p::le : (A : Set) -> forall (p : (nat.nat -> bool.bool)) -> forall (f : (nat.nat -> A)) -> forall (g : (nat.nat -> A)) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n m) -> (sameF::p (A) m p f g) -> sameF::p (A) n p f g
sameF::p::le = \(A : Set) -> \(p : nat.nat -> bool.bool) -> \(f : nat.nat -> A) -> \(g : nat.nat -> A) -> \(n : nat.nat) -> \(m : nat.nat) -> \(lenm : nat.le n m) -> (\(samef : sameF::p (A) m p f g) -> (\(i : nat.nat) -> \(ltin : nat.lt i n) -> (\(pi : logic.eq (bool.bool) (p i) bool.true) -> ((((samef) (i)) ((((((nat.lt::to::le::to::lt) (i)) (n)) (m)) (ltin)) (lenm))) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p i)) (pi))))))

postulate bigop : (H : Set) -> nat.nat -> (nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H
postulate bigop::body : (H : Set) -> nat.nat -> (nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H
postulate axiom::bigop::O : (H : Set) -> connectives.equal ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) (bigop (H) nat.O) (bigop::body (H) nat.O)
eq::bigop::O : (H : Set) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (bigop (H) nat.O)) -> P (bigop::body (H) nat.O)
eq::bigop::O = \(H : Set) -> ((((connectives.equal::leibniz) ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) (bigop (H) nat.O)) (bigop::body (H) nat.O)) ((axiom::bigop::O) (H))

sym::eq::bigop::O : (H : Set) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (bigop::body (H) nat.O)) -> P (bigop (H) nat.O)
sym::eq::bigop::O = \(H : Set) -> \(P : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set) -> \(H0 : P (bigop::body (H) nat.O)) -> (((((eq::bigop::O) (H)) (\(a : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) -> (P a) -> P (bigop (H) nat.O))) (\(px : P (bigop (H) nat.O)) -> (px))) (H0))

postulate axiom::bigop::S : (H : Set) -> forall (n : nat.nat) -> connectives.equal ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) (bigop (H) (nat.S n)) (bigop::body (H) (nat.S n))
eq::bigop::S : (H : Set) -> forall (n : nat.nat) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (bigop (H) (nat.S n))) -> P (bigop::body (H) (nat.S n))
eq::bigop::S = \(H : Set) -> \(n : nat.nat) -> ((((connectives.equal::leibniz) ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) (bigop (H) (nat.S n))) (bigop::body (H) (nat.S n))) (((axiom::bigop::S) (H)) (n))

sym::eq::bigop::S : (H : Set) -> forall (n : nat.nat) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (bigop::body (H) (nat.S n))) -> P (bigop (H) (nat.S n))
sym::eq::bigop::S = \(H : Set) -> \(n : nat.nat) -> \(P : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set) -> \(H0 : P (bigop::body (H) (nat.S n))) -> ((((((eq::bigop::S) (H)) (n)) (\(a : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) -> (P a) -> P (bigop (H) (nat.S n)))) (\(px : P (bigop (H) (nat.S n))) -> (px))) (H0))

postulate axiom::bigop::body::O : (H : Set) -> connectives.equal ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) (bigop::body (H) nat.O) (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> nil)
eq::bigop::body::O : (H : Set) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (bigop::body (H) nat.O)) -> P (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> nil)
eq::bigop::body::O = \(H : Set) -> ((((connectives.equal::leibniz) ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) (bigop::body (H) nat.O)) (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> nil)) ((axiom::bigop::body::O) (H))

sym::eq::bigop::body::O : (H : Set) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> nil)) -> P (bigop::body (H) nat.O)
sym::eq::bigop::body::O = \(H : Set) -> \(P : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set) -> \(H0 : P (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> nil)) -> (((((eq::bigop::body::O) (H)) (\(a : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) -> (P a) -> P (bigop::body (H) nat.O))) (\(px : P (bigop::body (H) nat.O)) -> (px))) (H0))

postulate axiom::bigop::body::S : (H : Set) -> forall (n : nat.nat) -> connectives.equal ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) (bigop::body (H) (nat.S n)) (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> bool.match::bool::type (H) (op (f n) (bigop (H) n p nil op f)) (bigop (H) n p nil op f) (p n))
eq::bigop::body::S : (H : Set) -> forall (n : nat.nat) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (bigop::body (H) (nat.S n))) -> P (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> bool.match::bool::type (H) (op (f n) (bigop (H) n p nil op f)) (bigop (H) n p nil op f) (p n))
eq::bigop::body::S = \(H : Set) -> \(n : nat.nat) -> ((((connectives.equal::leibniz) ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) (bigop::body (H) (nat.S n))) (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> bool.match::bool::type (H) (op (f n) (bigop (H) n p nil op f)) (bigop (H) n p nil op f) (p n))) (((axiom::bigop::body::S) (H)) (n))

sym::eq::bigop::body::S : (H : Set) -> forall (n : nat.nat) -> forall (P : (((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set)) -> (P (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> bool.match::bool::type (H) (op (f n) (bigop (H) n p nil op f)) (bigop (H) n p nil op f) (p n))) -> P (bigop::body (H) (nat.S n))
sym::eq::bigop::body::S = \(H : Set) -> \(n : nat.nat) -> \(P : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H) -> Set) -> \(H0 : P (\(p : (nat.nat -> bool.bool)) -> \(nil : H) -> \(op : (H -> H -> H)) -> \(f : (nat.nat -> H)) -> bool.match::bool::type (H) (op (f n) (bigop (H) n p nil op f)) (bigop (H) n p nil op f) (p n))) -> ((((((eq::bigop::body::S) (H)) (n)) (\(a : ((nat.nat -> bool.bool) -> H -> (H -> H -> H) -> (nat.nat -> H) -> H)) -> (P a) -> P (bigop::body (H) (nat.S n)))) (\(px : P (bigop::body (H) (nat.S n))) -> (px))) (H0))

bigop::Strue : (B : Set) -> forall (k : nat.nat) -> forall (p : (nat.nat -> bool.bool)) -> forall (nil : B) -> forall (op : (B -> B -> B)) -> forall (f : (nat.nat -> B)) -> (logic.eq (bool.bool) (p k) bool.true) -> logic.eq (B) (bigop (B) (nat.S k) (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))
bigop::Strue = \(B : Set) -> \(k : nat.nat) -> \(p : nat.nat -> bool.bool) -> \(nil : B) -> \(op : B -> B -> B) -> \(f : nat.nat -> B) -> ((((sym::eq::bigop::S) (B)) (k)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (logic.eq (bool.bool) (p k) bool.true) -> logic.eq (B) (y (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))))) (((((sym::eq::bigop::body::S) (B)) (k)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (logic.eq (bool.bool) (p k) bool.true) -> logic.eq (B) (y (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))))) (\(H : logic.eq (bool.bool) (p k) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (B) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) x) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))))) (((((((connectives.equal::leibniz) (B)) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) bool.true)) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) ((((bool.axiom::match::bool::type::true) (B)) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (\(y : B) -> logic.eq (B) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) bool.true) y)) (((logic.refl) (B)) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) bool.true)))) (p k)) (H))))

bigop::Sfalse : (B : Set) -> forall (k : nat.nat) -> forall (p : (nat.nat -> bool.bool)) -> forall (nil : B) -> forall (op : (B -> B -> B)) -> forall (f : (nat.nat -> B)) -> (logic.eq (bool.bool) (p k) bool.false) -> logic.eq (B) (bigop (B) (nat.S k) (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))
bigop::Sfalse = \(B : Set) -> \(k : nat.nat) -> \(p : nat.nat -> bool.bool) -> \(nil : B) -> \(op : B -> B -> B) -> \(f : nat.nat -> B) -> ((((sym::eq::bigop::S) (B)) (k)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (logic.eq (bool.bool) (p k) bool.false) -> logic.eq (B) (y (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (((((sym::eq::bigop::body::S) (B)) (k)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (logic.eq (bool.bool) (p k) bool.false) -> logic.eq (B) (y (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (\(H : logic.eq (bool.bool) (p k) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (B) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) x) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (((((((connectives.equal::leibniz) (B)) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) bool.false)) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) ((((bool.axiom::match::bool::type::false) (B)) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)))) (\(y : B) -> logic.eq (B) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) bool.false) y)) (((logic.refl) (B)) (bool.match::bool::type (B) (op (f k) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i))) (bigop (B) k (\(i : nat.nat) -> p i) nil op (\(i : nat.nat) -> f i)) bool.false)))) (p k)) (H))))

same::bigop : (B : Set) -> forall (k : nat.nat) -> forall (p1 : (nat.nat -> bool.bool)) -> forall (p2 : (nat.nat -> bool.bool)) -> forall (nil : B) -> forall (op : (B -> B -> B)) -> forall (f : (nat.nat -> B)) -> forall (g : (nat.nat -> B)) -> (sameF::upto (bool.bool) k p1 p2) -> (sameF::p (B) k p1 f g) -> logic.eq (B) (bigop (B) k (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) k (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))
same::bigop = \(B : Set) -> \(k : nat.nat) -> \(p1 : nat.nat -> bool.bool) -> \(p2 : nat.nat -> bool.bool) -> \(nil : B) -> \(op : B -> B -> B) -> \(f : nat.nat -> B) -> \(g : nat.nat -> B) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> (sameF::upto (bool.bool) ::x::365 p1 p2) -> (sameF::p (B) ::x::365 p1 f g) -> logic.eq (B) (bigop (B) ::x::365 (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) ::x::365 (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) ((((sym::eq::bigop::O) (B)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (sameF::upto (bool.bool) nat.O p1 p2) -> (sameF::p (B) nat.O p1 f g) -> logic.eq (B) (bigop (B) nat.O (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) ((((sym::eq::bigop::body::O) (B)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (sameF::upto (bool.bool) nat.O p1 p2) -> (sameF::p (B) nat.O p1 f g) -> logic.eq (B) (bigop (B) nat.O (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) ((((eq::bigop::body::O) (B)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (sameF::upto (bool.bool) nat.O p1 p2) -> (sameF::p (B) nat.O p1 f g) -> logic.eq (B) (bigop (B) nat.O (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)))) ((((eq::bigop::O) (B)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> (sameF::upto (bool.bool) nat.O p1 p2) -> (sameF::p (B) nat.O p1 f g) -> logic.eq (B) (bigop (B) nat.O (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)))) (\(auto : sameF::upto (bool.bool) nat.O p1 p2) -> (\(auto' : sameF::p (B) nat.O p1 f g) -> (((logic.refl) (B)) (bigop (B) nat.O (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)))))))))) (\(n : nat.nat) -> ((((sym::eq::bigop::S) (B)) (n)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> ((sameF::upto (bool.bool) n p1 p2) -> (sameF::p (B) n p1 f g) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) -> (sameF::upto (bool.bool) (nat.S n) p1 p2) -> (sameF::p (B) (nat.S n) p1 f g) -> logic.eq (B) (bigop (B) (nat.S n) (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (((((sym::eq::bigop::S) (B)) (n)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> ((sameF::upto (bool.bool) n p1 p2) -> (sameF::p (B) n p1 f g) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) -> (sameF::upto (bool.bool) (nat.S n) p1 p2) -> (sameF::p (B) (nat.S n) p1 f g) -> logic.eq (B) (y (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop::body (B) (nat.S n) (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (((((sym::eq::bigop::body::S) (B)) (n)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> ((sameF::upto (bool.bool) n p1 p2) -> (sameF::p (B) n p1 f g) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) -> (sameF::upto (bool.bool) (nat.S n) p1 p2) -> (sameF::p (B) (nat.S n) p1 f g) -> logic.eq (B) (y (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop::body (B) (nat.S n) (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (((((sym::eq::bigop::body::S) (B)) (n)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> ((sameF::upto (bool.bool) n p1 p2) -> (sameF::p (B) n p1 f g) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) -> (sameF::upto (bool.bool) (nat.S n) p1 p2) -> (sameF::p (B) (nat.S n) p1 f g) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i))) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (p1 n)) (y (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (\(Hind : (sameF::upto (bool.bool) n p1 p2) -> (sameF::p (B) n p1 f g) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) -> (\(samep : sameF::upto (bool.bool) (nat.S n) p1 p2) -> (\(samef : sameF::p (B) (nat.S n) p1 f g) -> (((((((logic.eq::ind::r) (B)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (\(x : B) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) x) x (p1 n)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) (p2 n)))) (((((((logic.eq::ind) (bool.bool)) (p1 n)) (\(x::1 : bool.bool) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) (p1 n)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) x::1))) (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (p1 n) bool.true)) (logic.eq (bool.bool) (p1 n) bool.false)) (logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) (p1 n)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) (p1 n)))) (\(H1 : logic.eq (bool.bool) (p1 n) bool.true) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) x) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) x))) ((((((((connectives.equal::leibniz) (B)) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true)) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) ((((bool.axiom::match::bool::type::true) (B)) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (\(a : B) -> (logic.eq (B) a (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true)) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true))) (\(px : logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true)) -> (px))) ((((((((connectives.equal::leibniz) (B)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true)) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) ((((bool.axiom::match::bool::type::true) (B)) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (\(a : B) -> (logic.eq (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) a) -> logic.eq (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true))) (\(px : logic.eq (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.true)) -> (px))) (((((((logic.eq::ind) (B)) (f n)) (\(x::1 : B) -> logic.eq (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (op x::1 (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))))) (((logic.refl) (B)) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))))) (g n)) ((((samef) (n)) ((nat.le::n) (nat.S n))) (H1)))))) (p1 n)) (H1)))) (\(H1 : logic.eq (bool.bool) (p1 n) bool.false) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) x) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) x))) ((((((((connectives.equal::leibniz) (B)) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) ((((bool.axiom::match::bool::type::false) (B)) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (\(a : B) -> (logic.eq (B) a (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false)) -> logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false))) (\(px : logic.eq (B) (bool.match::bool::type (B) (op (f n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false)) -> (px))) ((((((((connectives.equal::leibniz) (B)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) ((((bool.axiom::match::bool::type::false) (B)) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))) (\(a : B) -> (logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) a) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false))) (\(px : logic.eq (B) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) (bool.match::bool::type (B) (op (g n) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i))) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)) bool.false)) -> (px))) (((logic.refl) (B)) (bigop (B) n (\(i : nat.nat) -> p2 i) nil op (\(i : nat.nat) -> g i)))))) (p1 n)) (H1)))) ((bool.true::or::false) (p1 n)))) (p2 n)) (((samep) (n)) ((nat.le::n) (nat.S n))))) (bigop (B) n (\(i : nat.nat) -> p1 i) nil op (\(i : nat.nat) -> f i))) (((Hind) ((((((((sameF::upto::le) (bool.bool)) (p1)) (p2)) (n)) (nat.S n)) (((((logic.eq::coerc) (nat.le (nat.pred (nat.S n)) (nat.S n))) (nat.le n (nat.S n))) ((nat.le::pred::n) (nat.S n))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.S n)) (nat.le n (nat.S n)))) (((logic.refl) (Set)) (nat.le n (nat.S n)))) (nat.pred (nat.S n))) ((nat.pred::Sn) (n))))) (samep))) (((((((((sameF::p::le) (B)) (p1)) (f)) (g)) (n)) (nat.S n)) (((((logic.eq::coerc) (nat.le (nat.pred (nat.S n)) (nat.S n))) (nat.le n (nat.S n))) ((nat.le::pred::n) (nat.S n))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.S n)) (nat.le n (nat.S n)))) (((logic.refl) (Set)) (nat.le n (nat.S n)))) (nat.pred (nat.S n))) ((nat.pred::Sn) (n))))) (samef)))))))))))) (k)

bigop::false : (B : Set) -> forall (n : nat.nat) -> forall (nil : B) -> forall (op : (B -> B -> B)) -> forall (f : (nat.nat -> B)) -> logic.eq (B) (bigop (B) n (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)) nil
bigop::false = \(B : Set) -> \(n : nat.nat) -> \(nil : B) -> \(op : B -> B -> B) -> \(f : nat.nat -> B) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> logic.eq (B) (bigop (B) ::x::365 (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)) nil)) ((((eq::bigop::body::O) (B)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> logic.eq (B) (bigop (B) nat.O (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)))) ((((eq::bigop::O) (B)) (\(y : ((nat.nat -> bool.bool) -> B -> (B -> B -> B) -> (nat.nat -> B) -> B)) -> logic.eq (B) (bigop (B) nat.O (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)) (y (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)))) (((logic.refl) (B)) (bigop (B) nat.O (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)))))) (\(n1 : nat.nat) -> \(Hind : logic.eq (B) (bigop (B) n1 (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i)) nil) -> (((((((logic.eq::ind::r) (B)) (bigop (B) n1 (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i))) (\(x : B) -> logic.eq (B) x nil)) (((((((logic.rewrite::r) (B)) (nil)) (\(:::: : B) -> logic.eq (B) :::: nil)) (((logic.refl) (B)) (nil))) (bigop (B) n1 (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i))) (Hind))) (bigop (B) (nat.S n1) (\(i : nat.nat) -> bool.false) nil op (\(i : nat.nat) -> f i))) ((((((((bigop::Sfalse) (B)) (n1)) (\(:::: : nat.nat) -> bool.false)) (nil)) (op)) (f)) (((logic.refl) (bool.bool)) (bool.false)))))) (n)

postulate Aop : (A : Set) -> A -> Set
postulate mk::Aop : (A : Set) -> forall (nil : A) -> forall (op : (A -> A -> A)) -> (forall (a : A) -> logic.eq (A) (op nil a) a) -> (forall (a : A) -> logic.eq (A) (op a nil) a) -> (forall (a : A) -> forall (b : A) -> forall (c : A) -> logic.eq (A) (op a (op b c)) (op (op a b) c)) -> Aop (A) nil
assoc : forall (a : nat.nat) -> forall (b : nat.nat) -> forall (c : nat.nat) -> logic.eq (nat.nat) (nat.times a (nat.times b c)) (nat.times (nat.times a b) c)
assoc = \(a : nat.nat) -> \(b : nat.nat) -> \(c : nat.nat) -> ((((logic.sym::eq) (nat.nat)) (nat.times (nat.times a b) c)) (nat.times a (nat.times b c))) ((((nat.associative::times) (a)) (b)) (c))

timesA : Aop (nat.nat) (nat.S nat.O)
timesA = ((((((mk::Aop) (nat.nat)) (nat.S nat.O)) (nat.times)) (\(a : nat.nat) -> (((nat.sym::eq::times) (nat.S nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y a) a)) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.times::body)) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y a) a)) ((((nat.sym::eq::times::body::S) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y a) a)) ((((nat.sym::eq::times) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.plus a (y a)) a)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.times::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.plus a (y a)) a)) (((nat.sym::eq::times::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.plus a (y a)) a)) (((((logic.sym::eq) (nat.nat)) (a)) (nat.plus a nat.O)) ((nat.plus::n::O) (a)))))))))) (\(n : nat.nat) -> ((((logic.sym::eq) (nat.nat)) (n)) (nat.times n (nat.S nat.O))) ((nat.times::n::1) (n)))) (\(a : nat.nat) -> \(b : nat.nat) -> \(c : nat.nat) -> ((((logic.sym::eq) (nat.nat)) (nat.times (nat.times a b) c)) (nat.times a (nat.times b c))) ((((nat.associative::times) (a)) (b)) (c)))

bigop::I::gen : forall (a : nat.nat) -> forall (b : nat.nat) -> forall (p : (nat.nat -> bool.bool)) -> forall (f : (nat.nat -> nat.nat)) -> (nat.le a b) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus b a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) b (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))
bigop::I::gen = \(a : nat.nat) -> \(b : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (p : (nat.nat -> bool.bool)) -> forall (f : (nat.nat -> nat.nat)) -> (nat.le a ::x::365) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus ::x::365 a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) ::x::365 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (\(p : nat.nat -> bool.bool) -> \(f : nat.nat -> nat.nat) -> (((sym::eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (y (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) ((((sym::eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (y (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) ((((eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (y (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))) ((((eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (y (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))) (((nat.eq::minus::body::O) (\(y : (nat.nat -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) (y a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))) (((((nat.eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.minus::body)) (\(y : (nat.nat -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) (y a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))) ((((nat.eq::minus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> (nat.le a nat.O) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) (y a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))) (\(auto : nat.le a nat.O) -> (((logic.refl) (nat.nat)) (bigop (nat.nat) (nat.minus nat.O a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))))))))))) (\(b0 : nat.nat) -> \(Hind : forall (p : (nat.nat -> bool.bool)) -> forall (f : (nat.nat -> nat.nat)) -> (nat.le a b0) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus b0 a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) -> (\(p : nat.nat -> bool.bool) -> \(f : nat.nat -> nat.nat) -> \(lea : nat.le a (nat.S b0)) -> (((((((connectives.match::Or::prop) (nat.lt a (nat.S b0))) (logic.eq (nat.nat) a (nat.S b0))) (logic.eq (nat.nat) (bigop (nat.nat) (nat.minus (nat.S b0) a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) (nat.S b0) (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (\(Ha : nat.lt a (nat.S b0)) -> (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (p b0) bool.true)) (logic.eq (bool.bool) (p b0) bool.false)) (logic.eq (nat.nat) (bigop (nat.nat) (nat.minus (nat.S b0) a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) (nat.S b0) (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (\(Hcase : logic.eq (bool.bool) (p b0) bool.true) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f b0) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus (nat.S b0) a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) x)) (((((((logic.eq::ind::r) (nat.nat)) (nat.S (nat.minus b0 a))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) x (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (nat.times (f b0) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f (nat.plus (nat.minus b0 a) a)) (bigop (nat.nat) (nat.minus b0 a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))))) (\(x : nat.nat) -> logic.eq (nat.nat) x (nat.times (f b0) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))))) (((((((((((logic.eq::f2) (nat.nat)) (nat.nat)) (nat.nat)) (nat.times)) (f (nat.plus (nat.minus b0 a) a))) (f b0)) (bigop (nat.nat) (nat.minus b0 a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a)))) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (((((((logic.eq::f) (nat.nat)) (nat.nat)) (f)) (nat.plus (nat.minus b0 a) a)) (b0)) (((((((logic.eq::ind) (nat.nat)) (b0)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) x::1 b0)) (((logic.refl) (nat.nat)) (b0))) (nat.plus (nat.minus b0 a) a)) ((((nat.plus::minus::m::m) (b0)) (a)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha)))))) ((((Hind) (p)) (f)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha))))) (bigop (nat.nat) (nat.S (nat.minus b0 a)) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a)))) ((((((((bigop::Strue) (nat.nat)) (nat.minus b0 a)) (\(:::: : nat.nat) -> p (nat.plus :::: a))) (nat.S nat.O)) (nat.times)) (\(:::: : nat.nat) -> f (nat.plus :::: a))) (((((((logic.eq::ind) (nat.nat)) (b0)) (\(x::1 : nat.nat) -> logic.eq (bool.bool) (p x::1) bool.true)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p b0)) (Hcase))) (nat.plus (nat.minus b0 a) a)) ((((nat.plus::minus::m::m) (b0)) (a)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha))))))) (nat.minus (nat.S b0) a)) ((((((nat.match::nat::prop) (\(:::: : nat.nat) -> (nat.le :::: b0) -> logic.eq (nat.nat) (nat.minus (nat.S b0) ::::) (nat.S (nat.minus b0 ::::)))) (\(auto : nat.le nat.O b0) -> (((((((logic.rewrite::l) (nat.nat)) (nat.S b0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.S (nat.minus b0 nat.O)))) (((((((logic.rewrite::l) (nat.nat)) (b0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.S b0) (nat.S ::::))) (((logic.refl) (nat.nat)) (nat.S b0))) (nat.minus b0 nat.O)) ((nat.minus::n::O) (b0)))) (nat.minus (nat.S b0) nat.O)) ((nat.minus::n::O) (nat.S b0))))) ((((nat.sym::eq::minus) (nat.S b0)) (\(y : (nat.nat -> nat.nat)) -> forall (n : nat.nat) -> (nat.le (nat.S n) b0) -> logic.eq (nat.nat) (y (nat.S n)) (nat.S (nat.minus b0 (nat.S n))))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.minus::body)) (b0)) (\(y : (nat.nat -> nat.nat)) -> forall (n : nat.nat) -> (nat.le (nat.S n) b0) -> logic.eq (nat.nat) (y (nat.S n)) (nat.S (nat.minus b0 (nat.S n))))) (\(a1 : nat.nat) -> (((nat.sym::eq::minus::body::S) (b0)) (\(y : (nat.nat -> nat.nat)) -> (nat.le (nat.S a1) b0) -> logic.eq (nat.nat) (y (nat.S a1)) (nat.S (nat.minus b0 (nat.S a1))))) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.S b0)) (\(q : nat.nat) -> nat.minus b0 q)) (a1)) (\(y : nat.nat) -> (nat.le (nat.S a1) b0) -> logic.eq (nat.nat) y (nat.S (nat.minus b0 (nat.S a1))))) (\(lta1 : nat.le (nat.S a1) b0) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.pred (nat.minus b0 a1))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus b0 a1) (nat.S x))) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus b0 a1)) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus b0 a1) x)) (((logic.refl) (nat.nat)) (nat.minus b0 a1))) (nat.S (nat.pred (nat.minus b0 a1)))) (((nat.S::pred) (nat.minus b0 a1)) (((((nat.lt::plus::to::minus::r) (nat.O)) (a1)) (b0)) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y a1)) b0)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y a1)) b0)) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y a1)) b0)) (lta1)))))))) (nat.minus b0 (nat.S a1))) (((nat.eq::minus::S::pred) (b0)) (a1))))))))) (a)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha))))) (bigop (nat.nat) (nat.S b0) (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) ((((((((bigop::Strue) (nat.nat)) (b0)) (\(:::: : nat.nat) -> bool.andb (nat.leb a ::::) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb (nat.leb a b0) x) bool.true)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb x bool.true) bool.true)) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.true bool.false bool.true)) (bool.true)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (bool.true)) (bool.false))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) bool.true bool.false bool.true) y)) (((logic.refl) (bool.bool)) (bool.andb bool.true bool.true)))) (nat.leb a b0)) ((((nat.le::to::leb::true) (a)) (b0)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha))))) (p b0)) (Hcase)))))) (\(Hcase : logic.eq (bool.bool) (p b0) bool.false) -> (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus (nat.S b0) a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) x)) (((((((logic.eq::ind::r) (nat.nat)) (nat.S (nat.minus b0 a))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) x (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) (nat.minus b0 a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a)))) (\(x : nat.nat) -> logic.eq (nat.nat) x (bigop (nat.nat) b0 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) ((((Hind) (p)) (f)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha)))) (bigop (nat.nat) (nat.S (nat.minus b0 a)) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a)))) ((((((((bigop::Sfalse) (nat.nat)) (nat.minus b0 a)) (\(:::: : nat.nat) -> p (nat.plus :::: a))) (nat.S nat.O)) (nat.times)) (\(:::: : nat.nat) -> f (nat.plus :::: a))) (((((((logic.eq::ind) (nat.nat)) (b0)) (\(x::1 : nat.nat) -> logic.eq (bool.bool) (p x::1) bool.false)) (((((((logic.rewrite::r) (bool.bool)) (bool.false)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (((logic.refl) (bool.bool)) (bool.false))) (p b0)) (Hcase))) (nat.plus (nat.minus b0 a) a)) ((((nat.plus::minus::m::m) (b0)) (a)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha))))))) (nat.minus (nat.S b0) a)) ((((((nat.match::nat::prop) (\(:::: : nat.nat) -> (nat.le :::: b0) -> logic.eq (nat.nat) (nat.minus (nat.S b0) ::::) (nat.S (nat.minus b0 ::::)))) (\(auto : nat.le nat.O b0) -> (((((((logic.rewrite::l) (nat.nat)) (nat.S b0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.S (nat.minus b0 nat.O)))) (((((((logic.rewrite::l) (nat.nat)) (b0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.S b0) (nat.S ::::))) (((logic.refl) (nat.nat)) (nat.S b0))) (nat.minus b0 nat.O)) ((nat.minus::n::O) (b0)))) (nat.minus (nat.S b0) nat.O)) ((nat.minus::n::O) (nat.S b0))))) ((((nat.sym::eq::minus) (nat.S b0)) (\(y : (nat.nat -> nat.nat)) -> forall (n : nat.nat) -> (nat.le (nat.S n) b0) -> logic.eq (nat.nat) (y (nat.S n)) (nat.S (nat.minus b0 (nat.S n))))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.minus::body)) (b0)) (\(y : (nat.nat -> nat.nat)) -> forall (n : nat.nat) -> (nat.le (nat.S n) b0) -> logic.eq (nat.nat) (y (nat.S n)) (nat.S (nat.minus b0 (nat.S n))))) (\(a1 : nat.nat) -> (((nat.sym::eq::minus::body::S) (b0)) (\(y : (nat.nat -> nat.nat)) -> (nat.le (nat.S a1) b0) -> logic.eq (nat.nat) (y (nat.S a1)) (nat.S (nat.minus b0 (nat.S a1))))) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.S b0)) (\(q : nat.nat) -> nat.minus b0 q)) (a1)) (\(y : nat.nat) -> (nat.le (nat.S a1) b0) -> logic.eq (nat.nat) y (nat.S (nat.minus b0 (nat.S a1))))) (\(lta1 : nat.le (nat.S a1) b0) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.pred (nat.minus b0 a1))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus b0 a1) (nat.S x))) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus b0 a1)) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus b0 a1) x)) (((logic.refl) (nat.nat)) (nat.minus b0 a1))) (nat.S (nat.pred (nat.minus b0 a1)))) (((nat.S::pred) (nat.minus b0 a1)) (((((nat.lt::plus::to::minus::r) (nat.O)) (a1)) (b0)) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y a1)) b0)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y a1)) b0)) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> nat.le (nat.S (y a1)) b0)) (lta1)))))))) (nat.minus b0 (nat.S a1))) (((nat.eq::minus::S::pred) (b0)) (a1))))))))) (a)) ((((nat.le::S::S::to::le) (a)) (b0)) (Ha))))) (bigop (nat.nat) (nat.S b0) (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) ((((((((bigop::Sfalse) (nat.nat)) (b0)) (\(:::: : nat.nat) -> bool.andb (nat.leb a ::::) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb (nat.leb a b0) x) bool.false)) (((((bool.match::bool::prop) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb :::: bool.false) bool.false)) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.false bool.true)) (bool.false)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (bool.false)) (bool.false))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) bool.false bool.false bool.true) y)) (((logic.refl) (bool.bool)) (bool.andb bool.true bool.false)))) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.false bool.false)) (bool.false)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.false))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) bool.false bool.false bool.false) y)) (((logic.refl) (bool.bool)) (bool.andb bool.false bool.false)))) (nat.leb a b0))) (p b0)) (Hcase)))))) ((bool.true::or::false) (p b0))))) (\(Ha : logic.eq (nat.nat) a (nat.S b0)) -> (((((((logic.eq::ind) (nat.nat)) (a)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.minus x::1 a) (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) x::1 (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (((((((logic.eq::ind) (nat.nat)) (nat.O)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) x::1 (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) a (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) ((((sym::eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (y (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) a (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) ((((sym::eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (y (\(i : nat.nat) -> p (nat.plus i a)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f (nat.plus i a))) (bigop (nat.nat) a (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (((((((logic.eq::ind) (nat.nat)) (bigop (nat.nat) a (\(i : nat.nat) -> bool.false) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) x::1 (bigop (nat.nat) a (\(i : nat.nat) -> bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))) (((((((((((same::bigop) (nat.nat)) (a)) (\(:::: : nat.nat) -> bool.false)) (\(:::: : nat.nat) -> bool.andb (nat.leb a ::::) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (f)) (\(i : nat.nat) -> \(ltia : nat.lt i a) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (bool.bool) bool.false (bool.andb x (p i)))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p i) bool.false bool.false)) (bool.false)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (p i)) (bool.false))) (\(a0 : bool.bool) -> (logic.eq (bool.bool) bool.false a0) -> logic.eq (bool.bool) bool.false (bool.match::bool::type (bool.bool) (p i) bool.false bool.false))) (\(px : logic.eq (bool.bool) bool.false (bool.match::bool::type (bool.bool) (p i) bool.false bool.false)) -> (px))) (((logic.refl) (bool.bool)) (bool.false)))) (nat.leb a i)) ((((nat.not::le::to::leb::false) (a)) (i)) ((((nat.lt::to::not::le) (i)) (a)) (ltia)))))) (\(i : nat.nat) -> \(auto : nat.lt i a) -> (\(auto' : logic.eq (bool.bool) bool.false bool.true) -> (((logic.refl) (nat.nat)) (f i)))))) (nat.S nat.O)) ((((((bigop::false) (nat.nat)) (a)) (nat.S nat.O)) (nat.times)) (f)))))) (nat.minus a a)) ((nat.minus::n::n) (a)))) (nat.S b0)) (Ha)))) ((((nat.le::to::or::lt::eq) (a)) (nat.S b0)) (lea)))))) (b)

postulate ACop : (A : Set) -> A -> Set
postulate mk::ACop : (A : Set) -> forall (nil : A) -> forall (op : (A -> A -> A)) -> (forall (a : A) -> logic.eq (A) (op nil a) a) -> (forall (a : A) -> logic.eq (A) (op a nil) a) -> (forall (a : A) -> forall (b : A) -> forall (c : A) -> logic.eq (A) (op a (op b c)) (op (op a b) c)) -> (forall (a : A) -> forall (b : A) -> logic.eq (A) (op a b) (op b a)) -> ACop (A) nil
timesAC : ACop (nat.nat) (nat.S nat.O)
timesAC = (((((((mk::ACop) (nat.nat)) (nat.S nat.O)) (nat.times)) (\(a : nat.nat) -> (((nat.sym::eq::times) (nat.S nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y a) a)) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.times::body)) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y a) a)) ((((nat.sym::eq::times::body::S) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (y a) a)) ((((nat.sym::eq::times) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.plus a (y a)) a)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.times::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.plus a (y a)) a)) (((nat.sym::eq::times::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.plus a (y a)) a)) (((((logic.sym::eq) (nat.nat)) (a)) (nat.plus a nat.O)) ((nat.plus::n::O) (a)))))))))) (\(n : nat.nat) -> ((((logic.sym::eq) (nat.nat)) (n)) (nat.times n (nat.S nat.O))) ((nat.times::n::1) (n)))) (\(a : nat.nat) -> \(b : nat.nat) -> \(c : nat.nat) -> ((((logic.sym::eq) (nat.nat)) (nat.times (nat.times a b) c)) (nat.times a (nat.times b c))) ((((nat.associative::times) (a)) (b)) (c)))) (nat.commutative::times)

bigop::diff : forall (p : (nat.nat -> bool.bool)) -> forall (f : (nat.nat -> nat.nat)) -> forall (i : nat.nat) -> forall (n : nat.nat) -> (nat.lt i n) -> (logic.eq (bool.bool) (p i) bool.true) -> logic.eq (nat.nat) (bigop (nat.nat) n (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) n (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)))
bigop::diff = \(p : nat.nat -> bool.bool) -> \(f : nat.nat -> nat.nat) -> \(i : nat.nat) -> \(n : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> (nat.lt i ::x::365) -> (logic.eq (bool.bool) (p i) bool.true) -> logic.eq (nat.nat) (bigop (nat.nat) ::x::365 (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) ::x::365 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))))) (\(ltO : nat.lt i nat.O) -> (((connectives.falsity) ((logic.eq (bool.bool) (p i) bool.true) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) nat.O (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))))) ((((logic.absurd) (nat.le (nat.S i) nat.O)) (ltO)) ((nat.not::le::Sn::O) (i)))))) (\(n0 : nat.nat) -> \(Hind : (nat.lt i n0) -> (logic.eq (bool.bool) (p i) bool.true) -> logic.eq (nat.nat) (bigop (nat.nat) n0 (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) n0 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)))) -> (\(lein : nat.lt i (nat.S n0)) -> (\(pi : logic.eq (bool.bool) (p i) bool.true) -> (((((((connectives.match::Or::prop) (nat.lt i n0)) (logic.eq (nat.nat) i n0)) (logic.eq (nat.nat) (bigop (nat.nat) (nat.S n0) (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) (nat.S n0) (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))))) (\(Hi : nat.lt i n0) -> (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (p n0) bool.true)) (logic.eq (bool.bool) (p n0) bool.false)) (logic.eq (nat.nat) (bigop (nat.nat) (nat.S n0) (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) (nat.S n0) (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))))) (\(pn : logic.eq (bool.bool) (p n0) bool.true) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x : nat.nat) -> logic.eq (nat.nat) x (nat.times (f i) (bigop (nat.nat) (nat.S n0) (\(x0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i x0)) (p x0)) (nat.S nat.O) nat.times (\(x0 : nat.nat) -> f x0))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (nat.times (f i) x))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (nat.times (f i) (f n0)) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) x)) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f n0) (f i))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (nat.times x (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (((((((logic.eq::ind) (nat.nat)) (nat.times (f n0) (nat.times (f i) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) x::1)) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f i) (bigop (nat.nat) n0 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (f n0) x) (nat.times (f n0) (nat.times (f i) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))))) (((logic.refl) (nat.nat)) (nat.times (f n0) (nat.times (f i) (bigop (nat.nat) n0 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)))))) (bigop (nat.nat) n0 (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))) (((Hind) (Hi)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p i)) (pi))))) (nat.times (nat.times (f n0) (f i)) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) ((((assoc) (f n0)) (f i)) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (nat.times (f i) (f n0))) (((nat.commutative::times) (f i)) (f n0)))) (nat.times (f i) (nat.times (f n0) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) ((((assoc) (f i)) (f n0)) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.match::bool::type (bool.bool) (p i0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true (nat.eqb i i0))) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (bigop (nat.nat) (nat.S n0) (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigop::Strue) (nat.nat)) (n0)) (\(:::: : nat.nat) -> bool.andb (bool.notb (nat.eqb i ::::)) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb i n0)) ::::) bool.true)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (bool.andb (bool.notb (nat.eqb i n0)) bool.true)) (((((((logic.rewrite::l) (bool.bool)) (p n0)) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb i n0)) bool.true) ::::)) (((((((logic.rewrite::l) (bool.bool)) (p n0)) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb i n0)) ::::) (p n0))) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb x) (p n0)) (p n0))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(a : bool.bool) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false a) (p n0)) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (p n0))) (\(px : logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (p n0)) -> (px))) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p n0) bool.false bool.true)) (p n0)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (p n0)) (bool.false))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false bool.true) y)) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false bool.true) (bool.match::bool::type (bool.bool) (p n0) bool.false y))) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false y) (bool.match::bool::type (bool.bool) (p n0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)))) (((logic.refl) (bool.bool)) (bool.andb (bool.notb bool.false) (p n0)))))))) (nat.eqb i n0)) ((((nat.not::eq::to::eqb::false) (i)) (n0)) ((((nat.lt::to::not::eq) (i)) (n0)) (Hi))))) (bool.true)) (pn))) (bool.true)) (pn)))) (p n0)) (pn))))) (bigop (nat.nat) (nat.S n0) (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigop::Strue) (nat.nat)) (n0)) (p)) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p n0)) (pn)))))) (\(pn : logic.eq (bool.bool) (p n0) bool.false) -> (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (\(x : nat.nat) -> logic.eq (nat.nat) x (nat.times (f i) (bigop (nat.nat) (nat.S n0) (\(x0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i x0)) (p x0)) (nat.S nat.O) nat.times (\(x0 : nat.nat) -> f x0))))) (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)) (nat.times (f i) x))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f i) (bigop (nat.nat) n0 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)))) (\(x : nat.nat) -> logic.eq (nat.nat) x (nat.times (f i) (bigop (nat.nat) n0 (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (((logic.refl) (nat.nat)) (nat.times (f i) (bigop (nat.nat) n0 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))))) (bigop (nat.nat) n0 (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))) (((Hind) (Hi)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p i)) (pi))))) (bigop (nat.nat) (nat.S n0) (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigop::Sfalse) (nat.nat)) (n0)) (\(:::: : nat.nat) -> bool.andb (bool.notb (nat.eqb i ::::)) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.rewrite::r) (bool.bool)) (bool.false)) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb i n0)) ::::) bool.false)) (((((((logic.rewrite::r) (bool.bool)) (bool.false)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (((logic.refl) (bool.bool)) (bool.false))) (bool.andb (bool.notb (nat.eqb i n0)) bool.false)) (((((((logic.rewrite::l) (bool.bool)) (p n0)) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb i n0)) bool.false) ::::)) (((((((logic.rewrite::l) (bool.bool)) (p n0)) (\(:::: : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb i n0)) ::::) (p n0))) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb x) (p n0)) (p n0))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(a : bool.bool) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false a) (p n0)) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (p n0))) (\(px : logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (p n0)) -> (px))) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p n0) bool.false bool.true)) (p n0)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (p n0)) (bool.false))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false bool.true) y)) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false bool.true) (bool.match::bool::type (bool.bool) (p n0) bool.false y))) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p n0) bool.false y) (bool.match::bool::type (bool.bool) (p n0) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)))) (((logic.refl) (bool.bool)) (bool.andb (bool.notb bool.false) (p n0)))))))) (nat.eqb i n0)) ((((nat.not::eq::to::eqb::false) (i)) (n0)) ((((nat.lt::to::not::eq) (i)) (n0)) (Hi))))) (bool.false)) (pn))) (bool.false)) (pn)))) (p n0)) (pn))))) (bigop (nat.nat) (nat.S n0) (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigop::Sfalse) (nat.nat)) (n0)) (p)) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.rewrite::r) (bool.bool)) (bool.false)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (((logic.refl) (bool.bool)) (bool.false))) (p n0)) (pn)))))) ((bool.true::or::false) (p n0))))) (\(Hi : logic.eq (nat.nat) i n0) -> (((((((logic.eq::ind) (nat.nat)) (i)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) (nat.S x::1) (\(x : nat.nat) -> p x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x)) (nat.times (f i) (bigop (nat.nat) (nat.S x::1) (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f i) (bigop (nat.nat) i (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x : nat.nat) -> logic.eq (nat.nat) x (nat.times (f i) (bigop (nat.nat) (nat.S i) (\(x0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i x0)) (p x0)) (nat.S nat.O) nat.times (\(x0 : nat.nat) -> f x0))))) (((((((logic.eq::f) (nat.nat)) (nat.nat)) (nat.times (f i))) (bigop (nat.nat) i (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (bigop (nat.nat) (nat.S i) (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f x))) (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) i (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) i (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)) x)) (((((((((((same::bigop) (nat.nat)) (i)) (p)) (\(:::: : nat.nat) -> bool.andb (bool.notb (nat.eqb i ::::)) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (f)) (\(k : nat.nat) -> \(ltki : nat.lt k i) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (bool.bool) (p k) (bool.andb (bool.notb x) (p k)))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(a : bool.bool) -> (logic.eq (bool.bool) (p k) (bool.match::bool::type (bool.bool) (p k) bool.false a)) -> logic.eq (bool.bool) (p k) (bool.match::bool::type (bool.bool) (p k) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)))) (\(px : logic.eq (bool.bool) (p k) (bool.match::bool::type (bool.bool) (p k) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false))) -> (px))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p k) bool.false bool.true)) (p k)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (p k)) (bool.false))) (\(a : bool.bool) -> (logic.eq (bool.bool) (p k) a) -> logic.eq (bool.bool) (p k) (bool.match::bool::type (bool.bool) (p k) bool.false bool.true))) (\(px : logic.eq (bool.bool) (p k) (bool.match::bool::type (bool.bool) (p k) bool.false bool.true)) -> (px))) (((logic.refl) (bool.bool)) (p k))))) (nat.eqb i k)) ((((nat.not::eq::to::eqb::false) (i)) (k)) (((((logic.not::to::not) (logic.eq (nat.nat) i k)) (nat.le (nat.S i) i)) (\(auto : logic.eq (nat.nat) i k) -> (((((logic.eq::coerc) (nat.le (nat.S k) i)) (nat.le (nat.S i) i)) (ltki)) (((((((logic.rewrite::l) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.S ::::) i) (nat.le (nat.S i) i))) (((logic.refl) (Set)) (nat.le (nat.S i) i))) (k)) (auto))))) ((nat.not::le::Sn::n) (i))))))) (\(i0 : nat.nat) -> \(auto : nat.lt i0 i) -> (\(auto' : logic.eq (bool.bool) (p i0) bool.true) -> (((logic.refl) (nat.nat)) (f i0)))))) (bigop (nat.nat) (nat.S i) (\(i0 : nat.nat) -> bool.andb (bool.notb (nat.eqb i i0)) (p i0)) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigop::Sfalse) (nat.nat)) (i)) (\(:::: : nat.nat) -> bool.andb (bool.notb (nat.eqb i ::::)) (p ::::))) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb x) (p i)) bool.false)) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p i) bool.false bool.false)) (bool.false)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (p i)) (bool.false))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p i) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.true)) y)) (((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.true)) (bool.false)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (bool.false)) (bool.true))) (\(y : bool.bool) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p i) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.true)) (bool.match::bool::type (bool.bool) (p i) bool.false y))) (((logic.refl) (bool.bool)) (bool.andb (bool.notb bool.true) (p i)))))) (nat.eqb i i)) ((((nat.eq::to::eqb::true) (i)) (i)) (((logic.refl) (nat.nat)) (i)))))))) (bigop (nat.nat) (nat.S i) (\(i0 : nat.nat) -> p i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigop::Strue) (nat.nat)) (i)) (p)) (nat.S nat.O)) (nat.times)) (f)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p i)) (pi))))) (n0)) (Hi)))) ((((nat.le::to::or::lt::eq) (i)) (n0)) ((((nat.le::S::S::to::le) (i)) (n0)) (lein)))))))) (n)

sub::hk : (nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat -> nat.nat -> (nat.nat -> bool.bool) -> (nat.nat -> bool.bool) -> (nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> Set
sub::hk = \(h : (nat.nat -> nat.nat)) -> \(k : (nat.nat -> nat.nat)) -> \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(p1 : (nat.nat -> bool.bool)) -> \(p2 : (nat.nat -> bool.bool)) -> \(f1 : (nat.nat -> nat.nat)) -> \(f2 : (nat.nat -> nat.nat)) -> forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> connectives.And (connectives.And (nat.lt (h i) n2) (logic.eq (bool.bool) (p2 (h i)) bool.true)) (logic.eq (nat.nat) (k (h i)) i)

iso : nat.nat -> nat.nat -> (nat.nat -> bool.bool) -> (nat.nat -> bool.bool) -> (nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> Set
iso = \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(p1 : (nat.nat -> bool.bool)) -> \(p2 : (nat.nat -> bool.bool)) -> \(f1 : (nat.nat -> nat.nat)) -> \(f2 : (nat.nat -> nat.nat)) -> connectives.ex (nat.nat -> nat.nat) (\(h : (nat.nat -> nat.nat)) -> connectives.ex (nat.nat -> nat.nat) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1)))

sub::hkO : forall (h : (nat.nat -> nat.nat)) -> forall (k : (nat.nat -> nat.nat)) -> forall (n1 : nat.nat) -> forall (n2 : nat.nat) -> forall (p1 : (nat.nat -> bool.bool)) -> forall (p2 : (nat.nat -> bool.bool)) -> forall (f1 : (nat.nat -> nat.nat)) -> forall (f2 : (nat.nat -> nat.nat)) -> (logic.eq (nat.nat) n1 nat.O) -> sub::hk h k n1 n2 p1 p2 f1 f2
sub::hkO = \(h : nat.nat -> nat.nat) -> \(k : nat.nat -> nat.nat) -> \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(p1 : nat.nat -> bool.bool) -> \(p2 : nat.nat -> bool.bool) -> \(f1 : nat.nat -> nat.nat) -> \(f2 : nat.nat -> nat.nat) -> \(up0 : logic.eq (nat.nat) n1 nat.O) -> (\(i : nat.nat) -> \(lti : nat.lt i n1) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.O)) (\(x : nat.nat) -> (logic.eq (bool.bool) (p1 i) bool.true) -> connectives.And (connectives.And (nat.lt (h i) n2) (logic.eq (bool.bool) (p2 (h i)) bool.true)) (logic.eq (nat.nat) (k (h i)) i))) (((connectives.falsity) ((logic.eq (bool.bool) (p1 i) bool.true) -> connectives.And (connectives.And (nat.lt (h i) n2) (logic.eq (bool.bool) (p2 (h i)) bool.true)) (logic.eq (nat.nat) (k (h i)) i))) ((((logic.absurd) (nat.le (nat.S i) nat.O)) (((((logic.eq::coerc) (nat.le (nat.S i) n1)) (nat.le (nat.S i) nat.O)) (lti)) (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.S i) ::::) (nat.le (nat.S i) nat.O))) (((logic.refl) (Set)) (nat.le (nat.S i) nat.O))) (n1)) (up0)))) ((nat.not::le::Sn::O) (i))))) (n1)) (up0)))

sub0::to::false : forall (h : (nat.nat -> nat.nat)) -> forall (k : (nat.nat -> nat.nat)) -> forall (n1 : nat.nat) -> forall (n2 : nat.nat) -> forall (p1 : (nat.nat -> bool.bool)) -> forall (p2 : (nat.nat -> bool.bool)) -> forall (f1 : (nat.nat -> nat.nat)) -> forall (f2 : (nat.nat -> nat.nat)) -> (logic.eq (nat.nat) n1 nat.O) -> (sub::hk h k n2 n1 p2 p1 f2 f1) -> forall (i : nat.nat) -> (nat.lt i n2) -> logic.eq (bool.bool) (p2 i) bool.false
sub0::to::false = \(h : nat.nat -> nat.nat) -> \(k : nat.nat -> nat.nat) -> \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(p1 : nat.nat -> bool.bool) -> \(p2 : nat.nat -> bool.bool) -> \(f1 : nat.nat -> nat.nat) -> \(f2 : nat.nat -> nat.nat) -> \(up0 : logic.eq (nat.nat) n1 nat.O) -> (\(sub : sub::hk h k n2 n1 p2 p1 f2 f1) -> (\(i : nat.nat) -> \(lti : nat.lt i n2) -> (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (p2 i) bool.true)) (logic.eq (bool.bool) (p2 i) bool.false)) (logic.eq (bool.bool) (p2 i) bool.false)) (\(ptrue : logic.eq (bool.bool) (p2 i) bool.true) -> ((((((connectives.match::And::prop) (connectives.And (nat.lt (h i) n1) (logic.eq (bool.bool) (p1 (h i)) bool.true))) (logic.eq (nat.nat) (k (h i)) i)) (logic.eq (bool.bool) (p2 i) bool.false)) (\(::clearme : connectives.And (nat.lt (h i) n1) (logic.eq (bool.bool) (p1 (h i)) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (h i) n1)) (logic.eq (bool.bool) (p1 (h i)) bool.true)) ((logic.eq (nat.nat) (k (h i)) i) -> logic.eq (bool.bool) (p2 i) bool.false)) (\(hi : nat.lt (h i) n1) -> (((connectives.falsity) ((logic.eq (bool.bool) (p1 (h i)) bool.true) -> (logic.eq (nat.nat) (k (h i)) i) -> logic.eq (bool.bool) (p2 i) bool.false)) ((((logic.absurd) (nat.le (nat.S (h i)) nat.O)) (((((logic.eq::coerc) (nat.le (nat.S (h i)) n1)) (nat.le (nat.S (h i)) nat.O)) (hi)) (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.S (h i)) ::::) (nat.le (nat.S (h i)) nat.O))) (((logic.refl) (Set)) (nat.le (nat.S (h i)) nat.O))) (n1)) (up0)))) ((nat.not::le::Sn::O) (h i)))))) (::clearme)))) ((((sub) (i)) (lti)) (ptrue))))) (\(auto : logic.eq (bool.bool) (p2 i) bool.false) -> (((((((logic.rewrite::r) (bool.bool)) (bool.false)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (((logic.refl) (bool.bool)) (bool.false))) (p2 i)) (auto)))) ((bool.true::or::false) (p2 i)))))

sub::lt : forall (e : (nat.nat -> nat.nat)) -> forall (p : (nat.nat -> bool.bool)) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n m) -> sub::hk (\(x : nat.nat) -> x) (\(x : nat.nat) -> x) n m p p e e
sub::lt = \(e : nat.nat -> nat.nat) -> \(f : nat.nat -> bool.bool) -> \(n : nat.nat) -> \(m : nat.nat) -> \(lenm : nat.le n m) -> (\(i : nat.nat) -> \(lti : nat.lt i n) -> (\(fi : logic.eq (bool.bool) (f i) bool.true) -> (((((connectives.conj) (connectives.And (nat.lt i m) (logic.eq (bool.bool) (f i) bool.true))) (logic.eq (nat.nat) i i)) (((((connectives.conj) (nat.lt i m)) (logic.eq (bool.bool) (f i) bool.true)) ((((((nat.lt::to::le::to::lt) (i)) (n)) (m)) (lti)) (lenm))) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (f i)) (fi)))) (((logic.refl) (nat.nat)) (i)))))

transitive::sub : forall (h1 : (nat.nat -> nat.nat)) -> forall (k1 : (nat.nat -> nat.nat)) -> forall (h2 : (nat.nat -> nat.nat)) -> forall (k2 : (nat.nat -> nat.nat)) -> forall (n1 : nat.nat) -> forall (n2 : nat.nat) -> forall (n3 : nat.nat) -> forall (p1 : (nat.nat -> bool.bool)) -> forall (p2 : (nat.nat -> bool.bool)) -> forall (p3 : (nat.nat -> bool.bool)) -> forall (f1 : (nat.nat -> nat.nat)) -> forall (f2 : (nat.nat -> nat.nat)) -> forall (f3 : (nat.nat -> nat.nat)) -> (sub::hk h1 k1 n1 n2 p1 p2 f1 f2) -> (sub::hk h2 k2 n2 n3 p2 p3 f2 f3) -> sub::hk (\(x : nat.nat) -> h2 (h1 x)) (\(x : nat.nat) -> k1 (k2 x)) n1 n3 p1 p3 f1 f3
transitive::sub = \(h1 : nat.nat -> nat.nat) -> \(k1 : nat.nat -> nat.nat) -> \(h2 : nat.nat -> nat.nat) -> \(k2 : nat.nat -> nat.nat) -> \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(n3 : nat.nat) -> \(p1 : nat.nat -> bool.bool) -> \(p2 : nat.nat -> bool.bool) -> \(p3 : nat.nat -> bool.bool) -> \(f1 : nat.nat -> nat.nat) -> \(f2 : nat.nat -> nat.nat) -> \(f3 : nat.nat -> nat.nat) -> \(sub1 : sub::hk h1 k1 n1 n2 p1 p2 f1 f2) -> (\(sub2 : sub::hk h2 k2 n2 n3 p2 p3 f2 f3) -> (\(i : nat.nat) -> \(lti : nat.lt i n1) -> (\(fi : logic.eq (bool.bool) (p1 i) bool.true) -> ((((((connectives.match::And::prop) (connectives.And (nat.lt (h1 i) n2) (logic.eq (bool.bool) (p2 (h1 i)) bool.true))) (logic.eq (nat.nat) (k1 (h1 i)) i)) (connectives.And (connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) (logic.eq (nat.nat) (k1 (k2 (h2 (h1 i)))) i))) (\(::clearme : connectives.And (nat.lt (h1 i) n2) (logic.eq (bool.bool) (p2 (h1 i)) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (h1 i) n2)) (logic.eq (bool.bool) (p2 (h1 i)) bool.true)) ((logic.eq (nat.nat) (k1 (h1 i)) i) -> connectives.And (connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) (logic.eq (nat.nat) (k1 (k2 (h2 (h1 i)))) i))) (\(lth1i : nat.lt (h1 i) n2) -> (\(fh1i : logic.eq (bool.bool) (p2 (h1 i)) bool.true) -> (\(ei : logic.eq (nat.nat) (k1 (h1 i)) i) -> ((((((connectives.match::And::prop) (connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true))) (logic.eq (nat.nat) (k2 (h2 (h1 i))) (h1 i))) (connectives.And (connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) (logic.eq (nat.nat) (k1 (k2 (h2 (h1 i)))) i))) (\(::clearme0 : connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (h2 (h1 i)) n3)) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) ((logic.eq (nat.nat) (k2 (h2 (h1 i))) (h1 i)) -> connectives.And (connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) (logic.eq (nat.nat) (k1 (k2 (h2 (h1 i)))) i))) (\(H1 : nat.lt (h2 (h1 i)) n3) -> (\(H2 : logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true) -> (\(H3 : logic.eq (nat.nat) (k2 (h2 (h1 i))) (h1 i)) -> (((((connectives.conj) (connectives.And (nat.lt (h2 (h1 i)) n3) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true))) (logic.eq (nat.nat) (k1 (k2 (h2 (h1 i)))) i)) (((((connectives.conj) (nat.lt (h2 (h1 i)) n3)) (logic.eq (bool.bool) (p3 (h2 (h1 i))) bool.true)) (H1)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p3 (h2 (h1 i)))) (H2)))) (((((((logic.rewrite::r) (nat.nat)) (h1 i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (k1 ::::) i)) (((((((logic.rewrite::r) (nat.nat)) (i)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: i)) (((logic.refl) (nat.nat)) (i))) (k1 (h1 i))) (ei))) (k2 (h2 (h1 i)))) (H3))))))) (::clearme0)))) ((((sub2) (h1 i)) (lth1i)) (fh1i))))))) (::clearme)))) ((((sub1) (i)) (lti)) (fi))))))

let::clause::10471 : forall (n1 : nat.nat) -> forall (n2 : nat.nat) -> forall (p1 : (nat.nat -> bool.bool)) -> forall (p2 : (nat.nat -> bool.bool)) -> forall (f1 : (nat.nat -> nat.nat)) -> forall (f2 : (nat.nat -> nat.nat)) -> (iso n1 n2 p1 p2 f1 f2) -> forall (h : (nat.nat -> nat.nat)) -> (connectives.ex (nat.nat -> nat.nat) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1))) -> forall (k : (nat.nat -> nat.nat)) -> (connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1)) -> (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) -> (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) -> forall (i : nat.nat) -> forall (m : nat.nat) -> (forall (f : (nat.nat -> bool.bool)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O m p1 f f1 f2) -> (sub::hk k h m nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) m (\(i0 : nat.nat) -> f i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0))) -> forall (p20 : (nat.nat -> bool.bool)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O (nat.S m) p1 p20 f1 f2) -> (sub::hk k h (nat.S m) nat.O p20 p1 f2 f1) -> forall (x2571 : nat.nat) -> forall (x2572 : nat.nat) -> logic.eq (nat.nat) x2571 (nat.plus (nat.times x2572 (div::mod.div x2571 x2572)) (div::mod.mod x2571 x2572))
let::clause::10471 = \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(p1 : nat.nat -> bool.bool) -> \(p2 : nat.nat -> bool.bool) -> \(f1 : nat.nat -> nat.nat) -> \(f2 : nat.nat -> nat.nat) -> \(::clearme : iso n1 n2 p1 p2 f1 f2) -> (\(h : nat.nat -> nat.nat) -> \(::clearme0 : connectives.ex (nat.nat -> nat.nat) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1))) -> (\(k : nat.nat -> nat.nat) -> \(::clearme1 : connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1)) -> (\(::clearme2 : connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) -> (\(same : forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) -> (\(i : nat.nat) -> \(m : nat.nat) -> \(Hind : forall (f : (nat.nat -> bool.bool)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O m p1 f f1 f2) -> (sub::hk k h m nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) m (\(i0 : nat.nat) -> f i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0))) -> (\(p20 : nat.nat -> bool.bool) -> \(:::: : nat.le nat.O n1) -> (\(sub1 : sub::hk h k nat.O (nat.S m) p1 p20 f1 f2) -> (\(sub2 : sub::hk k h (nat.S m) nat.O p20 p1 f2 f1) -> (\(x2571 : nat.nat) -> \(x2572 : nat.nat) -> ((((((logic.rewrite::l) (nat.nat)) (nat.times (div::mod.div x2571 x2572) x2572)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) x2571 (nat.plus ::::1 (div::mod.mod x2571 x2572)))) (((div::mod.div::mod) (x2571)) (x2572))) (nat.times x2572 (div::mod.div x2571 x2572))) (((nat.commutative::times) (div::mod.div x2571 x2572)) (x2572)))))))))))

bigop::iso : forall (n1 : nat.nat) -> forall (n2 : nat.nat) -> forall (p1 : (nat.nat -> bool.bool)) -> forall (p2 : (nat.nat -> bool.bool)) -> forall (f1 : (nat.nat -> nat.nat)) -> forall (f2 : (nat.nat -> nat.nat)) -> (iso n1 n2 p1 p2 f1 f2) -> logic.eq (nat.nat) (bigop (nat.nat) n1 (\(i : nat.nat) -> p1 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f1 i)) (bigop (nat.nat) n2 (\(i : nat.nat) -> p2 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f2 i))
bigop::iso = \(n1 : nat.nat) -> \(n2 : nat.nat) -> \(p1 : nat.nat -> bool.bool) -> \(p2 : nat.nat -> bool.bool) -> \(f1 : nat.nat -> nat.nat) -> \(f2 : nat.nat -> nat.nat) -> \(::clearme : iso n1 n2 p1 p2 f1 f2) -> ((((((connectives.match::ex::prop) (nat.nat -> nat.nat)) (\(h : (nat.nat -> nat.nat)) -> connectives.ex (nat.nat -> nat.nat) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1)))) (logic.eq (nat.nat) (bigop (nat.nat) n1 (\(i : nat.nat) -> p1 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f1 i)) (bigop (nat.nat) n2 (\(i : nat.nat) -> p2 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f2 i)))) (\(h : nat.nat -> nat.nat) -> \(::clearme0 : connectives.ex (nat.nat -> nat.nat) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1))) -> ((((((connectives.match::ex::prop) (nat.nat -> nat.nat)) (\(k : (nat.nat -> nat.nat)) -> connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1))) (logic.eq (nat.nat) (bigop (nat.nat) n1 (\(i : nat.nat) -> p1 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f1 i)) (bigop (nat.nat) n2 (\(i : nat.nat) -> p2 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f2 i)))) (\(k : nat.nat -> nat.nat) -> \(::clearme1 : connectives.And (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) (sub::hk k h n2 n1 p2 p1 f2 f1)) -> ((((((connectives.match::And::prop) (connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2))) (sub::hk k h n2 n1 p2 p1 f2 f1)) (logic.eq (nat.nat) (bigop (nat.nat) n1 (\(i : nat.nat) -> p1 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f1 i)) (bigop (nat.nat) n2 (\(i : nat.nat) -> p2 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f2 i)))) (\(::clearme2 : connectives.And (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) (sub::hk h k n1 n2 p1 p2 f1 f2)) -> ((((((connectives.match::And::prop) (forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i)))) (sub::hk h k n1 n2 p1 p2 f1 f2)) ((sub::hk k h n2 n1 p2 p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) n1 (\(i : nat.nat) -> p1 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f1 i)) (bigop (nat.nat) n2 (\(i : nat.nat) -> p2 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f2 i)))) (\(same : forall (i : nat.nat) -> (nat.lt i n1) -> (logic.eq (bool.bool) (p1 i) bool.true) -> logic.eq (nat.nat) (f1 i) (f2 (h i))) -> ((((nat.le::gen) (\(:::: : nat.nat) -> (sub::hk h k :::: n2 p1 p2 f1 f2) -> (sub::hk k h n2 :::: p2 p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) :::: (\(i : nat.nat) -> p1 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f1 i)) (bigop (nat.nat) n2 (\(i : nat.nat) -> p2 i) (nat.S nat.O) nat.times (\(i : nat.nat) -> f2 i)))) (n1)) (\(i : nat.nat) -> (((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (f : (nat.nat -> bool.bool)) -> (nat.le ::x::365 n1) -> (sub::hk h k ::x::365 n2 p1 f f1 f2) -> (sub::hk k h n2 ::x::365 f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) ::x::365 (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) n2 (\(i0 : nat.nat) -> f i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) (((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (f : (nat.nat -> bool.bool)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O ::x::365 p1 f f1 f2) -> (sub::hk k h ::x::365 nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) ::x::365 (\(i0 : nat.nat) -> f i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) (\(f : nat.nat -> bool.bool) -> (((sym::eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O nat.O p1 f f1 f2) -> (sub::hk k h nat.O nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(iO : nat.nat) -> p1 iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f1 iO)) (y (\(iO : nat.nat) -> f iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f2 iO)))) ((((sym::eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O nat.O p1 f f1 f2) -> (sub::hk k h nat.O nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(iO : nat.nat) -> p1 iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f1 iO)) (y (\(iO : nat.nat) -> f iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f2 iO)))) ((((eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O nat.O p1 f f1 f2) -> (sub::hk k h nat.O nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(iO : nat.nat) -> p1 iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f1 iO)) (y (\(iO : nat.nat) -> p1 iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f1 iO)))) ((((eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O nat.O p1 f f1 f2) -> (sub::hk k h nat.O nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(iO : nat.nat) -> p1 iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f1 iO)) (y (\(iO : nat.nat) -> p1 iO) (nat.S nat.O) nat.times (\(iO : nat.nat) -> f1 iO)))) (\(auto : nat.le nat.O n1) -> (\(auto' : sub::hk h k nat.O nat.O p1 f f1 f2) -> (\(auto'' : sub::hk k h nat.O nat.O f p1 f2 f1) -> (((logic.refl) (nat.nat)) (bigop (nat.nat) nat.O (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))))))))))) (\(m : nat.nat) -> \(Hind : forall (f : (nat.nat -> bool.bool)) -> (nat.le nat.O n1) -> (sub::hk h k nat.O m p1 f f1 f2) -> (sub::hk k h m nat.O f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) m (\(i0 : nat.nat) -> f i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0))) -> (\(p20 : nat.nat -> bool.bool) -> \(:::: : nat.le nat.O n1) -> (\(sub1 : sub::hk h k nat.O (nat.S m) p1 p20 f1 f2) -> (\(sub2 : sub::hk k h (nat.S m) nat.O p20 p1 f2 f1) -> (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) m (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0))) (\(x : nat.nat) -> logic.eq (nat.nat) (bigop (nat.nat) nat.O (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) x)) (((((Hind) (p20)) ((nat.le::O::n) (n1))) ((((((((((sub::hkO) (h)) (k)) (nat.O)) (m)) (p1)) (p20)) (f1)) (f2)) (((logic.refl) (nat.nat)) (nat.O)))) ((((((((((((((((transitive::sub) (\(x : nat.nat) -> x)) (\(x : nat.nat) -> x)) (k)) (h)) (m)) (nat.S m)) (nat.O)) (p20)) (p20)) (p1)) (f2)) (f2)) (f1)) ((((((sub::lt) (f2)) (p20)) (m)) (nat.S m)) ((nat.le::n::Sn) (m)))) (sub2)))) (bigop (nat.nat) (nat.S m) (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0))) ((((((((bigop::Sfalse) (nat.nat)) (m)) (p20)) (nat.S nat.O)) (nat.times)) (f2)) (((((((((((((sub0::to::false) (k)) (h)) (nat.O)) (nat.S m)) (p1)) (p20)) (f1)) (f2)) (((logic.refl) (nat.nat)) (nat.O))) (sub2)) (m)) (((((logic.eq::coerc) (nat.lt (div::mod.mod m nat.O) (nat.plus (nat.plus (div::mod.mod m nat.O) (nat.times nat.O (div::mod.div m nat.O))) (nat.S nat.O)))) (nat.lt m (nat.S m))) ((((nat.lt::plus::Sn::r) (div::mod.mod m nat.O)) (nat.times nat.O (div::mod.div m nat.O))) (nat.O))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(::::1 : nat.nat) -> logic.eq (Set) (nat.lt (div::mod.mod m nat.O) (nat.plus ::::1 (nat.S nat.O))) (nat.lt m (nat.S m)))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(::::1 : nat.nat) -> logic.eq (Set) (nat.lt ::::1 (nat.plus m (nat.S nat.O))) (nat.lt m (nat.S m)))) (((((((logic.rewrite::l) (nat.nat)) (nat.S m)) (\(::::1 : nat.nat) -> logic.eq (Set) (nat.lt m ::::1) (nat.lt m (nat.S m)))) (((logic.refl) (Set)) (nat.lt m (nat.S m)))) (nat.plus m (nat.S nat.O))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus m nat.O)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) (nat.S ::::1) (nat.plus m (nat.S nat.O)))) (((nat.plus::n::Sm) (m)) (nat.O))) (m)) ((nat.plus::n::O) (m))))) (div::mod.mod m nat.O)) (((((((logic.rewrite::r) (nat.nat)) (nat.plus nat.O (div::mod.mod m nat.O))) (\(::::1 : nat.nat) -> logic.eq (nat.nat) m ::::1)) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (div::mod.mod m nat.O) nat.O)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) m ::::1)) (((((((logic.rewrite::r) (nat.nat)) (nat.times nat.O (div::mod.div m nat.O))) (\(::::1 : nat.nat) -> logic.eq (nat.nat) m (nat.plus (div::mod.mod m nat.O) ::::1))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times nat.O (div::mod.div m nat.O)) (div::mod.mod m nat.O))) (\(::::1 : nat.nat) -> logic.eq (nat.nat) m ::::1)) (((((((((((((((((((((((let::clause::10471) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) (::clearme)) (h)) (::clearme0)) (k)) (::clearme1)) (::clearme2)) (same)) (i)) (m)) (Hind)) (p20)) (::::)) (sub1)) (sub2)) (m)) (nat.O))) (nat.plus (div::mod.mod m nat.O) (nat.times nat.O (div::mod.div m nat.O)))) (((nat.commutative::plus) (nat.times nat.O (div::mod.div m nat.O))) (div::mod.mod m nat.O)))) (nat.O)) ((nat.times::O::n) (div::mod.div m nat.O)))) (nat.plus nat.O (div::mod.mod m nat.O))) (((nat.commutative::plus) (div::mod.mod m nat.O)) (nat.O)))) (div::mod.mod m nat.O)) ((nat.plus::O::n) (div::mod.mod m nat.O))))) (nat.plus (div::mod.mod m nat.O) (nat.times nat.O (div::mod.div m nat.O)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times nat.O (div::mod.div m nat.O)) (div::mod.mod m nat.O))) (\(::::1 : nat.nat) -> logic.eq (nat.nat) m ::::1)) (((((((((((((((((((((((let::clause::10471) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) (::clearme)) (h)) (::clearme0)) (k)) (::clearme1)) (::clearme2)) (same)) (i)) (m)) (Hind)) (p20)) (::::)) (sub1)) (sub2)) (m)) (nat.O))) (nat.plus (div::mod.mod m nat.O) (nat.times nat.O (div::mod.div m nat.O)))) (((nat.commutative::plus) (nat.times nat.O (div::mod.div m nat.O))) (div::mod.mod m nat.O))))))))))))) (n2))) (\(n : nat.nat) -> \(Hind : forall (f : (nat.nat -> bool.bool)) -> (nat.le n n1) -> (sub::hk h k n n2 p1 f f1 f2) -> (sub::hk k h n2 n f p1 f2 f1) -> logic.eq (nat.nat) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) n2 (\(i0 : nat.nat) -> f i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0))) -> (\(p20 : nat.nat -> bool.bool) -> \(ltn : nat.le (nat.S n) n1) -> (\(sub1 : sub::hk h k (nat.S n) n2 p1 p20 f1 f2) -> (\(sub2 : sub::hk k h n2 (nat.S n) p20 p1 f2 f1) -> (((((((connectives.match::Or::prop) (logic.eq (bool.bool) (p1 n) bool.true)) (logic.eq (bool.bool) (p1 n) bool.false)) (logic.eq (nat.nat) (bigop (nat.nat) (nat.S n) (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)) (bigop (nat.nat) n2 (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) (\(p1n : logic.eq (bool.bool) (p1 n) bool.true) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f1 n) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0)))) (\(x : nat.nat) -> logic.eq (nat.nat) x (bigop (nat.nat) n2 (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) ((((((connectives.match::And::prop) (connectives.And (nat.lt (h n) n2) (logic.eq (bool.bool) (p20 (h n)) bool.true))) (logic.eq (nat.nat) (k (h n)) n)) (logic.eq (nat.nat) (nat.times (f1 n) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) (bigop (nat.nat) n2 (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) (\(::clearme3 : connectives.And (nat.lt (h n) n2) (logic.eq (bool.bool) (p20 (h n)) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (h n) n2)) (logic.eq (bool.bool) (p20 (h n)) bool.true)) ((logic.eq (nat.nat) (k (h n)) n) -> logic.eq (nat.nat) (nat.times (f1 n) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) (bigop (nat.nat) n2 (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) (\(hn : nat.lt (h n) n2) -> (\(p2hn : logic.eq (bool.bool) (p20 (h n)) bool.true) -> (\(eqn : logic.eq (nat.nat) (k (h n)) n) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f2 (h n)) (bigop (nat.nat) n2 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb (h n) x)) (p20 x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f2 x)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (f1 n) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) x)) (((((((logic.eq::ind::r) (nat.nat)) (f2 (h n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times x (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) (nat.times (f2 (h n)) (bigop (nat.nat) n2 (\(x0 : nat.nat) -> bool.andb (bool.notb (nat.eqb (h n) x0)) (p20 x0)) (nat.S nat.O) nat.times (\(x0 : nat.nat) -> f2 x0))))) (((((((logic.eq::f) (nat.nat)) (nat.nat)) (nat.times (f2 (h n)))) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) (bigop (nat.nat) n2 (\(x : nat.nat) -> bool.andb (bool.notb (nat.eqb (h n) x)) (p20 x)) (nat.S nat.O) nat.times (\(x : nat.nat) -> f2 x))) (((((Hind) (\(:::: : nat.nat) -> bool.andb (bool.notb (nat.eqb (h n) ::::)) (p20 ::::))) ((((nat.lt::to::le) (n)) (n1)) (ltn))) (\(i0 : nat.nat) -> \(ltin : nat.lt i0 n) -> (\(p1i : logic.eq (bool.bool) (p1 i0) bool.true) -> ((((((connectives.match::And::prop) (connectives.And (nat.lt (h i0) n2) (logic.eq (bool.bool) (p20 (h i0)) bool.true))) (logic.eq (nat.nat) (k (h i0)) i0)) (connectives.And (connectives.And (nat.lt (h i0) n2) (logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb (h n) (h i0))) (p20 (h i0))) bool.true)) (logic.eq (nat.nat) (k (h i0)) i0))) (\(::clearme4 : connectives.And (nat.lt (h i0) n2) (logic.eq (bool.bool) (p20 (h i0)) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (h i0) n2)) (logic.eq (bool.bool) (p20 (h i0)) bool.true)) ((logic.eq (nat.nat) (k (h i0)) i0) -> connectives.And (connectives.And (nat.lt (h i0) n2) (logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb (h n) (h i0))) (p20 (h i0))) bool.true)) (logic.eq (nat.nat) (k (h i0)) i0))) (\(h1i : nat.lt (h i0) n2) -> (\(p2h1i : logic.eq (bool.bool) (p20 (h i0)) bool.true) -> (\(eqi : logic.eq (nat.nat) (k (h i0)) i0) -> (((((connectives.conj) (connectives.And (nat.lt (h i0) n2) (logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb (h n) (h i0))) (p20 (h i0))) bool.true))) (logic.eq (nat.nat) (k (h i0)) i0)) (((((connectives.conj) (nat.lt (h i0) n2)) (logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb (h n) (h i0))) (p20 (h i0))) bool.true)) (h1i)) (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (bool.bool) (bool.andb (bool.notb x) (p20 (h i0))) bool.true)) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(a : bool.bool) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 (h i0)) bool.false a) bool.true) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 (h i0)) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) bool.true)) (\(px : logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 (h i0)) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) bool.true) -> (px))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p20 (h i0)) bool.false bool.true)) (p20 (h i0))) ((((bool.axiom::match::bool::type::true) (bool.bool)) (p20 (h i0))) (bool.false))) (\(a : bool.bool) -> (logic.eq (bool.bool) a bool.true) -> logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 (h i0)) bool.false bool.true) bool.true)) (\(px : logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 (h i0)) bool.false bool.true) bool.true) -> (px))) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p20 (h i0))) (p2h1i))))) (nat.eqb (h n) (h i0))) ((((nat.not::eq::to::eqb::false) (h n)) (h i0)) (((((logic.not::to::not) (logic.eq (nat.nat) (h n) (h i0))) (logic.eq (nat.nat) i0 n)) (\(auto : logic.eq (nat.nat) (h n) (h i0)) -> (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: n)) (((logic.refl) (nat.nat)) (n))) (i0)) (((((((logic.rewrite::l) (nat.nat)) (k (h n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: n)) (eqn)) (i0)) (((((((logic.rewrite::r) (nat.nat)) (h i0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (k ::::) i0)) (eqi)) (h n)) (auto)))))) ((((nat.lt::to::not::eq) (i0)) (n)) (ltin))))))) (((((((logic.rewrite::r) (nat.nat)) (i0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: i0)) (((logic.refl) (nat.nat)) (i0))) (k (h i0))) (eqi))))))) (::clearme4)))) ((((sub1) (i0)) ((((nat.le::S) (nat.S i0)) (n)) (ltin))) (p1i)))))) (\(j : nat.nat) -> \(ltj : nat.lt j n2) -> (\(p2j : logic.eq (bool.bool) (bool.andb (bool.notb (nat.eqb (h n) j)) (p20 j)) bool.true) -> ((((((connectives.match::And::prop) (connectives.And (nat.lt (k j) (nat.S n)) (logic.eq (bool.bool) (p1 (k j)) bool.true))) (logic.eq (nat.nat) (h (k j)) j)) (connectives.And (connectives.And (nat.lt (k j) n) (logic.eq (bool.bool) (p1 (k j)) bool.true)) (logic.eq (nat.nat) (h (k j)) j))) (\(::clearme4 : connectives.And (nat.lt (k j) (nat.S n)) (logic.eq (bool.bool) (p1 (k j)) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (k j) (nat.S n))) (logic.eq (bool.bool) (p1 (k j)) bool.true)) ((logic.eq (nat.nat) (h (k j)) j) -> connectives.And (connectives.And (nat.lt (k j) n) (logic.eq (bool.bool) (p1 (k j)) bool.true)) (logic.eq (nat.nat) (h (k j)) j))) (\(ltkj : nat.lt (k j) (nat.S n)) -> (\(p1kj : logic.eq (bool.bool) (p1 (k j)) bool.true) -> (\(eqj : logic.eq (nat.nat) (h (k j)) j) -> (((((connectives.conj) (connectives.And (nat.lt (k j) n) (logic.eq (bool.bool) (p1 (k j)) bool.true))) (logic.eq (nat.nat) (h (k j)) j)) (((((connectives.conj) (nat.lt (k j) n)) (logic.eq (bool.bool) (p1 (k j)) bool.true)) (((((((connectives.match::Or::prop) (nat.lt (k j) n)) (logic.eq (nat.nat) (k j) n)) (nat.lt (k j) n)) (\(auto : nat.lt (k j) n) -> (auto))) (\(eqkj : logic.eq (nat.nat) (k j) n) -> (((connectives.falsity) (nat.lt (k j) n)) (((((((nat.eqb::elim) (h n)) (j)) (\(:::: : bool.bool) -> (logic.eq (bool.bool) (bool.andb (bool.notb ::::) (p20 j)) bool.true) -> connectives.False)) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.true)) (bool.false)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (bool.false)) (bool.true))) (\(a : bool.bool) -> ((logic.eq (nat.nat) (h n) j) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false a) bool.true) -> connectives.False) -> (logic.eq (nat.nat) (h n) j) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.true)) bool.true) -> connectives.False)) (\(px : (logic.eq (nat.nat) (h n) j) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.true)) bool.true) -> connectives.False) -> (px))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p20 j) bool.false bool.false)) (bool.false)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (p20 j)) (bool.false))) (\(a : bool.bool) -> ((logic.eq (nat.nat) (h n) j) -> (logic.eq (bool.bool) a bool.true) -> connectives.False) -> (logic.eq (nat.nat) (h n) j) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false bool.false) bool.true) -> connectives.False)) (\(px : (logic.eq (nat.nat) (h n) j) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false bool.false) bool.true) -> connectives.False) -> (px))) (\(auto : logic.eq (nat.nat) (h n) j) -> (\(auto' : logic.eq (bool.bool) bool.false bool.true) -> ((((logic.absurd) (logic.eq (bool.bool) bool.true bool.false)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) bool.true ::::)) (((logic.refl) (bool.bool)) (bool.true))) (bool.false)) (auto'))) (bool.not::eq::true::false))))))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) (bool.true)) ((((bool.axiom::match::bool::type::false) (bool.bool)) (bool.false)) (bool.true))) (\(a : bool.bool) -> ((connectives.Not (logic.eq (nat.nat) (h n) j)) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false a) bool.true) -> connectives.False) -> (connectives.Not (logic.eq (nat.nat) (h n) j)) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) bool.true) -> connectives.False)) (\(px : (connectives.Not (logic.eq (nat.nat) (h n) j)) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false (bool.match::bool::type (bool.bool) bool.false bool.true bool.false)) bool.true) -> connectives.False) -> (px))) ((((((((connectives.equal::leibniz) (bool.bool)) (bool.match::bool::type (bool.bool) (p20 j) bool.false bool.true)) (p20 j)) ((((bool.axiom::match::bool::type::true) (bool.bool)) (p20 j)) (bool.false))) (\(a : bool.bool) -> ((connectives.Not (logic.eq (nat.nat) (h n) j)) -> (logic.eq (bool.bool) a bool.true) -> connectives.False) -> (connectives.Not (logic.eq (nat.nat) (h n) j)) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false bool.true) bool.true) -> connectives.False)) (\(px : (connectives.Not (logic.eq (nat.nat) (h n) j)) -> (logic.eq (bool.bool) (bool.match::bool::type (bool.bool) (p20 j) bool.false bool.true) bool.true) -> connectives.False) -> (px))) (\(auto : connectives.Not (logic.eq (nat.nat) (h n) j)) -> (\(auto' : logic.eq (bool.bool) (p20 j) bool.true) -> ((((logic.absurd) (logic.eq (nat.nat) (h n) j)) (((((((logic.rewrite::r) (nat.nat)) (j)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: j)) (((logic.refl) (nat.nat)) (j))) (h n)) (((((((logic.rewrite::l) (nat.nat)) (k j)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (h ::::) j)) (eqj)) (n)) (eqkj)))) (auto))))))) (p2j))))) ((((nat.le::to::or::lt::eq) (k j)) (n)) ((((nat.le::S::S::to::le) (k j)) (n)) (ltkj))))) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p1 (k j))) (p1kj)))) (((((((logic.rewrite::r) (nat.nat)) (j)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: j)) (((logic.refl) (nat.nat)) (j))) (h (k j))) (eqj))))))) (::clearme4)))) ((((sub2) (j)) (ltj)) ((((bool.andb::true::r) (bool.notb (nat.eqb (h n) j))) (p20 j)) (p2j))))))))) (f1 n)) ((((same) (n)) (ltn)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p1 n)) (p1n))))) (bigop (nat.nat) n2 (\(x : nat.nat) -> p20 x) (nat.S nat.O) nat.times (\(x : nat.nat) -> f2 x))) (((((((bigop::diff) (p20)) (f2)) (h n)) (n2)) (hn)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p20 (h n))) (p2hn)))))))) (::clearme3)))) ((((sub1) (n)) ((nat.le::n) (nat.S n))) (p1n)))) (bigop (nat.nat) (nat.S n) (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) ((((((((bigop::Strue) (nat.nat)) (n)) (p1)) (nat.S nat.O)) (nat.times)) (f1)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p1 n)) (p1n)))))) (\(p1n : logic.eq (bool.bool) (p1 n) bool.false) -> (((((((logic.eq::ind::r) (nat.nat)) (bigop (nat.nat) n (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) (\(x : nat.nat) -> logic.eq (nat.nat) x (bigop (nat.nat) n2 (\(i0 : nat.nat) -> p20 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f2 i0)))) (((((Hind) (p20)) ((((nat.lt::to::le) (n)) (n1)) (ltn))) ((((((((((((((((transitive::sub) (\(x : nat.nat) -> x)) (\(x : nat.nat) -> x)) (h)) (k)) (n)) (nat.S n)) (n2)) (p1)) (p1)) (p20)) (f1)) (f1)) (f2)) ((((((sub::lt) (f1)) (p1)) (n)) (nat.S n)) ((nat.le::n::Sn) (n)))) (sub1))) (\(i0 : nat.nat) -> \(lti : nat.lt i0 n2) -> (\(p2i : logic.eq (bool.bool) (p20 i0) bool.true) -> ((((((connectives.match::And::prop) (connectives.And (nat.lt (k i0) (nat.S n)) (logic.eq (bool.bool) (p1 (k i0)) bool.true))) (logic.eq (nat.nat) (h (k i0)) i0)) (connectives.And (connectives.And (nat.lt (k i0) n) (logic.eq (bool.bool) (p1 (k i0)) bool.true)) (logic.eq (nat.nat) (h (k i0)) i0))) (\(::clearme3 : connectives.And (nat.lt (k i0) (nat.S n)) (logic.eq (bool.bool) (p1 (k i0)) bool.true)) -> ((((((connectives.match::And::prop) (nat.lt (k i0) (nat.S n))) (logic.eq (bool.bool) (p1 (k i0)) bool.true)) ((logic.eq (nat.nat) (h (k i0)) i0) -> connectives.And (connectives.And (nat.lt (k i0) n) (logic.eq (bool.bool) (p1 (k i0)) bool.true)) (logic.eq (nat.nat) (h (k i0)) i0))) (\(ltki : nat.lt (k i0) (nat.S n)) -> (\(p1ki : logic.eq (bool.bool) (p1 (k i0)) bool.true) -> (\(eqi : logic.eq (nat.nat) (h (k i0)) i0) -> (((((connectives.conj) (connectives.And (nat.lt (k i0) n) (logic.eq (bool.bool) (p1 (k i0)) bool.true))) (logic.eq (nat.nat) (h (k i0)) i0)) (((((connectives.conj) (nat.lt (k i0) n)) (logic.eq (bool.bool) (p1 (k i0)) bool.true)) (((((((connectives.match::Or::prop) (nat.lt (k i0) n)) (logic.eq (nat.nat) (k i0) n)) (nat.lt (k i0) n)) (\(auto : nat.lt (k i0) n) -> (auto))) (\(eqki : logic.eq (nat.nat) (k i0) n) -> (((connectives.falsity) (nat.lt (k i0) n)) ((((logic.absurd) (logic.eq (bool.bool) bool.true bool.false)) (((((((logic.rewrite::l) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) bool.true ::::)) (((logic.refl) (bool.bool)) (bool.true))) (bool.false)) (((((((logic.rewrite::l) (bool.bool)) (p1 n)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (p1n)) (bool.true)) (((((((logic.rewrite::l) (nat.nat)) (k i0)) (\(:::: : nat.nat) -> logic.eq (bool.bool) (p1 ::::) bool.true)) (p1ki)) (n)) (eqki))))) (bool.not::eq::true::false))))) ((((nat.le::to::or::lt::eq) (k i0)) (n)) ((((nat.le::S::S::to::le) (k i0)) (n)) (ltki))))) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (p1 (k i0))) (p1ki)))) (((((((logic.rewrite::r) (nat.nat)) (i0)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: i0)) (((logic.refl) (nat.nat)) (i0))) (h (k i0))) (eqi))))))) (::clearme3)))) ((((sub2) (i0)) (lti)) (p2i))))))) (bigop (nat.nat) (nat.S n) (\(i0 : nat.nat) -> p1 i0) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f1 i0))) ((((((((bigop::Sfalse) (nat.nat)) (n)) (p1)) (nat.S nat.O)) (nat.times)) (f1)) (((((((logic.rewrite::r) (bool.bool)) (bool.false)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (((logic.refl) (bool.bool)) (bool.false))) (p1 n)) (p1n)))))) ((bool.true::or::false) (p1 n)))))))) (i)) (p2))))) (::clearme2)))) (::clearme1)))) (::clearme0)))) (::clearme))

