module sigma_pi where
open import Agda.Primitive
open import bigops
open import bool
open import exp
open import logic
open import nat
exp::pi::l : _
exp::pi::l = \(n : nat.nat) -> \(a : nat.nat) -> \(f : nat.nat -> nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a ::x::365) (bigops.bigop (nat.nat) ::x::365 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (bigops.bigop (nat.nat) ::x::365 (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i))))) ((((bigops.sym::eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i))))) ((((bigops.sym::eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i))))) (((nat.eq::times::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.S (y (nat.S nat.O))))) (((((nat.eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.times::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.S (y (nat.S nat.O))))) ((((nat.eq::times) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.S (y (nat.S nat.O))))) (((nat.eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.S (y (nat.times nat.O (nat.S nat.O)))))) (((((nat.eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.S (y (nat.times nat.O (nat.S nat.O)))))) ((((nat.eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.S (y (nat.times nat.O (nat.S nat.O)))))) ((((nat.eq::plus::body::S) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (nat.times nat.O (nat.S nat.O))))) ((((((nat.eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.plus::body)) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (nat.times nat.O (nat.S nat.O))))) ((((nat.eq::plus) (nat.S nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (nat.times nat.O (nat.S nat.O))))) ((((nat.eq::times::body::S) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (nat.S nat.O)))) ((((((nat.eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.times::body)) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (nat.S nat.O)))) ((((nat.eq::times) (nat.S nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (y (nat.S nat.O)))) ((((((nat.eq::match::nat::type::O) (nat.nat)) (nat.S nat.O)) (\(k : nat.nat) -> bool.match::bool::type (nat.nat) (nat.times (nat.times a (f k)) (bigops.bigop (nat.nat) k (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i)))) (bigops.bigop (nat.nat) k (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i))) bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times (nat.S nat.O) y))) ((((exp.eq::exp::body::O) (a)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times y (((\(p : (nat.nat -> bool.bool)) -> \(nil : nat.nat) -> \(op : (nat.nat -> nat.nat -> nat.nat)) -> \(f0 : (nat.nat -> nat.nat)) -> nat.match::nat::type (nat.nat) nil (\(k : nat.nat) -> bool.match::bool::type (nat.nat) (op (f0 k) (bigops.bigop (nat.nat) k p nil op f0)) (bigops.bigop (nat.nat) k p nil op f0) (p k)) nat.O) (\(i : nat.nat) -> bool.true)) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i)))))) (((((nat.eq::filter::nat::type::O) (nat.nat)) (exp.exp::body a)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times y (((\(p : (nat.nat -> bool.bool)) -> \(nil : nat.nat) -> \(op : (nat.nat -> nat.nat -> nat.nat)) -> \(f0 : (nat.nat -> nat.nat)) -> nat.match::nat::type (nat.nat) nil (\(k : nat.nat) -> bool.match::bool::type (nat.nat) (op (f0 k) (bigops.bigop (nat.nat) k p nil op f0)) (bigops.bigop (nat.nat) k p nil op f0) (p k)) nat.O) (\(i : nat.nat) -> bool.true)) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i)))))) (((((exp.eq::exp) (a)) (nat.O)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times y (((\(p : (nat.nat -> bool.bool)) -> \(nil : nat.nat) -> \(op : (nat.nat -> nat.nat -> nat.nat)) -> \(f0 : (nat.nat -> nat.nat)) -> nat.match::nat::type (nat.nat) nil (\(k : nat.nat) -> bool.match::bool::type (nat.nat) (op (f0 k) (bigops.bigop (nat.nat) k p nil op f0)) (bigops.bigop (nat.nat) k p nil op f0) (p k)) nat.O) (\(i : nat.nat) -> bool.true)) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i)))))) ((((((nat.sym::eq::match::nat::type::O) (nat.nat)) (nat.S nat.O)) (\(k : nat.nat) -> bool.match::bool::type (nat.nat) (nat.times (nat.times a (f k)) (bigops.bigop (nat.nat) k (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i)))) (bigops.bigop (nat.nat) k (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> nat.times a (f i))) bool.true)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times (exp.exp a nat.O) y))) ((((bigops.eq::bigop::body::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times (exp.exp a nat.O) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))))) ((((bigops.eq::bigop::O) (nat.nat)) (\(y : ((nat.nat -> bool.bool) -> nat.nat -> (nat.nat -> nat.nat -> nat.nat) -> (nat.nat -> nat.nat) -> nat.nat)) -> logic.eq (nat.nat) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))) (nat.times (exp.exp a nat.O) (y (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i))))) (((logic.refl) (nat.nat)) (nat.times (exp.exp a nat.O) (bigops.bigop (nat.nat) nat.O (\(i : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i : nat.nat) -> f i)))))))))))))))))))))))))) (\(i : nat.nat) -> \(Hind : logic.eq (nat.nat) (nat.times (exp.exp a i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> nat.times a (f i0)))) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.times (f i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a (nat.S i)) x) (bigops.bigop (nat.nat) (nat.S i) (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> nat.times a (f i0))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times (nat.times a (f i)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> nat.times a (f i0))))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a (nat.S i)) (nat.times (f i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) x)) (((((((logic.eq::ind) (nat.nat)) (nat.times (exp.exp a i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.times (exp.exp a (nat.S i)) (nat.times (f i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (nat.times (nat.times a (f i)) x::1))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times (exp.exp a (nat.S i)) (f i)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) x::1 (nat.times (nat.times a (f i)) (nat.times (exp.exp a i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times (nat.times a (f i)) (exp.exp a i)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.times (nat.times (exp.exp a (nat.S i)) (f i)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) x::1)) (((((((((((logic.eq::f2) (nat.nat)) (nat.nat)) (nat.nat)) (nat.times)) (nat.times (exp.exp a (nat.S i)) (f i))) (nat.times (nat.times a (f i)) (exp.exp a i))) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) (((((exp.sym::eq::exp) (a)) (nat.S i)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times y (f i)) (nat.times (nat.times a (f i)) (exp.exp a i)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat)) (exp.exp::body a)) (i)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times y (f i)) (nat.times (nat.times a (f i)) (exp.exp a i)))) (((((exp.sym::eq::exp::body::S) (a)) (i)) (\(y : nat.nat) -> logic.eq (nat.nat) (nat.times y (f i)) (nat.times (nat.times a (f i)) (exp.exp a i)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times a (exp.exp a i))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.times :::: (f i)) (nat.times (nat.times a (f i)) (exp.exp a i)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times (f i) (nat.times a (exp.exp a i)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.times (nat.times a (f i)) (exp.exp a i)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times a (nat.times (f i) (exp.exp a i)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.times (nat.times a (f i)) (exp.exp a i)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times (exp.exp a i) (nat.times a (f i)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.times a (nat.times (f i) (exp.exp a i))) ::::)) (((((((logic.rewrite::r) (nat.nat)) (nat.times a (nat.times (exp.exp a i) (f i)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.times a (nat.times (f i) (exp.exp a i))) ::::)) (((((((logic.rewrite::r) (nat.nat)) (nat.times (f i) (exp.exp a i))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.times a (nat.times (f i) (exp.exp a i))) (nat.times a ::::))) (((logic.refl) (nat.nat)) (nat.times a (nat.times (f i) (exp.exp a i))))) (nat.times (exp.exp a i) (f i))) (((nat.commutative::times) (exp.exp a i)) (f i)))) (nat.times (exp.exp a i) (nat.times a (f i)))) ((((nat.times::times) (exp.exp a i)) (a)) (f i)))) (nat.times (nat.times a (f i)) (exp.exp a i))) (((nat.commutative::times) (nat.times a (f i))) (exp.exp a i)))) (nat.times (f i) (nat.times a (exp.exp a i)))) ((((nat.times::times) (f i)) (a)) (exp.exp a i)))) (nat.times (nat.times a (exp.exp a i)) (f i))) (((nat.commutative::times) (nat.times a (exp.exp a i))) (f i)))) (nat.times (exp.exp a i) a)) (((nat.commutative::times) (exp.exp a i)) (a))))))) (((logic.refl) (nat.nat)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (nat.times (nat.times a (f i)) (nat.times (exp.exp a i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) ((((nat.associative::times) (nat.times a (f i))) (exp.exp a i)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (nat.times (exp.exp a (nat.S i)) (nat.times (f i) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) ((((nat.associative::times) (exp.exp a (nat.S i))) (f i)) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))))) (bigops.bigop (nat.nat) i (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> nat.times a (f i0)))) (Hind))) (bigops.bigop (nat.nat) (nat.S i) (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> nat.times a (f i0)))) ((((((((bigops.bigop::Strue) (nat.nat)) (i)) (\(:::: : nat.nat) -> bool.true)) (nat.S nat.O)) (nat.times)) (\(:::: : nat.nat) -> nat.times a (f ::::))) (((logic.refl) (bool.bool)) (bool.true))))) (bigops.bigop (nat.nat) (nat.S i) (\(i0 : nat.nat) -> bool.true) (nat.S nat.O) nat.times (\(i0 : nat.nat) -> f i0))) ((((((((bigops.bigop::Strue) (nat.nat)) (i)) (\(:::: : nat.nat) -> bool.true)) (nat.S nat.O)) (nat.times)) (f)) (((logic.refl) (bool.bool)) (bool.true)))))) (n)

exp::pi::bc : _
exp::pi::bc = \(a : nat.nat) -> \(b : nat.nat) -> \(c : nat.nat) -> \(f : nat.nat -> nat.nat) -> (((exp::pi::l) (nat.minus c b)) (a)) (\(:::: : nat.nat) -> f (nat.plus :::: b))

