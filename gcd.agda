module gcd where
open import Agda.Primitive
open import bool
open import connectives
open import div_mod
open import leibniz
open import logic
open import nat
open import primes
postulate gcd::aux : nat.nat -> nat.nat -> nat.nat -> nat.nat
postulate gcd::aux::body : nat.nat -> nat.nat -> nat.nat -> nat.nat
postulate axiom::gcd::aux : forall (p : nat.nat) -> connectives.equal (nat.nat -> nat.nat -> nat.nat) (gcd::aux p) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) gcd::aux::body p)
eq::gcd::aux : _
eq::gcd::aux = \(p : nat.nat) -> ((((connectives.equal::leibniz) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux p)) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) gcd::aux::body p)) ((axiom::gcd::aux) (p))

sym::eq::gcd::aux : _
sym::eq::gcd::aux = \(p : nat.nat) -> ((((leibniz.sym::leibniz) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux p)) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) gcd::aux::body p)) ((eq::gcd::aux) (p))

postulate axiom::gcd::aux::body::O : connectives.equal (nat.nat -> nat.nat -> nat.nat) (gcd::aux::body nat.O) (\(m : nat.nat) -> \(n : nat.nat) -> m)
eq::gcd::aux::body::O : _
eq::gcd::aux::body::O = ((((connectives.equal::leibniz) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body nat.O)) (\(m : nat.nat) -> \(n : nat.nat) -> m)) (axiom::gcd::aux::body::O)

sym::eq::gcd::aux::body::O : _
sym::eq::gcd::aux::body::O = ((((leibniz.sym::leibniz) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body nat.O)) (\(m : nat.nat) -> \(n : nat.nat) -> m)) (eq::gcd::aux::body::O)

postulate axiom::gcd::aux::body::S : forall (p : nat.nat) -> connectives.equal (nat.nat -> nat.nat -> nat.nat) (gcd::aux::body (nat.S p)) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) n (gcd::aux p n (div_mod.mod m n)) (primes.dividesb n m))
eq::gcd::aux::body::S : _
eq::gcd::aux::body::S = \(p : nat.nat) -> ((((connectives.equal::leibniz) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body (nat.S p))) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) n (gcd::aux p n (div_mod.mod m n)) (primes.dividesb n m))) ((axiom::gcd::aux::body::S) (p))

sym::eq::gcd::aux::body::S : _
sym::eq::gcd::aux::body::S = \(p : nat.nat) -> ((((leibniz.sym::leibniz) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body (nat.S p))) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) n (gcd::aux p n (div_mod.mod m n)) (primes.dividesb n m))) ((eq::gcd::aux::body::S) (p))

gcd : _
gcd = \(n : nat.nat) -> \(m : nat.nat) -> bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) (nat.leb n m)

commutative::gcd : _
commutative::gcd = \(n : nat.nat) -> \(m : nat.nat) -> (((((nat.leb::elim) (n)) (m)) (\(:::: : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) ::::) (bool.match::bool::type (nat.nat) (gcd::aux m n m) (gcd::aux n m n) (nat.leb m n)))) (\(lenm : nat.le n m) -> (((((((connectives.match::Or::prop) (nat.lt n m)) (logic.eq (nat.nat) n m)) (logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true) (bool.match::bool::type (nat.nat) (gcd::aux m n m) (gcd::aux n m n) (nat.leb m n)))) (\(ltnm : nat.lt n m) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true) (bool.match::bool::type (nat.nat) (gcd::aux m n m) (gcd::aux n m n) x))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux m n m)) (gcd::aux n m n)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true) y)) ((((((bool.eq::match::bool::type::true) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true))))) (nat.leb m n)) ((((nat.not::le::to::leb::false) (m)) (n)) ((((nat.lt::to::not::le) (n)) (m)) (ltnm)))))) (\(eqnm : logic.eq (nat.nat) n m) -> (((((((logic.eq::ind::r) (nat.nat)) (m)) (\(x : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux x m x) (gcd::aux m x m) bool.true) (bool.match::bool::type (nat.nat) (gcd::aux m x m) (gcd::aux x m x) (nat.leb m x)))) (((((bool.match::bool::prop) (\(:::: : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux m m m) (gcd::aux m m m) bool.true) (bool.match::bool::type (nat.nat) (gcd::aux m m m) (gcd::aux m m m) ::::))) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) (gcd::aux m m m) (gcd::aux m m m) bool.true))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux m m m)) (gcd::aux m m m)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux m m m) (gcd::aux m m m) bool.true) y)) ((((((bool.eq::match::bool::type::true) (nat.nat)) (gcd::aux m m m)) (gcd::aux m m m)) (\(y : nat.nat) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux m m m) (gcd::aux m m m) bool.true) y)) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) (gcd::aux m m m) (gcd::aux m m m) bool.true))))) (nat.leb m m))) (n)) (eqnm)))) ((((nat.le::to::or::lt::eq) (n)) (m)) (lenm))))) (\(notlenm : connectives.Not (nat.le n m)) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.false) (bool.match::bool::type (nat.nat) (gcd::aux m n m) (gcd::aux n m n) x))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> logic.eq (nat.nat) y (bool.match::bool::type (nat.nat) (gcd::aux m n m) (gcd::aux n m n) bool.true))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (gcd::aux m n m)) (gcd::aux n m n)) (\(y : nat.nat) -> logic.eq (nat.nat) (gcd::aux m n m) y)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> logic.eq (nat.nat) (gcd::aux m n m) y)) ((((((bool.eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> logic.eq (nat.nat) y (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.false))) (((logic.refl) (nat.nat)) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.false))))))) (nat.leb m n)) ((((nat.le::to::leb::true) (m)) (n)) ((((((nat.transitive::le) (m)) (nat.S m)) (n)) ((nat.le::n::Sn) (m))) ((((nat.not::le::to::lt) (n)) (m)) (notlenm))))))

gcd::O::l : _
gcd::O::l = \(m : nat.nat) -> (((((bool.eq::match::bool::type::true) (nat.nat)) (m)) (gcd::aux m nat.O m)) (\(y : nat.nat) -> logic.eq (nat.nat) (gcd nat.O m) y)) (((nat.eq::leb::body::O) (\(y : (nat.nat -> bool.bool)) -> logic.eq (nat.nat) (gcd nat.O m) (bool.match::bool::type (nat.nat) m (gcd::aux m nat.O m) (y m)))) (((((nat.eq::filter::nat::type::O) (nat.nat -> bool.bool)) (nat.leb::body)) (\(y : (nat.nat -> bool.bool)) -> logic.eq (nat.nat) (gcd nat.O m) (bool.match::bool::type (nat.nat) m (gcd::aux m nat.O m) (y m)))) ((((nat.eq::leb) (nat.O)) (\(y : (nat.nat -> bool.bool)) -> logic.eq (nat.nat) (gcd nat.O m) (bool.match::bool::type (nat.nat) m (gcd::aux m nat.O m) (y m)))) (((eq::gcd::aux::body::O) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) (gcd nat.O m) (bool.match::bool::type (nat.nat) (y m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)))) (((((nat.eq::filter::nat::type::O) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) (gcd nat.O m) (bool.match::bool::type (nat.nat) (y m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)))) ((((eq::gcd::aux) (nat.O)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) (gcd nat.O m) (bool.match::bool::type (nat.nat) (y m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)))) (((logic.refl) (nat.nat)) (gcd nat.O m))))))))

divides::mod::to::divides : _
divides::mod::to::divides = \(p : nat.nat) -> \(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(::clearme : primes.divides p (div_mod.mod m n)) -> ((((((primes.match::divides::prop) (p)) (div_mod.mod m n)) ((primes.divides p n) -> primes.divides p m)) (\(q1 : nat.nat) -> \(eq1 : logic.eq (nat.nat) (div_mod.mod m n) (nat.times p q1)) -> (\(::clearme0 : primes.divides p n) -> ((((((primes.match::divides::prop) (p)) (n)) (primes.divides p m)) (\(q2 : nat.nat) -> \(eq2 : logic.eq (nat.nat) n (nat.times p q2)) -> (((((primes.quotient) (p)) (m)) (nat.plus (nat.times q2 (div_mod.div m n)) q1)) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times p (nat.times q2 (div_mod.div m n))) (nat.times p q1))) (\(x : nat.nat) -> logic.eq (nat.nat) m x)) (((((((logic.eq::ind) (nat.nat)) (div_mod.mod m n)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.plus (nat.times p (nat.times q2 (div_mod.div m n))) x::1))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times p q2) (div_mod.div m n))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.plus x::1 (div_mod.mod m n)))) (((((((logic.eq::ind) (nat.nat)) (n)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.plus (nat.times x::1 (div_mod.div m n)) (div_mod.mod m n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus (div_mod.mod m n) (nat.times n (div_mod.div m n)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((logic.refl) (nat.nat)) (m))) (nat.plus (div_mod.mod m n) (nat.times n (div_mod.div m n)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times n (div_mod.div m n)) (div_mod.mod m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times (div_mod.div m n) n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.plus :::: (div_mod.mod m n)))) (((div_mod.div::mod) (m)) (n))) (nat.times n (div_mod.div m n))) (((nat.commutative::times) (div_mod.div m n)) (n)))) (nat.plus (div_mod.mod m n) (nat.times n (div_mod.div m n)))) (((nat.commutative::plus) (nat.times n (div_mod.div m n))) (div_mod.mod m n))))) (nat.plus (nat.times n (div_mod.div m n)) (div_mod.mod m n))) (((nat.commutative::plus) (nat.times n (div_mod.div m n))) (div_mod.mod m n)))) (nat.times p q2)) (eq2))) (nat.times p (nat.times q2 (div_mod.div m n)))) ((((nat.associative::times) (p)) (q2)) (div_mod.div m n)))) (nat.times p q1)) (eq1))) (nat.times p (nat.plus (nat.times q2 (div_mod.div m n)) q1))) ((((nat.distributive::times::plus) (p)) (nat.times q2 (div_mod.div m n))) (q1)))))) (::clearme0))))) (::clearme)))

divides::to::gcd::aux : _
divides::to::gcd::aux = \(p : nat.nat) -> \(m : nat.nat) -> \(n : nat.nat) -> \(posp : nat.lt nat.O p) -> (((((nat.lt::O::n::elim) (p)) (posp)) (\(:::: : nat.nat) -> (nat.lt nat.O n) -> (primes.divides n m) -> logic.eq (nat.nat) (gcd::aux :::: m n) n)) (\(l : nat.nat) -> (((sym::eq::gcd::aux) (nat.S l)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.lt nat.O n) -> (primes.divides n m) -> logic.eq (nat.nat) (y m n) n)) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body)) (l)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.lt nat.O n) -> (primes.divides n m) -> logic.eq (nat.nat) (y m n) n)) ((((sym::eq::gcd::aux::body::S) (l)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.lt nat.O n) -> (primes.divides n m) -> logic.eq (nat.nat) (y m n) n)) (\(posn : nat.lt nat.O n) -> (\(divnm : primes.divides n m) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.true)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) n (gcd::aux l n (div_mod.mod m n)) x) n)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (n)) (gcd::aux l n (nat.match::nat::type (nat.nat) m (\(p0 : nat.nat) -> div_mod.mod::aux m m p0) n))) (\(y : nat.nat) -> logic.eq (nat.nat) y n)) (((logic.refl) (nat.nat)) (n)))) (primes.dividesb n m)) (((((primes.divides::to::dividesb::true) (n)) (m)) (posn)) (divnm)))))))))

not::divides::to::gcd::aux : _
not::divides::to::gcd::aux = \(p : nat.nat) -> \(m : nat.nat) -> \(n : nat.nat) -> (((sym::eq::gcd::aux) (nat.S p)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.lt nat.O n) -> (connectives.Not (primes.divides n m)) -> logic.eq (nat.nat) (y m n) (gcd::aux p n (div_mod.mod m n)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body)) (p)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.lt nat.O n) -> (connectives.Not (primes.divides n m)) -> logic.eq (nat.nat) (y m n) (gcd::aux p n (div_mod.mod m n)))) ((((sym::eq::gcd::aux::body::S) (p)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.lt nat.O n) -> (connectives.Not (primes.divides n m)) -> logic.eq (nat.nat) (y m n) (gcd::aux p n (div_mod.mod m n)))) (\(lenm : nat.lt nat.O n) -> (\(divnm : connectives.Not (primes.divides n m)) -> (((((((logic.eq::ind::r) (bool.bool)) (bool.false)) (\(x : bool.bool) -> logic.eq (nat.nat) (bool.match::bool::type (nat.nat) n (gcd::aux p n (div_mod.mod m n)) x) (gcd::aux p n (div_mod.mod m n)))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (n)) (gcd::aux p n (nat.match::nat::type (nat.nat) m (\(p0 : nat.nat) -> div_mod.mod::aux m m p0) n))) (\(y : nat.nat) -> logic.eq (nat.nat) y (gcd::aux p n (nat.match::nat::type (nat.nat) m (\(p0 : nat.nat) -> div_mod.mod::aux m m p0) n)))) (((logic.refl) (nat.nat)) (gcd::aux p n (nat.match::nat::type (nat.nat) m (\(p0 : nat.nat) -> div_mod.mod::aux m m p0) n))))) (primes.dividesb n m)) (((((primes.not::divides::to::dividesb::false) (n)) (m)) (lenm)) (divnm)))))))

divides::gcd::aux::mn : _
divides::gcd::aux::mn = \(p : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (m : nat.nat) -> forall (n : nat.nat) -> (nat.lt nat.O n) -> (nat.le n m) -> (nat.le n ::x::365) -> connectives.And (primes.divides (gcd::aux ::x::365 m n) m) (primes.divides (gcd::aux ::x::365 m n) n))) (\(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(lenm : nat.le n m) -> (\(lenO : nat.le n nat.O) -> (((connectives.falsity) (connectives.And (primes.divides (gcd::aux nat.O m n) m) (primes.divides (gcd::aux nat.O m n) n))) ((((logic.absurd) (nat.lt nat.O n)) (posn)) ((((nat.le::to::not::lt) (n)) (nat.O)) (lenO)))))))) (\(q : nat.nat) -> \(Hind : forall (m : nat.nat) -> forall (n : nat.nat) -> (nat.lt nat.O n) -> (nat.le n m) -> (nat.le n q) -> connectives.And (primes.divides (gcd::aux q m n) m) (primes.divides (gcd::aux q m n) n)) -> (\(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(lenm : nat.le n m) -> (\(lenS : nat.le n (nat.S q)) -> (((((((connectives.match::Or::prop) (primes.divides n m)) (connectives.Not (primes.divides n m))) (connectives.And (primes.divides (gcd::aux (nat.S q) m n) m) (primes.divides (gcd::aux (nat.S q) m n) n))) (\(divnm : primes.divides n m) -> (((((((logic.eq::ind::r) (nat.nat)) (n)) (\(x : nat.nat) -> connectives.And (primes.divides x m) (primes.divides x n))) (((((connectives.conj) (primes.divides n m)) (primes.divides n n)) (divnm)) ((primes.divides::n::n) (n)))) (gcd::aux (nat.S q) m n)) (((((((divides::to::gcd::aux) (nat.S q)) (m)) (n)) ((nat.lt::O::S) (q))) (posn)) (divnm))))) (\(ndivnm : connectives.Not (primes.divides n m)) -> (((((((logic.eq::ind::r) (nat.nat)) (gcd::aux q n (div_mod.mod m n))) (\(x : nat.nat) -> connectives.And (primes.divides x m) (primes.divides x n))) ((((((connectives.match::And::prop) (primes.divides (gcd::aux q n (div_mod.mod m n)) n)) (primes.divides (gcd::aux q n (div_mod.mod m n)) (div_mod.mod m n))) (connectives.And (primes.divides (gcd::aux q n (div_mod.mod m n)) m) (primes.divides (gcd::aux q n (div_mod.mod m n)) n))) (\(H : primes.divides (gcd::aux q n (div_mod.mod m n)) n) -> (\(H1 : primes.divides (gcd::aux q n (div_mod.mod m n)) (div_mod.mod m n)) -> (((((connectives.conj) (primes.divides (gcd::aux q n (div_mod.mod m n)) m)) (primes.divides (gcd::aux q n (div_mod.mod m n)) n)) (((((((divides::mod::to::divides) (gcd::aux q n (div_mod.mod m n))) (m)) (n)) (posn)) (H1)) (H))) (H))))) ((((((Hind) (n)) (div_mod.mod m n)) (((((((connectives.match::Or::prop) (nat.lt nat.O (div_mod.mod m n))) (logic.eq (nat.nat) nat.O (div_mod.mod m n))) (nat.lt nat.O (div_mod.mod m n))) (\(auto : nat.lt nat.O (div_mod.mod m n)) -> (auto))) (\(modO : logic.eq (nat.nat) nat.O (div_mod.mod m n)) -> (((connectives.falsity) (nat.lt nat.O (div_mod.mod m n))) ((((logic.absurd) (primes.divides n m)) (((((primes.mod::O::to::divides) (n)) (m)) (posn)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: nat.O)) (((logic.refl) (nat.nat)) (nat.O))) (div_mod.mod m n)) (modO)))) (ndivnm))))) ((((nat.le::to::or::lt::eq) (nat.O)) (div_mod.mod m n)) ((nat.le::O::n) (div_mod.mod m n))))) ((((nat.lt::to::le) (div_mod.mod m n)) (n)) ((((div_mod.lt::mod::m::m) (m)) (n)) (posn)))) ((((nat.le::S::S::to::le) (div_mod.mod m n)) (q)) ((((((nat.transitive::le) (nat.S (div_mod.mod m n))) (n)) (nat.S q)) ((((div_mod.lt::mod::m::m) (m)) (n)) (posn))) (lenS)))))) (gcd::aux (nat.S q) m n)) ((((((not::divides::to::gcd::aux) (q)) (m)) (n)) (posn)) (ndivnm))))) (((primes.decidable::divides) (n)) (m)))))))) (p)

divides::gcd::nm : _
divides::gcd::nm = \(n : nat.nat) -> \(m : nat.nat) -> ((((((connectives.match::Or::prop) (nat.lt nat.O n)) (logic.eq (nat.nat) nat.O n)) (connectives.And (primes.divides (gcd n m) m) (primes.divides (gcd n m) n))) (\(posn : nat.lt nat.O n) -> (((((((connectives.match::Or::prop) (nat.lt nat.O m)) (logic.eq (nat.nat) nat.O m)) (connectives.And (primes.divides (gcd n m) m) (primes.divides (gcd n m) n))) (\(posm : nat.lt nat.O m) -> ((((((nat.leb::elim) (n)) (m)) (\(:::: : bool.bool) -> connectives.And (primes.divides (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) ::::) m) (primes.divides (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) ::::) n))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (nat.le n m) -> connectives.And (primes.divides (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true) m) (primes.divides y n))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (nat.le n m) -> connectives.And (primes.divides y m) (primes.divides (gcd::aux n m n) n))) (\(lenm : nat.le n m) -> (((((((divides::gcd::aux::mn) (n)) (m)) (n)) (posn)) (lenm)) ((nat.le::n) (n))))))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (connectives.Not (nat.le n m)) -> connectives.And (primes.divides (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.false) m) (primes.divides y n))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (connectives.Not (nat.le n m)) -> connectives.And (primes.divides y m) (primes.divides (gcd::aux m n m) n))) (\(notlt : connectives.Not (nat.le n m)) -> ((((((connectives.match::And::prop) (primes.divides (gcd::aux m n m) n)) (primes.divides (gcd::aux m n m) m)) (connectives.And (primes.divides (gcd::aux m n m) m) (primes.divides (gcd::aux m n m) n))) (\(auto : primes.divides (gcd::aux m n m) n) -> (\(auto' : primes.divides (gcd::aux m n m) m) -> (((((connectives.conj) (primes.divides (gcd::aux m n m) m)) (primes.divides (gcd::aux m n m) n)) (auto')) (auto))))) (((((((divides::gcd::aux::mn) (m)) (n)) (m)) (posm)) ((((((nat.transitive::le) (m)) (nat.S m)) (n)) ((nat.le::n::Sn) (m))) ((((nat.not::le::to::lt) (n)) (m)) (notlt)))) ((nat.le::n) (m)))))))))) (\(eqmO : logic.eq (nat.nat) nat.O m) -> (((((((logic.eq::ind) (nat.nat)) (nat.O)) (\(x::1 : nat.nat) -> connectives.And (primes.divides (gcd n x::1) x::1) (primes.divides (gcd n x::1) n))) (((((connectives.conj) (primes.divides (gcd n nat.O) nat.O)) (primes.divides (gcd n nat.O) n)) ((primes.divides::n::O) (gcd n nat.O))) (((((logic.eq::coerc) (primes.divides (gcd n nat.O) (gcd n nat.O))) (primes.divides (gcd n nat.O) n)) ((primes.divides::n::n) (gcd n nat.O))) (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (primes.divides (gcd n nat.O) ::::) (primes.divides (gcd n nat.O) n))) (((logic.refl) (Set)) (primes.divides (gcd n nat.O) n))) (gcd n nat.O)) (((((((logic.rewrite::l) (nat.nat)) (gcd nat.O n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd n nat.O) ::::)) (((commutative::gcd) (n)) (nat.O))) (n)) ((gcd::O::l) (n))))))) (m)) (eqmO)))) ((((nat.le::to::or::lt::eq) (nat.O)) (m)) ((nat.le::O::n) (m)))))) (\(eqnO : logic.eq (nat.nat) nat.O n) -> (((((((logic.eq::ind) (nat.nat)) (nat.O)) (\(x::1 : nat.nat) -> connectives.And (primes.divides (gcd x::1 m) m) (primes.divides (gcd x::1 m) x::1))) (((((connectives.conj) (primes.divides (gcd nat.O m) m)) (primes.divides (gcd nat.O m) nat.O)) ((((((bool.eq::match::bool::type::true) (nat.nat)) (m)) (gcd::aux m nat.O m)) (\(y : nat.nat) -> primes.divides (bool.match::bool::type (nat.nat) (gcd::aux nat.O m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)) y)) (((nat.eq::leb::body::O) (\(y : (nat.nat -> bool.bool)) -> primes.divides (bool.match::bool::type (nat.nat) (gcd::aux nat.O m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)) (bool.match::bool::type (nat.nat) m (gcd::aux m nat.O m) (y m)))) (((((nat.eq::filter::nat::type::O) (nat.nat -> bool.bool)) (nat.leb::body)) (\(y : (nat.nat -> bool.bool)) -> primes.divides (bool.match::bool::type (nat.nat) (gcd::aux nat.O m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)) (bool.match::bool::type (nat.nat) m (gcd::aux m nat.O m) (y m)))) ((((nat.eq::leb) (nat.O)) (\(y : (nat.nat -> bool.bool)) -> primes.divides (bool.match::bool::type (nat.nat) (gcd::aux nat.O m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)) (bool.match::bool::type (nat.nat) m (gcd::aux m nat.O m) (y m)))) (((eq::gcd::aux::body::O) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> primes.divides (gcd nat.O m) (bool.match::bool::type (nat.nat) (y m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)))) (((((nat.eq::filter::nat::type::O) (nat.nat -> nat.nat -> nat.nat)) (gcd::aux::body)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> primes.divides (gcd nat.O m) (bool.match::bool::type (nat.nat) (y m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)))) ((((eq::gcd::aux) (nat.O)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> primes.divides (gcd nat.O m) (bool.match::bool::type (nat.nat) (y m nat.O) (gcd::aux m nat.O m) (nat.leb nat.O m)))) ((primes.divides::n::n) (gcd nat.O m)))))))))) ((primes.divides::n::O) (gcd nat.O m)))) (n)) (eqnO)))) ((((nat.le::to::or::lt::eq) (nat.O)) (n)) ((nat.le::O::n) (n)))

divides::gcd::l : _
divides::gcd::l = \(n : nat.nat) -> \(m : nat.nat) -> (((logic.proj2) (primes.divides (gcd n m) m)) (primes.divides (gcd n m) n)) (((divides::gcd::nm) (n)) (m))

divides::gcd::r : _
divides::gcd::r = \(n : nat.nat) -> \(m : nat.nat) -> (((logic.proj1) (primes.divides (gcd n m) m)) (primes.divides (gcd n m) n)) (((divides::gcd::nm) (n)) (m))

let::clause::1544 : _
let::clause::1544 = \(p : nat.nat) -> \(q : nat.nat) -> \(Hind : forall (m : nat.nat) -> forall (n : nat.nat) -> (nat.lt nat.O n) -> (nat.le n m) -> (nat.le n q) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux q m n)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux q m n))))) -> (\(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(lenm : nat.le n m) -> (\(lenS : nat.le n (nat.S q)) -> (\(ndivnm : connectives.Not (primes.divides n m)) -> (\(a : nat.nat) -> \(::clearme : connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n))))) -> (\(b : nat.nat) -> \(::clearme0 : connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n)))) -> (\(H : logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) -> (((((((logic.rewrite::l) (nat.nat)) (nat.times b n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) ::::) (gcd::aux q n (div_mod.mod m n)))) (H)) (nat.times n b)) (((nat.commutative::times) (b)) (n))))))))))

let::clause::15441 : _
let::clause::15441 = \(p : nat.nat) -> \(q : nat.nat) -> \(Hind : forall (m : nat.nat) -> forall (n : nat.nat) -> (nat.lt nat.O n) -> (nat.le n m) -> (nat.le n q) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux q m n)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux q m n))))) -> (\(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(lenm : nat.le n m) -> (\(lenS : nat.le n (nat.S q)) -> (\(ndivnm : connectives.Not (primes.divides n m)) -> (\(a : nat.nat) -> \(::clearme : connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n))))) -> (\(b : nat.nat) -> \(::clearme0 : connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n)))) -> (\(H : logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n))) -> (((((((logic.rewrite::l) (nat.nat)) (nat.times b n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n)))) (H)) (nat.times n b)) (((nat.commutative::times) (b)) (n))))))))))

eq::minus::gcd::aux : _
eq::minus::gcd::aux = \(p : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (m : nat.nat) -> forall (n : nat.nat) -> (nat.lt nat.O n) -> (nat.le n m) -> (nat.le n ::x::365) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux ::x::365 m n)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux ::x::365 m n)))))) (\(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(lenm : nat.le n m) -> (\(lenO : nat.le n nat.O) -> (((connectives.falsity) (connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux nat.O m n)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux nat.O m n)))))) ((((logic.absurd) (nat.lt nat.O n)) (posn)) ((((nat.le::to::not::lt) (n)) (nat.O)) (lenO)))))))) (\(q : nat.nat) -> \(Hind : forall (m : nat.nat) -> forall (n : nat.nat) -> (nat.lt nat.O n) -> (nat.le n m) -> (nat.le n q) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux q m n)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux q m n))))) -> (\(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(lenm : nat.le n m) -> (\(lenS : nat.le n (nat.S q)) -> (((((((connectives.match::Or::prop) (primes.divides n m)) (connectives.Not (primes.divides n m))) (connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux (nat.S q) m n)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux (nat.S q) m n)))))) (\(divnm : primes.divides n m) -> (((((((logic.eq::ind::r) (nat.nat)) (n)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) x) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) x))))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times x n) (nat.times b m)) n) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times x n)) n)))) (nat.S nat.O)) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times x m)) n) (logic.eq (nat.nat) (nat.minus (nat.times x m) (nat.times (nat.S nat.O) n)) n))) (nat.O)) ((((connectives.or::introl) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m)) n)) (logic.eq (nat.nat) (nat.minus (nat.times nat.O m) (nat.times (nat.S nat.O) n)) n)) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (nat.S nat.O))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) n)) (((((((logic.rewrite::l) (nat.nat)) (nat.plus n (nat.times n nat.O))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) n)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus n ::::) (nat.times nat.O m)) n)) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) n)) (((((((logic.rewrite::r) (nat.nat)) (nat.times m nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus n ::::) n)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus n ::::) n)) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: n)) (((logic.refl) (nat.nat)) (n))) (nat.minus n nat.O)) ((nat.minus::n::O) (n)))) (nat.times m nat.O)) ((nat.times::n::O) (m)))) (nat.times nat.O m)) (((nat.commutative::times) (nat.O)) (m)))) (nat.plus n nat.O)) ((nat.plus::n::O) (n)))) (nat.times n nat.O)) ((nat.times::n::O) (n)))) (nat.times n (nat.S nat.O))) (((nat.times::n::Sm) (n)) (nat.O)))) (nat.times (nat.S nat.O) n)) (((nat.commutative::times) (nat.S nat.O)) (n))))))) (gcd::aux (nat.S q) m n)) (((((((divides::to::gcd::aux) (nat.S q)) (m)) (n)) ((nat.lt::O::S) (q))) (posn)) (divnm))))) (\(ndivnm : connectives.Not (primes.divides n m)) -> (((((((logic.eq::ind::r) (nat.nat)) (gcd::aux q n (div_mod.mod m n))) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) x) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) x))))) ((((((connectives.match::ex::prop) (nat.nat)) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n)))))) (connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux q n (div_mod.mod m n))))))) (\(a : nat.nat) -> \(::clearme : connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n))))) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n))))) (connectives.ex (nat.nat) (\(a0 : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a0 n) (nat.times b m)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a0 n)) (gcd::aux q n (div_mod.mod m n))))))) (\(b : nat.nat) -> \(::clearme0 : connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n)))) -> (((((((connectives.match::Or::prop) (logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n)))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n)))) (connectives.ex (nat.nat) (\(a0 : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a0 n) (nat.times b0 m)) (gcd::aux q n (div_mod.mod m n))) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times a0 n)) (gcd::aux q n (div_mod.mod m n))))))) (\(H : logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) (gcd::aux q n (div_mod.mod m n))) -> (((((((logic.eq::ind) (nat.nat)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))) (\(x::1 : nat.nat) -> connectives.ex (nat.nat) (\(a0 : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a0 n) (nat.times b0 m)) x::1) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times a0 n)) x::1))))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times x n) (nat.times b0 m)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times x n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))))) (nat.plus b (nat.times a (div_mod.div m n)))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n) (nat.times x m)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))) (logic.eq (nat.nat) (nat.minus (nat.times x m) (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))))) (a)) ((((connectives.or::intror) (logic.eq (nat.nat) (nat.minus (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n) (nat.times a m)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind) (nat.nat)) (nat.plus (nat.times a (div_mod.div m n)) b)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times x::1 n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times (nat.times a (div_mod.div m n)) n) (nat.times b n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a m) x) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times (div_mod.div m n) n) (div_mod.mod m n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a x) (nat.plus (nat.times (nat.times a (div_mod.div m n)) n) (nat.times b n))) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times a (nat.times (div_mod.div m n) n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a (nat.plus (nat.times (div_mod.div m n) n) (div_mod.mod m n))) (nat.plus x (nat.times b n))) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind) (nat.nat)) (nat.plus (div_mod.mod m n) (nat.times (div_mod.div m n) n))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a x::1) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times b n))) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times a (div_mod.mod m n)) (nat.times a (nat.times (div_mod.div m n) n)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus x (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times b n))) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind) (nat.nat)) (nat.minus (nat.minus (nat.plus (nat.times a (div_mod.mod m n)) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) x::1 (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind) (nat.nat)) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (div_mod.mod m n)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.minus x::1 (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.eq::ind) (nat.nat)) (nat.plus (nat.minus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.minus x::1 (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (div_mod.div m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus (nat.times a ::::) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n))) (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (nat.times a (div_mod.div m n)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus :::: (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n))) (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (div_mod.div m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus (nat.times n (nat.times a (div_mod.div m n))) (nat.times a ::::)) (nat.times a (div_mod.mod m n))) (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (nat.times a (div_mod.div m n)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus (nat.times n (nat.times a (div_mod.div m n))) ::::) (nat.times a (div_mod.mod m n))) (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus :::: (nat.times a (div_mod.mod m n))) (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::l) (nat.nat)) (nat.times a (div_mod.mod m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times b n)) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times a (div_mod.mod m n)) ::::) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (gcd::aux q n (div_mod.mod m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd::aux q n (div_mod.mod m n)) (nat.minus (nat.times a (div_mod.mod m n)) ::::))) (((((((logic.rewrite::r) (nat.nat)) (gcd::aux q n (div_mod.mod m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd::aux q n (div_mod.mod m n)) ::::)) (((logic.refl) (nat.nat)) (gcd::aux q n (div_mod.mod m n)))) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times n b))) (((((((((((((((let::clause::1544) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (::clearme)) (b)) (::clearme0)) (H)))) (nat.times b n)) (((nat.commutative::times) (b)) (n)))) (nat.minus (nat.times a (div_mod.mod m n)) (nat.times n b))) (((((((((((((((let::clause::1544) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (::clearme)) (b)) (::clearme0)) (H)))) (nat.times b n)) (((nat.commutative::times) (b)) (n)))) (nat.plus nat.O (nat.times a (div_mod.mod m n)))) ((nat.plus::O::n) (nat.times a (div_mod.mod m n))))) (nat.minus (nat.times n (nat.times a (div_mod.div m n))) (nat.times n (nat.times a (div_mod.div m n))))) ((nat.minus::n::n) (nat.times n (nat.times a (div_mod.div m n)))))) (nat.times a (nat.times n (div_mod.div m n)))) ((((nat.times::times) (a)) (n)) (div_mod.div m n)))) (nat.times (div_mod.div m n) n)) (((nat.commutative::times) (div_mod.div m n)) (n)))) (nat.times a (nat.times n (div_mod.div m n)))) ((((nat.times::times) (a)) (n)) (div_mod.div m n)))) (nat.times (div_mod.div m n) n)) (((nat.commutative::times) (div_mod.div m n)) (n)))) (nat.minus (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (div_mod.mod m n))) (nat.times a (nat.times (div_mod.div m n) n)))) (((((nat.plus::minus) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n))) ((nat.le::n) (nat.times a (nat.times (div_mod.div m n) n)))))) (nat.plus (nat.times a (div_mod.mod m n)) (nat.times a (nat.times (div_mod.div m n) n)))) (((nat.commutative::plus) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n))))) (nat.minus (nat.plus (nat.times a (div_mod.mod m n)) (nat.times a (nat.times (div_mod.div m n) n))) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times b n)))) ((((nat.minus::plus) (nat.plus (nat.times a (div_mod.mod m n)) (nat.times a (nat.times (div_mod.div m n) n)))) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n)))) (nat.times a (nat.plus (div_mod.mod m n) (nat.times (div_mod.div m n) n)))) ((((nat.distributive::times::plus) (a)) (div_mod.mod m n)) (nat.times (div_mod.div m n) n)))) (nat.plus (nat.times (div_mod.div m n) n) (div_mod.mod m n))) (((nat.commutative::plus) (div_mod.mod m n)) (nat.times (div_mod.div m n) n)))) (nat.times (nat.times a (div_mod.div m n)) n)) ((((nat.associative::times) (a)) (div_mod.div m n)) (n)))) (m)) (((div_mod.div::mod) (m)) (n)))) (nat.times (nat.plus (nat.times a (div_mod.div m n)) b) n)) ((((nat.distributive::times::plus::r) (n)) (nat.times a (div_mod.div m n))) (b)))) (nat.plus b (nat.times a (div_mod.div m n)))) (((nat.commutative::plus) (nat.times a (div_mod.div m n))) (b))))))) (gcd::aux q n (div_mod.mod m n))) (H)))) (\(H : logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) (gcd::aux q n (div_mod.mod m n))) -> (((((((logic.eq::ind) (nat.nat)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))) (\(x::1 : nat.nat) -> connectives.ex (nat.nat) (\(a0 : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a0 n) (nat.times b0 m)) x::1) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times a0 n)) x::1))))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times x n) (nat.times b0 m)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times x n)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))))) (nat.plus b (nat.times a (div_mod.div m n)))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n) (nat.times x m)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))) (logic.eq (nat.nat) (nat.minus (nat.times x m) (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))))) (a)) ((((connectives.or::introl) (logic.eq (nat.nat) (nat.minus (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n) (nat.times a m)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times b n) (nat.times (nat.times a (div_mod.div m n)) n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus x (nat.times a m)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times (div_mod.div m n) n) (div_mod.mod m n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.times b n) (nat.times (nat.times a (div_mod.div m n)) n)) (nat.times a x)) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (div_mod.mod m n)))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.times b n) (nat.times (nat.times a (div_mod.div m n)) n)) x) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times a (nat.times (div_mod.div m n) n))) (\(x : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.times b n) x) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (div_mod.mod m n)))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind) (nat.nat)) (nat.minus (nat.minus (nat.plus (nat.times b n) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) x::1 (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind) (nat.nat)) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times b n))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.minus x::1 (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.eq::ind) (nat.nat)) (nat.plus (nat.minus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) (nat.minus x::1 (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (div_mod.div m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus (nat.times a ::::) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n)) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (nat.times a (div_mod.div m n)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus :::: (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n)) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (div_mod.div m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus (nat.times n (nat.times a (div_mod.div m n))) (nat.times a ::::)) (nat.times b n)) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (nat.times a (div_mod.div m n)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus (nat.minus (nat.times n (nat.times a (div_mod.div m n))) ::::) (nat.times b n)) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus :::: (nat.times b n)) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.plus nat.O ::::) (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::l) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times a (div_mod.mod m n))) (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (gcd::aux q n (div_mod.mod m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd::aux q n (div_mod.mod m n)) (nat.minus :::: (nat.times a (div_mod.mod m n))))) (((((((logic.rewrite::r) (nat.nat)) (gcd::aux q n (div_mod.mod m n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd::aux q n (div_mod.mod m n)) ::::)) (((logic.refl) (nat.nat)) (gcd::aux q n (div_mod.mod m n)))) (nat.minus (nat.times n b) (nat.times a (div_mod.mod m n)))) (((((((((((((((let::clause::15441) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (::clearme)) (b)) (::clearme0)) (H)))) (nat.times b n)) (((nat.commutative::times) (b)) (n)))) (nat.minus (nat.times n b) (nat.times a (div_mod.mod m n)))) (((((((((((((((let::clause::15441) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (::clearme)) (b)) (::clearme0)) (H)))) (nat.plus nat.O (nat.times n b))) ((nat.plus::O::n) (nat.times n b)))) (nat.times b n)) (((nat.commutative::times) (b)) (n)))) (nat.minus (nat.times n (nat.times a (div_mod.div m n))) (nat.times n (nat.times a (div_mod.div m n))))) ((nat.minus::n::n) (nat.times n (nat.times a (div_mod.div m n)))))) (nat.times a (nat.times n (div_mod.div m n)))) ((((nat.times::times) (a)) (n)) (div_mod.div m n)))) (nat.times (div_mod.div m n) n)) (((nat.commutative::times) (div_mod.div m n)) (n)))) (nat.times a (nat.times n (div_mod.div m n)))) ((((nat.times::times) (a)) (n)) (div_mod.div m n)))) (nat.times (div_mod.div m n) n)) (((nat.commutative::times) (div_mod.div m n)) (n)))) (nat.minus (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times b n)) (nat.times a (nat.times (div_mod.div m n) n)))) (((((nat.plus::minus) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n)) ((nat.le::n) (nat.times a (nat.times (div_mod.div m n) n)))))) (nat.plus (nat.times b n) (nat.times a (nat.times (div_mod.div m n) n)))) (((nat.commutative::plus) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times b n)))) (nat.minus (nat.plus (nat.times b n) (nat.times a (nat.times (div_mod.div m n) n))) (nat.plus (nat.times a (nat.times (div_mod.div m n) n)) (nat.times a (div_mod.mod m n))))) ((((nat.minus::plus) (nat.plus (nat.times b n) (nat.times a (nat.times (div_mod.div m n) n)))) (nat.times a (nat.times (div_mod.div m n) n))) (nat.times a (div_mod.mod m n))))) (nat.times (nat.times a (div_mod.div m n)) n)) ((((nat.associative::times) (a)) (div_mod.div m n)) (n)))) (nat.times a (nat.plus (nat.times (div_mod.div m n) n) (div_mod.mod m n)))) ((((nat.distributive::times::plus) (a)) (nat.times (div_mod.div m n) n)) (div_mod.mod m n)))) (m)) (((div_mod.div::mod) (m)) (n)))) (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n)) ((((nat.distributive::times::plus::r) (n)) (b)) (nat.times a (div_mod.div m n)))))))) (gcd::aux q n (div_mod.mod m n))) (H)))) (::clearme0)))) (::clearme)))) ((((((Hind) (n)) (div_mod.mod m n)) (((((((connectives.match::Or::prop) (nat.lt nat.O (div_mod.mod m n))) (logic.eq (nat.nat) nat.O (div_mod.mod m n))) (nat.lt nat.O (div_mod.mod m n))) (\(auto : nat.lt nat.O (div_mod.mod m n)) -> (auto))) (\(modO : logic.eq (nat.nat) nat.O (div_mod.mod m n)) -> (((connectives.falsity) (nat.lt nat.O (div_mod.mod m n))) ((((logic.absurd) (primes.divides n m)) (((((primes.mod::O::to::divides) (n)) (m)) (posn)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: nat.O)) (((logic.refl) (nat.nat)) (nat.O))) (div_mod.mod m n)) (modO)))) (ndivnm))))) ((((nat.le::to::or::lt::eq) (nat.O)) (div_mod.mod m n)) ((nat.le::O::n) (div_mod.mod m n))))) ((((nat.lt::to::le) (div_mod.mod m n)) (n)) ((((div_mod.lt::mod::m::m) (m)) (n)) (posn)))) ((((nat.le::S::S::to::le) (div_mod.mod m n)) (q)) ((((((nat.transitive::le) (nat.S (div_mod.mod m n))) (n)) (nat.S q)) ((((div_mod.lt::mod::m::m) (m)) (n)) (posn))) (lenS)))))) (gcd::aux (nat.S q) m n)) ((((((not::divides::to::gcd::aux) (q)) (m)) (n)) (posn)) (ndivnm))))) (((primes.decidable::divides) (n)) (m)))))))) (p)

let::clause::1549 : _
let::clause::1549 = \(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(eqm0 : logic.eq (nat.nat) nat.O m) -> (\(x1106 : nat.nat) -> ((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) x1106 (nat.minus x1106 ::::))) ((nat.minus::n::O) (x1106))) (m)) (eqm0)))

let::clause::15491 : _
let::clause::15491 = \(m : nat.nat) -> \(n : nat.nat) -> \(eqn0 : logic.eq (nat.nat) nat.O n) -> (\(x1106 : nat.nat) -> ((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) x1106 (nat.minus x1106 ::::))) ((nat.minus::n::O) (x1106))) (n)) (eqn0))

let::clause::1551 : _
let::clause::1551 = \(m : nat.nat) -> \(n : nat.nat) -> \(eqn0 : logic.eq (nat.nat) nat.O n) -> (\(x347 : nat.nat) -> ((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.times x347 ::::))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.times x347 nat.O))) ((nat.times::n::O) (x347))) (n)) (eqn0))) (n)) (eqn0))

eq::minus::gcd : _
eq::minus::gcd = \(m : nat.nat) -> \(n : nat.nat) -> ((((((connectives.match::Or::prop) (nat.lt nat.O n)) (logic.eq (nat.nat) nat.O n)) (connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))) (\(posn : nat.lt nat.O n) -> (((((((connectives.match::Or::prop) (nat.lt nat.O m)) (logic.eq (nat.nat) nat.O m)) (connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))) (\(posm : nat.lt nat.O m) -> ((((((nat.leb::elim) (n)) (m)) (\(:::: : bool.bool) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) ::::)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) ::::)))))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (nat.le n m) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.true)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) y))))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (nat.le n m) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) y) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux n m n)))))) (\(lenm : nat.le n m) -> (((((((eq::minus::gcd::aux) (n)) (m)) (n)) (posn)) (lenm)) ((nat.le::n) (n))))))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (connectives.Not (nat.le n m)) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (bool.match::bool::type (nat.nat) (gcd::aux n m n) (gcd::aux m n m) bool.false)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) y))))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (gcd::aux n m n)) (gcd::aux m n m)) (\(y : nat.nat) -> (connectives.Not (nat.le n m)) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) y) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux m n m)))))) (\(nlenm : connectives.Not (nat.le n m)) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m))))) (connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd::aux m n m)))))) (\(a : nat.nat) -> \(::clearme : connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m)))) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m)))) (connectives.ex (nat.nat) (\(a0 : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a0 n) (nat.times b m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a0 n)) (gcd::aux m n m)))))) (\(b : nat.nat) -> \(::clearme0 : connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m))) -> (((((((connectives.match::Or::prop) (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m))) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m))) (connectives.ex (nat.nat) (\(a0 : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a0 n) (nat.times b0 m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times a0 n)) (gcd::aux m n m)))))) (\(H : logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m)) -> (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times x n) (nat.times b0 m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times x n)) (gcd::aux m n m))))) (b)) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times x m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times x m) (nat.times b n)) (gcd::aux m n m)))) (a)) ((((connectives.or::intror) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m))) (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m))) (((((((logic.rewrite::r) (nat.nat)) (nat.times m a)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times b n)) (gcd::aux m n m))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times m a) ::::) (gcd::aux m n m))) (((((((logic.rewrite::r) (nat.nat)) (gcd::aux m n m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (gcd::aux m n m))) (((logic.refl) (nat.nat)) (gcd::aux m n m))) (nat.minus (nat.times m a) (nat.times n b))) (((((((logic.rewrite::l) (nat.nat)) (nat.times b n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times m a) ::::) (gcd::aux m n m))) (((((((logic.rewrite::l) (nat.nat)) (nat.times a m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times b n)) (gcd::aux m n m))) (H)) (nat.times m a)) (((nat.commutative::times) (a)) (m)))) (nat.times n b)) (((nat.commutative::times) (b)) (n))))) (nat.times b n)) (((nat.commutative::times) (b)) (n)))) (nat.times a m)) (((nat.commutative::times) (a)) (m)))))))) (\(H : logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m)) -> (((((connectives.ex::intro) (nat.nat)) (\(y : nat.nat) -> connectives.ex (nat.nat) (\(b0 : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times y n) (nat.times b0 m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times b0 m) (nat.times y n)) (gcd::aux m n m))))) (b)) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times x m)) (gcd::aux m n m)) (logic.eq (nat.nat) (nat.minus (nat.times x m) (nat.times b n)) (gcd::aux m n m)))) (a)) ((((connectives.or::introl) (logic.eq (nat.nat) (nat.minus (nat.times b n) (nat.times a m)) (gcd::aux m n m))) (logic.eq (nat.nat) (nat.minus (nat.times a m) (nat.times b n)) (gcd::aux m n m))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times a m)) (gcd::aux m n m))) (((((((logic.rewrite::r) (nat.nat)) (nat.times m a)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times n b) ::::) (gcd::aux m n m))) (((((((logic.rewrite::r) (nat.nat)) (gcd::aux m n m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (gcd::aux m n m))) (((logic.refl) (nat.nat)) (gcd::aux m n m))) (nat.minus (nat.times n b) (nat.times m a))) (((((((logic.rewrite::l) (nat.nat)) (nat.times a m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times n b) ::::) (gcd::aux m n m))) (((((((logic.rewrite::l) (nat.nat)) (nat.times b n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times a m)) (gcd::aux m n m))) (H)) (nat.times n b)) (((nat.commutative::times) (b)) (n)))) (nat.times m a)) (((nat.commutative::times) (a)) (m))))) (nat.times a m)) (((nat.commutative::times) (a)) (m)))) (nat.times b n)) (((nat.commutative::times) (b)) (n)))))))) (::clearme0)))) (::clearme)))) (((((((eq::minus::gcd::aux) (m)) (n)) (m)) (posm)) ((((((nat.transitive::le) (m)) (nat.S m)) (n)) ((nat.le::n::Sn) (m))) ((((nat.not::le::to::lt) (n)) (m)) (nlenm)))) ((nat.le::n) (m)))))))))) (\(eqm0 : logic.eq (nat.nat) nat.O m) -> (((((((logic.eq::ind::r) (nat.nat)) (m)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times x n) (nat.times b m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times x n)) (gcd n m))))) (nat.S nat.O)) (((((connectives.ex::intro) (nat.nat)) (\(y : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times y m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times y m) (nat.times (nat.S nat.O) n)) (gcd n m)))) (nat.O)) ((((connectives.or::introl) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m)) (gcd n m))) (logic.eq (nat.nat) (nat.minus (nat.times nat.O m) (nat.times (nat.S nat.O) n)) (gcd n m))) (((((logic.eq::coerc) (logic.eq (nat.nat) n (nat.minus n nat.O))) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m)) (gcd n m))) ((nat.minus::n::O) (n))) (((((((logic.rewrite::r) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n (nat.minus n ::::)) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n ::::) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::r) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S ::::) n) (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times n (nat.S m))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus n (nat.times n m))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times m n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus (nat.plus n ::::) (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus (nat.plus n ::::) (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus m n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O m)) (gcd n m)))) (((((((logic.rewrite::r) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus n (nat.times :::: m)) (gcd n m)))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) (nat.minus n ::::) (gcd n m)))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) :::: (gcd n m)))) (((((((logic.rewrite::r) (nat.nat)) (gcd m n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) n ::::))) (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n n) (logic.eq (nat.nat) n ::::))) (((logic.refl) (Set)) (logic.eq (nat.nat) n n))) (gcd m n)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd :::: n) n)) ((gcd::O::l) (n))) (m)) (eqm0)))) (gcd n m)) (((commutative::gcd) (n)) (m)))) (nat.minus n m)) ((((((let::clause::1549) (m)) (n)) (posn)) (eqm0)) (n)))) (nat.times m m)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times m ::::))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.times m nat.O))) ((nat.times::n::O) (m))) (m)) (eqm0))) (m)) (eqm0)))) (nat.O)) (eqm0))) (nat.plus m n)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus :::: n))) ((nat.plus::O::n) (n))) (m)) (eqm0)))) (nat.plus n m)) (((nat.commutative::plus) (n)) (m)))) (nat.times m n)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times :::: n))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.times nat.O n))) ((nat.times::O::n) (n))) (m)) (eqm0))) (m)) (eqm0)))) (nat.times n m)) (((nat.commutative::times) (n)) (m)))) (nat.times n (nat.S m))) (((nat.times::n::Sm) (n)) (m)))) (nat.times (nat.S m) n)) (((nat.commutative::times) (nat.S m)) (n)))) (nat.O)) (eqm0))) (nat.minus n m)) ((((((let::clause::1549) (m)) (n)) (posn)) (eqm0)) (n)))) (nat.O)) (eqm0))))))) (nat.O)) (eqm0)))) ((((nat.le::to::or::lt::eq) (nat.O)) (m)) ((nat.le::O::n) (m)))))) (\(eqn0 : logic.eq (nat.nat) nat.O n) -> (((((((logic.eq::ind::r) (nat.nat)) (n)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times x n) (nat.times b m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times b m) (nat.times x n)) (gcd n m))))) (nat.O)) (((((connectives.ex::intro) (nat.nat)) (\(x : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times nat.O n) (nat.times x m)) (gcd n m)) (logic.eq (nat.nat) (nat.minus (nat.times x m) (nat.times nat.O n)) (gcd n m)))) (nat.S nat.O)) ((((connectives.or::intror) (logic.eq (nat.nat) (nat.minus (nat.times nat.O n) (nat.times (nat.S nat.O) m)) (gcd n m))) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n)) (gcd n m))) (((((logic.eq::coerc) (logic.eq (nat.nat) m (nat.minus m nat.O))) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n)) (gcd n m))) ((nat.minus::n::O) (m))) (((((((logic.rewrite::r) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m (nat.minus m nat.O)) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n)) ::::))) (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m (nat.minus m ::::)) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n)) m))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m ::::) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n)) m))) (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus (nat.times (nat.S ::::) m) (nat.times nat.O n)) m))) (((((((logic.rewrite::r) (nat.nat)) (nat.times m (nat.S n))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O n)) m))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus m (nat.times m n))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O n)) m))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus (nat.plus m ::::) (nat.times nat.O n)) m))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus :::: (nat.times nat.O n)) m))) (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus m (nat.times :::: n)) m))) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) (nat.minus m ::::) m))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) m m) (logic.eq (nat.nat) :::: m))) (((logic.refl) (Set)) (logic.eq (nat.nat) m m))) (nat.minus m n)) (((((let::clause::15491) (m)) (n)) (eqn0)) (m)))) (nat.times n n)) (((((let::clause::1551) (m)) (n)) (eqn0)) (n)))) (nat.O)) (eqn0))) (nat.plus m n)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.plus m ::::))) ((nat.plus::n::O) (m))) (n)) (eqn0)))) (nat.times m n)) (((((let::clause::1551) (m)) (n)) (eqn0)) (m)))) (nat.times m (nat.S n))) (((nat.times::n::Sm) (m)) (n)))) (nat.times (nat.S n) m)) (((nat.commutative::times) (nat.S n)) (m)))) (nat.O)) (eqn0))) (nat.minus m n)) (((((let::clause::15491) (m)) (n)) (eqn0)) (m)))) (nat.O)) (eqn0))) (gcd n m)) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (gcd :::: m) m)) ((gcd::O::l) (m))) (n)) (eqn0)))))))) (nat.O)) (eqn0)))) ((((nat.le::to::or::lt::eq) (nat.O)) (n)) ((nat.le::O::n) (n)))

let::clause::1545 : _
let::clause::1545 = \(m : nat.nat) -> \(n : nat.nat) -> \(H : logic.eq (nat.nat) (gcd m n) nat.O) -> (\(::clearme : primes.divides nat.O n) -> (\(q1 : nat.nat) -> \(H1 : logic.eq (nat.nat) n (nat.times nat.O q1)) -> (\(::clearme0 : primes.divides nat.O m) -> (\(q2 : nat.nat) -> \(H2 : logic.eq (nat.nat) m (nat.times nat.O q2)) -> (((((((logic.rewrite::r) (nat.nat)) (nat.times q2 nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times nat.O q2)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (H2)) (nat.times q2 nat.O)) (((nat.commutative::times) (nat.O)) (q2)))) (nat.O)) ((nat.times::n::O) (q2)))))))

gcd::O::to::eq::O : _
gcd::O::to::eq::O = \(m : nat.nat) -> \(n : nat.nat) -> \(H : logic.eq (nat.nat) (gcd m n) nat.O) -> ((((((connectives.match::And::prop) (primes.divides nat.O n)) (primes.divides nat.O m)) (connectives.And (logic.eq (nat.nat) m nat.O) (logic.eq (nat.nat) n nat.O))) (\(::clearme : primes.divides nat.O n) -> ((((((primes.match::divides::prop) (nat.O)) (n)) ((primes.divides nat.O m) -> connectives.And (logic.eq (nat.nat) m nat.O) (logic.eq (nat.nat) n nat.O))) (\(q1 : nat.nat) -> \(H1 : logic.eq (nat.nat) n (nat.times nat.O q1)) -> (\(::clearme0 : primes.divides nat.O m) -> ((((((primes.match::divides::prop) (nat.O)) (m)) (connectives.And (logic.eq (nat.nat) m nat.O) (logic.eq (nat.nat) n nat.O))) (\(q2 : nat.nat) -> \(H2 : logic.eq (nat.nat) m (nat.times nat.O q2)) -> (((((connectives.conj) (logic.eq (nat.nat) m nat.O)) (logic.eq (nat.nat) n nat.O)) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((logic.refl) (nat.nat)) (m))) (nat.O)) (((((((logic.rewrite::r) (nat.nat)) (nat.times q2 nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times nat.O q2)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (H2)) (nat.times q2 nat.O)) (((nat.commutative::times) (nat.O)) (q2)))) (nat.O)) ((nat.times::n::O) (q2))))) (((((((logic.rewrite::r) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: nat.O)) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((logic.refl) (nat.nat)) (m))) (nat.O)) ((((((((((let::clause::1545) (m)) (n)) (H)) (::clearme)) (q1)) (H1)) (::clearme0)) (q2)) (H2)))) (n)) (((((((logic.rewrite::r) (nat.nat)) (nat.times m q1)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.times :::: q1))) (H1)) (m)) ((((((((((let::clause::1545) (m)) (n)) (H)) (::clearme)) (q1)) (H1)) (::clearme0)) (q2)) (H2)))) (m)) (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times :::: q1))) (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.times nat.O q1))) ((nat.times::O::n) (q1))) (m)) ((((((((((let::clause::1545) (m)) (n)) (H)) (::clearme)) (q1)) (H1)) (::clearme0)) (q2)) (H2)))) (m)) ((((((((((let::clause::1545) (m)) (n)) (H)) (::clearme)) (q1)) (H1)) (::clearme0)) (q2)) (H2)))))))) (::clearme0))))) (::clearme)))) (((((((logic.eq::ind) (nat.nat)) (gcd m n)) (\(x::1 : nat.nat) -> connectives.And (primes.divides x::1 n) (primes.divides x::1 m))) (((divides::gcd::nm) (m)) (n))) (nat.O)) (H)))

let::clause::1571 : _
let::clause::1571 = \(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(H : logic.eq (nat.nat) (gcd m n) nat.O) -> (\(auto : logic.eq (nat.nat) m nat.O) -> (\(auto' : logic.eq (nat.nat) n nat.O) -> (((((((logic.rewrite::r) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (auto)) (n)) (auto')))))

let::clause::1572 : _
let::clause::1572 = \(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (\(H : logic.eq (nat.nat) (gcd m n) nat.O) -> (\(auto : logic.eq (nat.nat) m nat.O) -> (\(auto' : logic.eq (nat.nat) n nat.O) -> (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: nat.O)) (auto')) (m)) (((((((let::clause::1571) (m)) (n)) (posn)) (H)) (auto)) (auto'))))))

lt::O::gcd : _
lt::O::gcd = \(m : nat.nat) -> \(n : nat.nat) -> \(posn : nat.lt nat.O n) -> (((((nat.nat::case) (gcd m n)) (nat.lt nat.O)) (\(H : logic.eq (nat.nat) (gcd m n) nat.O) -> ((((((connectives.match::And::prop) (logic.eq (nat.nat) m nat.O)) (logic.eq (nat.nat) n nat.O)) (nat.lt nat.O nat.O)) (\(auto : logic.eq (nat.nat) m nat.O) -> (\(auto' : logic.eq (nat.nat) n nat.O) -> (((((logic.eq::coerc) (nat.lt nat.O n)) (nat.lt nat.O nat.O)) (posn)) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt :::: n) (nat.lt nat.O nat.O))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt m ::::) (nat.lt nat.O nat.O))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt m m) (nat.lt :::: nat.O))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt m m) (nat.lt m ::::))) (((logic.refl) (Set)) (nat.lt m m))) (nat.O)) (((((((let::clause::1572) (m)) (n)) (posn)) (H)) (auto)) (auto')))) (nat.O)) (((((((let::clause::1572) (m)) (n)) (posn)) (H)) (auto)) (auto')))) (n)) (((((((let::clause::1571) (m)) (n)) (posn)) (H)) (auto)) (auto')))) (nat.O)) (((((((let::clause::1572) (m)) (n)) (posn)) (H)) (auto)) (auto'))))))) ((((gcd::O::to::eq::O) (m)) (n)) (H))))) (\(m0 : nat.nat) -> \(auto : logic.eq (nat.nat) (gcd m n) (nat.S m0)) -> ((nat.lt::O::S) (m0))))

prime::to::gcd::1 : _
prime::to::gcd::1 = \(n : nat.nat) -> \(m : nat.nat) -> \(::clearme : primes.prime n) -> ((((((connectives.match::And::prop) (nat.lt (nat.S nat.O) n)) (forall (m1 : nat.nat) -> (primes.divides m1 n) -> (nat.lt (nat.S nat.O) m1) -> logic.eq (nat.nat) m1 n)) ((connectives.Not (primes.divides n m)) -> logic.eq (nat.nat) (gcd n m) (nat.S nat.O))) (\(lt1n : nat.lt (nat.S nat.O) n) -> (\(primen : forall (m0 : nat.nat) -> (primes.divides m0 n) -> (nat.lt (nat.S nat.O) m0) -> logic.eq (nat.nat) m0 n) -> (\(ndivnm : connectives.Not (primes.divides n m)) -> (((((nat.le::to::le::to::eq) (gcd n m)) (nat.S nat.O)) ((((nat.not::lt::to::le) (nat.S nat.O)) (gcd n m)) (((((logic.not::to::not) (nat.lt (nat.S nat.O) (gcd n m))) (logic.eq (nat.nat) (gcd n m) n)) (((primen) (gcd n m)) (((divides::gcd::l) (n)) (m)))) (((((logic.not::to::not) (logic.eq (nat.nat) (gcd n m) n)) (primes.divides n m)) (\(auto : logic.eq (nat.nat) (gcd n m) n) -> (((((logic.eq::coerc) (primes.divides (gcd n m) m)) (primes.divides n m)) (((divides::gcd::r) (n)) (m))) (((((((logic.rewrite::r) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (Set) (primes.divides :::: m) (primes.divides n m))) (((logic.refl) (Set)) (primes.divides n m))) (gcd n m)) (auto))))) (ndivnm))))) ((((lt::O::gcd) (n)) (m)) (((((nat.not::eq::to::le::to::lt) (nat.O)) (m)) (((((logic.not::to::not) (logic.eq (nat.nat) nat.O m)) (primes.divides n m)) (\(auto : logic.eq (nat.nat) nat.O m) -> (((((logic.eq::coerc) (primes.divides n nat.O)) (primes.divides n m)) ((primes.divides::n::O) (n))) (((((((logic.rewrite::r) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (Set) (primes.divides n ::::) (primes.divides n m))) (((logic.refl) (Set)) (primes.divides n m))) (nat.O)) (auto))))) (ndivnm))) ((nat.le::O::n) (m))))))))) (::clearme))

divides::times::to::divides : _
divides::times::to::divides = \(p : nat.nat) -> \(n : nat.nat) -> \(m : nat.nat) -> \(primp : primes.prime p) -> (\(::clearme : primes.divides p (nat.times n m)) -> ((((((primes.match::divides::prop) (p)) (nat.times n m)) (connectives.Or (primes.divides p n) (primes.divides p m))) (\(c : nat.nat) -> \(nm : logic.eq (nat.nat) (nat.times n m) (nat.times p c)) -> (((((((connectives.match::Or::prop) (primes.divides p n)) (connectives.Not (primes.divides p n))) (connectives.Or (primes.divides p n) (primes.divides p m))) (\(auto : primes.divides p n) -> ((((connectives.or::introl) (primes.divides p n)) (primes.divides p m)) (auto)))) (\(ndivpn : connectives.Not (primes.divides p n)) -> ((((connectives.or::intror) (primes.divides p n)) (primes.divides p m)) ((((((connectives.match::ex::prop) (nat.nat)) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O)) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O))))) (primes.divides p m)) (\(a : nat.nat) -> \(::clearme0 : connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O)) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O)))) -> ((((((connectives.match::ex::prop) (nat.nat)) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O)) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O)))) (primes.divides p m)) (\(b : nat.nat) -> \(::clearme1 : connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O)) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O))) -> (((((((connectives.match::Or::prop) (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O))) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O))) (primes.divides p m)) (\(H : logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O)) -> (((((primes.quotient) (p)) (m)) (nat.minus (nat.times a c) (nat.times b m))) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus (nat.times p (nat.times a c)) (nat.times p (nat.times b m)))) (\(x : nat.nat) -> logic.eq (nat.nat) m x)) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times p a) c)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus x::1 (nat.times p (nat.times b m))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times a p)) (\(x : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times x c) (nat.times p (nat.times b m))))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times a (nat.times p c))) (\(x : nat.nat) -> logic.eq (nat.nat) m (nat.minus x (nat.times p (nat.times b m))))) (((((((logic.eq::ind) (nat.nat)) (nat.times n m)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times a x::1) (nat.times p (nat.times b m))))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times a n) m)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus x::1 (nat.times p (nat.times b m))))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times p b) m)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times (nat.times a n) m) x::1))) (((((((logic.eq::ind) (nat.nat)) (nat.times m (nat.times a n))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus x::1 (nat.times (nat.times p b) m)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times m (nat.times p b))) (\(x : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times m (nat.times a n)) x))) (((((((logic.eq::ind) (nat.nat)) (nat.times m (nat.minus (nat.times a n) (nat.times p b)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m x::1)) (((((((logic.rewrite::r) (nat.nat)) (nat.times n a)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times m (nat.minus :::: (nat.times p b))))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((logic.refl) (nat.nat)) (m))) (nat.times m (nat.minus (nat.times n a) (nat.times p b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.S nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times m ::::))) ((nat.times::n::1) (m))) (nat.minus (nat.times n a) (nat.times p b))) (((((((logic.rewrite::l) (nat.nat)) (nat.times b p)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times n a) ::::) (nat.S nat.O))) (((((((logic.rewrite::l) (nat.nat)) (nat.times a n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times b p)) (nat.S nat.O))) (H)) (nat.times n a)) (((nat.commutative::times) (a)) (n)))) (nat.times p b)) (((nat.commutative::times) (b)) (p)))))) (nat.times a n)) (((nat.commutative::times) (a)) (n)))) (nat.minus (nat.times m (nat.times a n)) (nat.times m (nat.times p b)))) ((((nat.distributive::times::minus) (m)) (nat.times a n)) (nat.times p b)))) (nat.times (nat.times p b) m)) (((nat.commutative::times) (nat.times p b)) (m)))) (nat.times (nat.times a n) m)) (((nat.commutative::times) (m)) (nat.times a n)))) (nat.times p (nat.times b m))) ((((nat.associative::times) (p)) (b)) (m)))) (nat.times a (nat.times n m))) ((((nat.associative::times) (a)) (n)) (m)))) (nat.times p c)) (nm))) (nat.times (nat.times a p) c)) ((((nat.associative::times) (a)) (p)) (c)))) (nat.times p a)) (((nat.commutative::times) (p)) (a)))) (nat.times p (nat.times a c))) ((((nat.associative::times) (p)) (a)) (c)))) (nat.times p (nat.minus (nat.times a c) (nat.times b m)))) ((((nat.distributive::times::minus) (p)) (nat.times a c)) (nat.times b m)))))) (\(H : logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O)) -> (((((primes.quotient) (p)) (m)) (nat.minus (nat.times b m) (nat.times a c))) (((((((logic.eq::ind::r) (nat.nat)) (nat.minus (nat.times p (nat.times b m)) (nat.times p (nat.times a c)))) (\(x : nat.nat) -> logic.eq (nat.nat) m x)) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times p b) m)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus x::1 (nat.times p (nat.times a c))))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times p a) c)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times (nat.times p b) m) x::1))) (((((((logic.eq::ind) (nat.nat)) (nat.times a p)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times (nat.times p b) m) (nat.times x::1 c)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times a (nat.times p c))) (\(x : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times (nat.times p b) m) x))) (((((((logic.eq::ind) (nat.nat)) (nat.times n m)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times (nat.times p b) m) (nat.times a x::1)))) (((((((logic.eq::ind) (nat.nat)) (nat.times (nat.times a n) m)) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times (nat.times p b) m) x::1))) (((((((logic.eq::ind) (nat.nat)) (nat.times m (nat.times p b))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m (nat.minus x::1 (nat.times (nat.times a n) m)))) (((((((logic.eq::ind::r) (nat.nat)) (nat.times m (nat.times a n))) (\(x : nat.nat) -> logic.eq (nat.nat) m (nat.minus (nat.times m (nat.times p b)) x))) (((((((logic.eq::ind) (nat.nat)) (nat.times m (nat.minus (nat.times p b) (nat.times a n)))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) m x::1)) (((((((logic.rewrite::r) (nat.nat)) (nat.times n a)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times m (nat.minus (nat.times p b) ::::)))) (((((((logic.rewrite::l) (nat.nat)) (m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m ::::)) (((logic.refl) (nat.nat)) (m))) (nat.times m (nat.minus (nat.times p b) (nat.times n a)))) (((((((logic.rewrite::r) (nat.nat)) (nat.S nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) m (nat.times m ::::))) ((nat.times::n::1) (m))) (nat.minus (nat.times p b) (nat.times n a))) (((((((logic.rewrite::l) (nat.nat)) (nat.times a n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus (nat.times p b) ::::) (nat.S nat.O))) (((((((logic.rewrite::l) (nat.nat)) (nat.times b p)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.minus :::: (nat.times a n)) (nat.S nat.O))) (H)) (nat.times p b)) (((nat.commutative::times) (b)) (p)))) (nat.times n a)) (((nat.commutative::times) (a)) (n)))))) (nat.times a n)) (((nat.commutative::times) (a)) (n)))) (nat.minus (nat.times m (nat.times p b)) (nat.times m (nat.times a n)))) ((((nat.distributive::times::minus) (m)) (nat.times p b)) (nat.times a n)))) (nat.times (nat.times a n) m)) (((nat.commutative::times) (nat.times a n)) (m)))) (nat.times (nat.times p b) m)) (((nat.commutative::times) (m)) (nat.times p b)))) (nat.times a (nat.times n m))) ((((nat.associative::times) (a)) (n)) (m)))) (nat.times p c)) (nm))) (nat.times (nat.times a p) c)) ((((nat.associative::times) (a)) (p)) (c)))) (nat.times p a)) (((nat.commutative::times) (a)) (p)))) (nat.times p (nat.times a c))) ((((nat.associative::times) (p)) (a)) (c)))) (nat.times p (nat.times b m))) ((((nat.associative::times) (p)) (b)) (m)))) (nat.times p (nat.minus (nat.times b m) (nat.times a c)))) ((((nat.distributive::times::minus) (p)) (nat.times b m)) (nat.times a c)))))) (::clearme1)))) (::clearme0)))) (((((((logic.eq::ind) (nat.nat)) (gcd p n)) (\(x::1 : nat.nat) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) x::1) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) x::1))))) (((((((logic.eq::ind::r) (nat.nat)) (gcd n p)) (\(x : nat.nat) -> connectives.ex (nat.nat) (\(a : nat.nat) -> connectives.ex (nat.nat) (\(b : nat.nat) -> connectives.Or (logic.eq (nat.nat) (nat.minus (nat.times a n) (nat.times b p)) x) (logic.eq (nat.nat) (nat.minus (nat.times b p) (nat.times a n)) x))))) (((eq::minus::gcd) (p)) (n))) (gcd p n)) (((commutative::gcd) (p)) (n)))) (nat.S nat.O)) (((((prime::to::gcd::1) (p)) (n)) (primp)) (ndivpn))))))) (((primes.decidable::divides) (p)) (n))))) (::clearme)))

