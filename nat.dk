nat : cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I).

O :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       nat).

S :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))).

match_nat_prop :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I))
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (x O)
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.star cts.star cts.I nat (x1 => x (S x1)))
             (x1 => cts.prod cts.box cts.star cts.star cts.I nat (x2 => x x2))))).

match_nat_type :
  cts.Term
    cts.diamond
    (cts.prod
       cts.triangle
       cts.diamond
       cts.diamond
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             x
             (x0 =>
              cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
                (x1 => cts.prod cts.box cts.box cts.box cts.I nat (x2 => x)))))).

axiom_match_nat_type_O :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          x
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
             (x1 => connectives.equal x (match_nat_type x x0 x1 O) x0)))).

def eq_match_nat_type_O :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          x
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
             (x1 => leibniz.leibniz x (match_nat_type x x0 x1 O) x0))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  case_O:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               return_type)) =>
  case_S:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  connectives.equal_leibniz
    return_type
    (match_nat_type return_type case_O case_S O)
    case_O
    (axiom_match_nat_type_O return_type case_O case_S).

def sym_eq_match_nat_type_O :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          x
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
             (x1 => leibniz.leibniz x x0 (match_nat_type x x0 x1 O)))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  case_O:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               return_type)) =>
  case_S:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  leibniz.sym_leibniz
    return_type
    (match_nat_type return_type case_O case_S O)
    case_O
    (eq_match_nat_type_O return_type case_O case_S).

axiom_match_nat_type_S :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          x
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 => connectives.equal x (match_nat_type x x0 x1 (S x2)) (x1 x2)))))).

def eq_match_nat_type_S :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          x
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 => leibniz.leibniz x (match_nat_type x x0 x1 (S x2)) (x1 x2))))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  case_O:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               return_type)) =>
  case_S:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    return_type
    (match_nat_type return_type case_O case_S (S n))
    (case_S n)
    (axiom_match_nat_type_S return_type case_O case_S n).

def sym_eq_match_nat_type_S :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          x
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 => leibniz.leibniz x (x1 x2) (match_nat_type x x0 x1 (S x2)))))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  case_O:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               return_type)) =>
  case_S:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    return_type
    (match_nat_type return_type case_O case_S (S n))
    (case_S n)
    (eq_match_nat_type_S return_type case_O case_S n).

filter_nat_type :
  cts.Term
    cts.diamond
    (cts.prod
       cts.triangle
       cts.diamond
       cts.diamond
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat (x1 => x))))).

axiom_filter_nat_type_O :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
          (x0 => connectives.equal x (filter_nat_type x x0 O) (x0 O)))).

def eq_filter_nat_type_O :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
          (x0 => leibniz.leibniz x (filter_nat_type x x0 O) (x0 O))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  return:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  connectives.equal_leibniz
    return_type
    (filter_nat_type return_type return O)
    (return O)
    (axiom_filter_nat_type_O return_type return).

def sym_eq_filter_nat_type_O :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
          (x0 => leibniz.leibniz x (x0 O) (filter_nat_type x x0 O))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  return:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  leibniz.sym_leibniz
    return_type
    (filter_nat_type return_type return O)
    (return O)
    (eq_filter_nat_type_O return_type return).

axiom_filter_nat_type_S :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => connectives.equal x (filter_nat_type x x0 (S x1)) (x0 (S x1)))))).

def eq_filter_nat_type_S :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => leibniz.leibniz x (filter_nat_type x x0 (S x1)) (x0 (S x1))))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  return:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    return_type
    (filter_nat_type return_type return (S n))
    (return (S n))
    (axiom_filter_nat_type_S return_type return n).

def sym_eq_filter_nat_type_S :
  cts.Term
    cts.star
    (cts.prod
       cts.triangle
       cts.star
       cts.star
       cts.I
       (cts.univ cts.box cts.triangle cts.I)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => x))
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => leibniz.leibniz x (x0 (S x1)) (filter_nat_type x x0 (S x1))))))
  :=
  return_type:(cts.Term cts.triangle (cts.univ cts.box cts.triangle cts.I)) =>
  return:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               (cts.prod cts.box cts.box cts.box cts.I nat (x => return_type)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    return_type
    (filter_nat_type return_type return (S n))
    (return (S n))
    (eq_filter_nat_type_S return_type return n).

nat_ind :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I))
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (x O)
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x1 => cts.prod cts.star cts.star cts.star cts.I (x x1) (x2 => x (S x1))))
             (x1 => cts.prod cts.box cts.star cts.star cts.I nat (x2 => x x2))))).

def pred :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  match_nat_type
    nat
    O
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     p)
    n.

def not_zero :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  match_nat_type
    (cts.univ cts.star cts.box cts.I)
    connectives.False
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     connectives.True)
    n.

le :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I)))).

le_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => le x x)).

le_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (le x x0) (x1 => le x (S x0))))).

match_le_prop :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (x0 x)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.box cts.star cts.star cts.I nat (x2 => x0 (S x2)))
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x3 => cts.prod cts.star cts.star cts.star cts.I (le x x3) (x4 => x0 x3))))))).

le_ind :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (x0 x)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x2 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le x x2)
                      (x3 =>
                       cts.prod cts.star cts.star cts.star cts.I (x0 x2) (x4 => x0 (S x2)))))
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x3 => cts.prod cts.star cts.star cts.star cts.I (le x x3) (x4 => x0 x3))))))).

def lt :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  le (S n) m.

plus :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))).

plus_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))).

axiom_plus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (plus x)
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) plus_body x))).

def eq_plus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (plus x)
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) plus_body x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (plus n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)) plus_body n)
    (axiom_plus n).

def sym_eq_plus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) plus_body x)
          (plus x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (plus n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)) plus_body n)
    (eq_plus n).

axiom_plus_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (plus_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        m)).

def eq_plus_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (plus_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        m))
  :=
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (plus_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m)
    axiom_plus_body_O.

def sym_eq_plus_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        m)
       (plus_body O))
  :=
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (plus_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m)
    eq_plus_body_O.

axiom_plus_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (plus_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           S (plus x m)))).

def eq_plus_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (plus_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           S (plus x m))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (plus_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     S (plus n m))
    (axiom_plus_body_S n).

def sym_eq_plus_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           S (plus x m))
          (plus_body (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (plus_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     S (plus n m))
    (eq_plus_body_S n).

times :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))).

times_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))).

axiom_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (times x)
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) times_body x))).

def eq_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (times x)
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) times_body x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (times n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)) times_body n)
    (axiom_times n).

def sym_eq_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) times_body x)
          (times x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (times n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)) times_body n)
    (eq_times n).

axiom_times_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (times_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        O)).

def eq_times_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (times_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        O))
  :=
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (times_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     O)
    axiom_times_body_O.

def sym_eq_times_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        O)
       (times_body O))
  :=
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (times_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     O)
    eq_times_body_O.

axiom_times_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (times_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus m (times x m)))).

def eq_times_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (times_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus m (times x m))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (times_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     plus m (times n m))
    (axiom_times_body_S n).

def sym_eq_times_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus m (times x m))
          (times_body (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (times_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     plus m (times n m))
    (eq_times_body_S n).

minus :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))).

minus_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))).

axiom_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (minus x)
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) minus_body x))).

def eq_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (minus x)
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) minus_body x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (minus n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)) minus_body n)
    (axiom_minus n).

def sym_eq_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)) minus_body x)
          (minus x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (minus n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)) minus_body n)
    (eq_minus n).

axiom_minus_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (minus_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        O)).

def eq_minus_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (minus_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        O))
  :=
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (minus_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     O)
    axiom_minus_body_O.

def sym_eq_minus_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        O)
       (minus_body O))
  :=
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (minus_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     O)
    eq_minus_body_O.

axiom_minus_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (minus_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             nat
             (S x)
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              minus x q)
             m))).

def eq_minus_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (minus_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             nat
             (S x)
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              minus x q)
             m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (minus_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       nat
       (S n)
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        minus n q)
       m)
    (axiom_minus_body_S n).

def sym_eq_minus_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             nat
             (S x)
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              minus x q)
             m)
          (minus_body (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
    (minus_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       nat
       (S n)
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        minus n q)
       m)
    (eq_minus_body_S n).

def nat_case :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat x O) (x1 => x0 O))
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x2 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat x (S x2))
                      (x3 => x0 (S x2))))
                (x2 => x0 x)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  P:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I)))) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat _x_365 O) (x => P O))
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat _x_365 (S x0))
                (x1 => P (S x0))))
          (x0 => P _x_365)))
    (auto:(cts.Term
             cts.star
             (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat O O) (x => P O))) =>
     auto':(cts.Term
              cts.star
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat
                 (x =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (logic.eq nat O (S x))
                    (x0 => P (S x))))) =>
     auto (logic.refl nat O))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.star
                  cts.star
                  cts.star
                  cts.I
                  (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat x_366 O) (x => P O))
                  (x =>
                   cts.prod
                     cts.star
                     cts.star
                     cts.star
                     cts.I
                     (cts.prod
                        cts.box
                        cts.star
                        cts.star
                        cts.I
                        nat
                        (x0 =>
                         cts.prod
                           cts.star
                           cts.star
                           cts.star
                           cts.I
                           (logic.eq nat x_366 (S x0))
                           (x1 => P (S x0))))
                     (x0 => P x_366)))) =>
     auto:(cts.Term
             cts.star
             (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat (S x_366) O) (x => P O))) =>
     auto':(cts.Term
              cts.star
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat
                 (x =>
                  cts.prod
                    cts.star
                    cts.star
                    cts.star
                    cts.I
                    (logic.eq nat (S x_366) (S x))
                    (x0 => P (S x))))) =>
     auto' x_366 (logic.refl nat (S x_366)))
    n.

def nat_elim2 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I)))
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.star cts.star cts.I nat (x0 => x O x0))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.star cts.star cts.I nat (x1 => x (S x1) O))
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x2 =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat
                      (x3 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (x x2 x3)
                         (x4 => x (S x2) (S x3)))))
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x3 => cts.prod cts.box cts.star cts.star cts.I nat (x4 => x x3 x4)))))))
  :=
  R:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat
             (x =>
              cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))))) =>
  ROn:(cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => R O x))) =>
  RSO:(cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => R (S x) O))) =>
  RSS:(cts.Term
         cts.star
         (cts.prod
            cts.box
            cts.star
            cts.star
            cts.I
            nat
            (x =>
             cts.prod
               cts.box
               cts.star
               cts.star
               cts.I
               nat
               (x0 => cts.prod cts.star cts.star cts.star cts.I (R x x0) (x1 => R (S x) (S x0)))))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod cts.box cts.star cts.star cts.I nat (x => R _x_365 x))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     ROn m)
    (n0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     Rn0m:(cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => R n0 x))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_prop
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        R (S n0) __)
       (RSO n0)
       (auto:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
        RSS n0 auto (Rn0m auto))
       m)
    n.

def le_gen :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x1 => cts.prod cts.star cts.star cts.star cts.I (le x1 x0) (x2 => x x1)))
             (x1 => x x0))))
  :=
  P:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term
          cts.star
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x => cts.prod cts.star cts.star cts.star cts.I (le x n) (x0 => P x)))) =>
  auto n (le_n n).

def pred_Sn :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat x (pred (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  sym_eq_match_nat_type_S
    nat
    O
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     p)
    n
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     logic.eq nat n y)
    (logic.refl nat n).

def injective_S :
  cts.Term cts.star (relations.injective_ nat nat S)
  :=
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (logic.eq nat (S x) (S y))) =>
  logic.rewrite_l
    nat
    y
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat __ y)
    (logic.refl nat y)
    x
    (logic.rewrite_r
       nat
       (pred (S x))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat y __)
       (logic.rewrite_r
          nat
          (S y)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat y (pred __))
          (pred_Sn y)
          (S x)
          auto)
       x
       (pred_Sn x)).

def S_pred :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.star cts.star cts.star cts.I (lt O x) (x0 => logic.eq nat (S (pred x)) x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  posn:(cts.Term cts.star (lt O n)) =>
  match_le_prop
    (S O)
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat (S (pred __)) __)
    (logic.rewrite_l
       nat
       O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat (S __) (S O))
       (logic.refl nat (S O))
       (pred (S O))
       (pred_Sn O))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     logic.rewrite_l
       nat
       m
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat (S __) (S m))
       (logic.refl nat (S m))
       (pred (S m))
       (pred_Sn m))
    n
    posn.

def plus_O_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat x (plus O x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  sym_eq_plus
    O
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
     logic.eq nat n (y n))
    (sym_eq_filter_nat_type_O
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       plus_body
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat n (y n))
       (sym_eq_plus_body_O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat n (y n))
          (logic.refl nat n))).

def plus_n_O :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat x (plus x O)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     logic.eq nat _x_365 (plus _x_365 O))
    (sym_eq_plus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat O (y O))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat O (y O))
          (sym_eq_plus_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat O (y O))
             (logic.refl nat O))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term cts.star (logic.eq nat x_366 (plus x_366 O))) =>
     sym_eq_plus
       (S x_366)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (S x_366) (y O))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          x_366
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (S x_366) (y O))
          (sym_eq_plus_body_S
             x_366
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat (S x_366) (y O))
             (logic.rewrite_l
                nat
                x_366
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat (S x_366) (S __))
                (logic.refl nat (S x_366))
                (plus x_366 O)
                _x_368))))
    n.

def plus_n_Sm :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (S (plus x x0)) (plus x (S x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => logic.eq nat (S (plus _x_365 x)) (plus _x_365 (S x))))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (S (y m)) (plus O (S m)))
       (sym_eq_plus
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (S
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   plus_body
                   O
                   m))
             (y (S m)))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (S
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      plus_body
                      O
                      m))
                (y (S m)))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (S (y m)) (plus_body O (S m)))
                (sym_eq_plus_body_O
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (S (y m)) (plus_body O (S m)))
                   (sym_eq_plus_body_O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq nat (S m) (y (S m)))
                      (logic.refl nat (S m))))))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x => logic.eq nat (S (plus x_366 x)) (plus x_366 (S x))))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       (S x_366)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (S (y m)) (plus (S x_366) (S m)))
       (sym_eq_plus
          (S x_366)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (S
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   plus_body
                   (S x_366)
                   m))
             (y (S m)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             x_366
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (S
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      plus_body
                      (S x_366)
                      m))
                (y (S m)))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                x_366
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (S (y m)) (plus_body (S x_366) (S m)))
                (sym_eq_plus_body_S
                   x_366
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (S (y m)) (plus_body (S x_366) (S m)))
                   (sym_eq_plus_body_S
                      x_366
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq nat (S (S (plus x_366 m))) (y (S m)))
                      (logic.rewrite_r
                         nat
                         (plus x_366 (S m))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq nat (S __) (S (plus x_366 (S m))))
                         (logic.rewrite_r
                            nat
                            (plus x_366 (S (S m)))
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             logic.eq nat __ (S (plus x_366 (S m))))
                            (logic.rewrite_r
                               nat
                               (plus x_366 (S (S m)))
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                logic.eq nat (plus x_366 (S (S m))) __)
                               (logic.refl nat (plus x_366 (S (S m))))
                               (S (plus x_366 (S m)))
                               (_x_368 (S m)))
                            (S (plus x_366 (S m)))
                            (_x_368 (S m)))
                         (S (plus x_366 m))
                         (_x_368 m))))))))
    n.

def commutative_plus :
  cts.Term cts.star (relations.commutative nat plus)
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat (plus _x_365 x) (plus x _x_365)))
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       O
       (z:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (z y) (plus y O))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          (z:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (z y) (plus y O))
          (sym_eq_plus_body_O
             (z:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat (z y) (plus y O))
             (logic.rewrite_l
                nat
                y
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat y __)
                (logic.refl nat y)
                (plus y O)
                (plus_n_O y)))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x => logic.eq nat (plus x_366 x) (plus x x_366)))) =>
     y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       (S x_366)
       (z:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (z y) (plus y (S x_366)))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          x_366
          (z:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (z y) (plus y (S x_366)))
          (sym_eq_plus_body_S
             x_366
             (z:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat (z y) (plus y (S x_366)))
             (logic.rewrite_r
                nat
                (plus x_366 (S y))
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat __ (plus y (S x_366)))
                (logic.rewrite_r
                   nat
                   (plus y (S x_366))
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq nat __ (plus y (S x_366)))
                   (logic.refl nat (plus y (S x_366)))
                   (plus x_366 (S y))
                   (logic.rewrite_l
                      nat
                      (S (plus x_366 y))
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat)) =>
                       logic.eq nat __ (plus y (S x_366)))
                      (logic.rewrite_r
                         nat
                         (plus y x_366)
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq nat (S __) (plus y (S x_366)))
                         (plus_n_Sm y x_366)
                         (plus x_366 y)
                         (_x_368 y))
                      (plus x_366 (S y))
                      (plus_n_Sm x_366 y)))
                (S (plus x_366 y))
                (plus_n_Sm x_366 y)))))
    n.

def associative_plus :
  cts.Term cts.star (relations.associative nat plus)
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (plus (plus _x_365 x) x0) (plus _x_365 (plus x x0)))))
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     z:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       O
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (plus (plus O y) z) (x (plus y z)))
       (sym_eq_plus
          O
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (plus (x y) z)
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                plus_body
                O
                (plus y z)))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (plus (x y) z)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   plus_body
                   O
                   (plus y z)))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (plus (plus_body O y) z) (x (plus y z)))
                (sym_eq_plus_body_O
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (plus (plus_body O y) z) (x (plus y z)))
                   (sym_eq_plus_body_O
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq nat (plus (x y) z) (plus y z))
                      (logic.refl nat (plus y z))))))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     nat
                     (x0 => logic.eq nat (plus (plus x_366 x) x0) (plus x_366 (plus x x0)))))) =>
     y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     z:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       (S x_366)
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (plus (plus (S x_366) y) z) (x (plus y z)))
       (sym_eq_plus
          (S x_366)
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (plus (x y) z)
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                plus_body
                (S x_366)
                (plus y z)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             x_366
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (plus (x y) z)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   plus_body
                   (S x_366)
                   (plus y z)))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                x_366
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (plus (plus_body (S x_366) y) z) (x (plus y z)))
                (sym_eq_plus_body_S
                   x_366
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (plus (plus_body (S x_366) y) z) (x (plus y z)))
                   (sym_eq_plus_body_S
                      x_366
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq nat (plus (x y) z) (S (plus x_366 (plus y z))))
                      (sym_eq_plus
                         (S (plus x_366 y))
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          logic.eq nat (x z) (S (plus x_366 (plus y z))))
                         (sym_eq_filter_nat_type_S
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                            plus_body
                            (plus x_366 y)
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             logic.eq nat (x z) (S (plus x_366 (plus y z))))
                            (sym_eq_plus_body_S
                               (plus x_366 y)
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                logic.eq nat (x z) (S (plus x_366 (plus y z))))
                               (logic.rewrite_r
                                  nat
                                  (plus x_366 (plus y z))
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat)) =>
                                   logic.eq nat (S __) (S (plus x_366 (plus y z))))
                                  (logic.refl nat (S (plus x_366 (plus y z))))
                                  (plus (plus x_366 y) z)
                                  (_x_368 y z)))))))))))
    n.

def assoc_plus1 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (plus x1 (plus x0 x)) (plus (plus x0 x1) x)))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.rewrite_r
    nat
    (plus a b)
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat (plus c __) (plus (plus b c) a))
    (logic.rewrite_r
       nat
       (plus a (plus b c))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat (plus c (plus a b)) __)
       (logic.rewrite_r
          nat
          (plus a (plus b c))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat __ (plus a (plus b c)))
          (logic.refl nat (plus a (plus b c)))
          (plus c (plus a b))
          (logic.rewrite_l
             nat
             (plus (plus a b) c)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat (plus c (plus a b)) __)
             (commutative_plus c (plus a b))
             (plus a (plus b c))
             (associative_plus a b c)))
       (plus (plus b c) a)
       (commutative_plus (plus b c) a))
    (plus b a)
    (commutative_plus b a).

def injective_plus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        relations.injective_
          nat
          nat
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus x m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     relations.injective_
       nat
       nat
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        plus _x_365 m))
    (sym_eq_plus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        relations.injective_
          nat
          nat
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           y m))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           relations.injective_
             nat
             nat
             (m:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              y m))
          (sym_eq_plus_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              relations.injective_
                nat
                nat
                (m:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 y m))
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              auto:(cts.Term cts.star (logic.eq nat x y)) =>
              logic.rewrite_l
                nat
                x
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat x __)
                (logic.refl nat x)
                y
                auto))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     nat
                     (x0 =>
                      cts.prod
                        cts.star
                        cts.star
                        cts.star
                        cts.I
                        (logic.eq nat (plus x_366 x) (plus x_366 x0))
                        (x1 => logic.eq nat x x0))))) =>
     sym_eq_plus
       (S x_366)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        relations.injective_
          nat
          nat
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           y m))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          x_366
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           relations.injective_
             nat
             nat
             (m:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              y m))
          (sym_eq_plus_body_S
             x_366
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              relations.injective_
                nat
                nat
                (m:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 y m))
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              auto:(cts.Term cts.star (logic.eq nat (S (plus x_366 x)) (S (plus x_366 y)))) =>
              _x_368
                x
                y
                (injective_S
                   (plus x_366 x)
                   (plus x_366 y)
                   (logic.rewrite_r
                      nat
                      (plus x_366 (S x))
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat)) =>
                       logic.eq nat __ (S (plus x_366 y)))
                      (logic.rewrite_r
                         nat
                         (plus x_366 (S y))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq nat (plus x_366 (S x)) __)
                         (logic.rewrite_l
                            nat
                            (plus x_366 (S x))
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             logic.eq nat (plus x_366 (S x)) __)
                            (logic.refl nat (plus x_366 (S x)))
                            (plus x_366 (S y))
                            (logic.rewrite_l
                               nat
                               (S (plus x_366 y))
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                logic.eq nat (plus x_366 (S x)) __)
                               (logic.rewrite_l
                                  nat
                                  (S (plus x_366 x))
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat)) =>
                                   logic.eq nat __ (S (plus x_366 y)))
                                  auto
                                  (plus x_366 (S x))
                                  (plus_n_Sm x_366 x))
                               (plus x_366 (S y))
                               (plus_n_Sm x_366 y)))
                         (S (plus x_366 y))
                         (plus_n_Sm x_366 y))
                      (S (plus x_366 x))
                      (plus_n_Sm x_366 x)))))))
    n.

def times_Sn_m :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (plus x0 (times x x0)) (times (S x) x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  sym_eq_times
    (S n)
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
     logic.eq nat (plus m (times n m)) (y m))
    (sym_eq_filter_nat_type_S
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       times_body
       n
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (plus m (times n m)) (y m))
       (sym_eq_times_body_S
          n
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (plus m (times n m)) (y m))
          (logic.refl nat (plus m (times n m))))).

def times_O_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (times O x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  sym_eq_times
    O
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
     logic.eq nat O (y n))
    (sym_eq_filter_nat_type_O
       (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
       times_body
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat O (y n))
       (sym_eq_times_body_O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat O (y n))
          (logic.refl nat O))).

def times_n_O :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (times x O)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     logic.eq nat O (times _x_365 O))
    (logic.rewrite_l
       nat
       O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat O __)
       (logic.refl nat O)
       (times O O)
       (times_O_n O))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term cts.star (logic.eq nat O (times x_366 O))) =>
     logic.rewrite_l
       nat
       (plus O (times x_366 O))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat O __)
       (logic.rewrite_l
          nat
          O
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat O (plus O __))
          (logic.rewrite_l
             nat
             O
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat O __)
             (logic.refl nat O)
             (plus O O)
             (plus_O_n O))
          (times x_366 O)
          _x_368)
       (times (S x_366) O)
       (times_Sn_m x_366 O))
    n.

def times_n_Sm :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (plus x (times x x0)) (times x (S x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => logic.eq nat (plus _x_365 (times _x_365 x)) (times _x_365 (S x))))
    (sym_eq_times
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x => logic.eq nat (plus O (times O x)) (y (S x))))
       (sym_eq_times
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x =>
              logic.eq
                nat
                (plus O (y x))
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   times_body
                   O
                   (S x))))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             times_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x =>
                 logic.eq
                   nat
                   (plus O (y x))
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                      times_body
                      O
                      (S x))))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x => logic.eq nat (plus O (times_body O x)) (y (S x))))
                (sym_eq_times_body_O
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat
                      (x => logic.eq nat (plus O (times_body O x)) (y (S x))))
                   (sym_eq_times_body_O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat
                         (x => logic.eq nat (plus O (y x)) O))
                      (sym_eq_plus
                         O
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat
                            (x => logic.eq nat (y O) O))
                         (sym_eq_filter_nat_type_O
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                            plus_body
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat
                               (x => logic.eq nat (y O) O))
                            (sym_eq_plus_body_O
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat
                                  (x => logic.eq nat (y O) O))
                               (_m:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                logic.refl nat O))))))))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x => logic.eq nat (plus x_366 (times x_366 x)) (times x_366 (S x))))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_times
       (S x_366)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (plus (S x_366) (times (S x_366) m)) (y (S m)))
       (sym_eq_times
          (S x_366)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (plus (S x_366) (y m))
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                (S x_366)
                (S m)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             times_body
             x_366
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (plus (S x_366) (y m))
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   times_body
                   (S x_366)
                   (S m)))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                x_366
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (plus (S x_366) (times_body (S x_366) m)) (y (S m)))
                (sym_eq_times_body_S
                   x_366
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (plus (S x_366) (times_body (S x_366) m)) (y (S m)))
                   (sym_eq_times_body_S
                      x_366
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq nat (plus (S x_366) (y m)) (plus (S m) (times x_366 (S m))))
                      (sym_eq_plus
                         (S x_366)
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          logic.eq
                            nat
                            (y (plus m (times x_366 m)))
                            (plus (S m) (times x_366 (S m))))
                         (sym_eq_filter_nat_type_S
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                            plus_body
                            x_366
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             logic.eq
                               nat
                               (y (plus m (times x_366 m)))
                               (plus (S m) (times x_366 (S m))))
                            (sym_eq_plus_body_S
                               x_366
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                logic.eq
                                  nat
                                  (y (plus m (times x_366 m)))
                                  (plus (S m) (times x_366 (S m))))
                               (sym_eq_plus
                                  (S m)
                                  (y:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           (cts.prod
                                              cts.box
                                              cts.box
                                              cts.box
                                              cts.I
                                              nat
                                              (x => nat)))) =>
                                   logic.eq
                                     nat
                                     (S (plus x_366 (plus m (times x_366 m))))
                                     (y (times x_366 (S m))))
                                  (sym_eq_filter_nat_type_S
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat))
                                     plus_body
                                     m
                                     (y:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              (cts.prod
                                                 cts.box
                                                 cts.box
                                                 cts.box
                                                 cts.I
                                                 nat
                                                 (x => nat)))) =>
                                      logic.eq
                                        nat
                                        (S (plus x_366 (plus m (times x_366 m))))
                                        (y (times x_366 (S m))))
                                     (sym_eq_plus_body_S
                                        m
                                        (y:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 (cts.prod
                                                    cts.box
                                                    cts.box
                                                    cts.box
                                                    cts.I
                                                    nat
                                                    (x => nat)))) =>
                                         logic.eq
                                           nat
                                           (S (plus x_366 (plus m (times x_366 m))))
                                           (y (times x_366 (S m))))
                                        (logic.rewrite_r
                                           nat
                                           (plus x_366 (S (plus m (times x_366 m))))
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat)) =>
                                            logic.eq
                                              nat
                                              __
                                              (S (plus m (times x_366 (S m)))))
                                           (logic.rewrite_r
                                              nat
                                              (plus m (S (times x_366 m)))
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat)) =>
                                               logic.eq
                                                 nat
                                                 (plus x_366 __)
                                                 (S (plus m (times x_366 (S m)))))
                                              (logic.rewrite_l
                                                 nat
                                                 (plus x_366 (times x_366 m))
                                                 (__:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat)) =>
                                                  logic.eq
                                                    nat
                                                    (plus
                                                       x_366
                                                       (plus m (S (times x_366 m))))
                                                    (S (plus m __)))
                                                 (logic.rewrite_r
                                                    nat
                                                    (plus
                                                       x_366
                                                       (plus m (times x_366 m)))
                                                    (__:(cts.Term
                                                           cts.diamond
                                                           (cts.cast
                                                              cts.triangle
                                                              cts.sinf
                                                              (cts.univ
                                                                 cts.box
                                                                 cts.triangle
                                                                 cts.I)
                                                              (cts.univ
                                                                 cts.diamond
                                                                 cts.sinf
                                                                 cts.I)
                                                              cts.I
                                                              nat)) =>
                                                     logic.eq
                                                       nat
                                                       (plus
                                                          x_366
                                                          (plus
                                                             m
                                                             (S (times x_366 m))))
                                                       (S __))
                                                    (logic.rewrite_r
                                                       nat
                                                       (plus
                                                          x_366
                                                          (S
                                                             (plus
                                                                m
                                                                (times x_366 m))))
                                                       (__:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat)) =>
                                                        logic.eq
                                                          nat
                                                          (plus
                                                             x_366
                                                             (plus
                                                                m
                                                                (S
                                                                   (times
                                                                    x_366
                                                                    m))))
                                                          __)
                                                       (logic.rewrite_r
                                                          nat
                                                          (plus
                                                             m
                                                             (S (times x_366 m)))
                                                          (__:(cts.Term
                                                                 cts.diamond
                                                                 (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (
                                                                    cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (
                                                                    cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat)) =>
                                                           logic.eq
                                                             nat
                                                             (plus
                                                                x_366
                                                                (plus
                                                                   m
                                                                   (S
                                                                    (times
                                                                    x_366
                                                                    m))))
                                                             (plus x_366 __))
                                                          (logic.refl
                                                             nat
                                                             (plus
                                                                x_366
                                                                (plus
                                                                   m
                                                                   (S
                                                                    (times
                                                                    x_366
                                                                    m)))))
                                                          (S
                                                             (plus
                                                                m
                                                                (times x_366 m)))
                                                          (plus_n_Sm
                                                             m
                                                             (times x_366 m)))
                                                       (S
                                                          (plus
                                                             x_366
                                                             (plus
                                                                m
                                                                (times x_366 m))))
                                                       (plus_n_Sm
                                                          x_366
                                                          (plus m (times x_366 m))))
                                                    (plus
                                                       m
                                                       (plus x_366 (times x_366 m)))
                                                    (logic.rewrite_l
                                                       nat
                                                       (plus
                                                          (plus x_366 m)
                                                          (times x_366 m))
                                                       (__:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat)) =>
                                                        logic.eq
                                                          nat
                                                          (plus
                                                             m
                                                             (plus
                                                                x_366
                                                                (times x_366 m)))
                                                          __)
                                                       (assoc_plus1
                                                          (times x_366 m)
                                                          x_366
                                                          m)
                                                       (plus
                                                          x_366
                                                          (plus m (times x_366 m)))
                                                       (associative_plus
                                                          x_366
                                                          m
                                                          (times x_366 m))))
                                                 (times x_366 (S m))
                                                 (_x_368 m))
                                              (S (plus m (times x_366 m)))
                                              (plus_n_Sm m (times x_366 m)))
                                           (S (plus x_366 (plus m (times x_366 m))))
                                           (plus_n_Sm x_366 (plus m (times x_366 m))))))))))))))))
    n.

def commutative_times :
  cts.Term cts.star (relations.commutative nat times)
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => logic.eq nat (times _x_365 x) (times x _x_365)))
    (sym_eq_times
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat (y x) (times x O)))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          times_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat (y x) (times x O)))
          (sym_eq_times_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat (y x) (times x O)))
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              logic.rewrite_l
                nat
                O
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat O __)
                (logic.refl nat O)
                (times y O)
                (times_n_O y)))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x => logic.eq nat (times x_366 x) (times x x_366)))) =>
     y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_times
       (S x_366)
       (z:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (z y) (times y (S x_366)))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          times_body
          x_366
          (z:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (z y) (times y (S x_366)))
          (sym_eq_times_body_S
             x_366
             (z:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat (z y) (times y (S x_366)))
             (logic.rewrite_l
                nat
                (plus y (times y x_366))
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat (plus y (times x_366 y)) __)
                (logic.rewrite_l
                   nat
                   (times x_366 y)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq nat (plus y (times x_366 y)) (plus y __))
                   (logic.refl nat (plus y (times x_366 y)))
                   (times y x_366)
                   (_x_368 y))
                (times y (S x_366))
                (times_n_Sm y x_366)))))
    n.

def distributive_times_plus :
  cts.Term cts.star (relations.distributive nat times plus)
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (times _x_365 (plus x x0)) (plus (times _x_365 x) (times _x_365 x0)))))
    (sym_eq_times
       O
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (times O (plus x0 x1)) (plus (times O x0) (x x1)))))
       (sym_eq_times
          O
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x0 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x1 =>
                 logic.eq
                   nat
                   (times O (plus x0 x1))
                   (plus
                      (x x0)
                      (filter_nat_type
                         (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                         times_body
                         O
                         x1)))))
          (sym_eq_times
             O
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x0 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x1 =>
                    logic.eq
                      nat
                      (x (plus x0 x1))
                      (plus
                         (filter_nat_type
                            (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                            times_body
                            O
                            x0)
                         (filter_nat_type
                            (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                            times_body
                            O
                            x1)))))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x0 =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat
                      (x1 =>
                       logic.eq
                         nat
                         (x (plus x0 x1))
                         (plus
                            (filter_nat_type
                               (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                               times_body
                               O
                               x0)
                            (filter_nat_type
                               (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                               times_body
                               O
                               x1)))))
                (sym_eq_filter_nat_type_O
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   times_body
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat
                      (x0 =>
                       cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat
                         (x1 =>
                          logic.eq
                            nat
                            (times_body O (plus x0 x1))
                            (plus
                               (x x0)
                               (filter_nat_type
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                                  times_body
                                  O
                                  x1)))))
                   (sym_eq_filter_nat_type_O
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      times_body
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat
                         (x0 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat
                            (x1 =>
                             logic.eq
                               nat
                               (times_body O (plus x0 x1))
                               (plus (times_body O x0) (x x1)))))
                      (sym_eq_times_body_O
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat
                            (x0 =>
                             cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat
                               (x1 =>
                                logic.eq
                                  nat
                                  (times_body O (plus x0 x1))
                                  (plus (times_body O x0) (x x1)))))
                         (sym_eq_times_body_O
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat
                               (x0 =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat
                                  (x1 =>
                                   logic.eq nat (times_body O (plus x0 x1)) (plus (x x0) O))))
                            (sym_eq_times_body_O
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat
                                  (x0 =>
                                   cts.prod
                                     cts.box
                                     cts.star
                                     cts.star
                                     cts.I
                                     nat
                                     (x1 => logic.eq nat (x (plus x0 x1)) (plus O O))))
                               (sym_eq_plus
                                  O
                                  (x:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           (cts.prod
                                              cts.box
                                              cts.box
                                              cts.box
                                              cts.I
                                              nat
                                              (x => nat)))) =>
                                   cts.prod
                                     cts.box
                                     cts.star
                                     cts.star
                                     cts.I
                                     nat
                                     (x0 =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat
                                        (x1 => logic.eq nat O (x O))))
                                  (sym_eq_filter_nat_type_O
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat))
                                     plus_body
                                     (x:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              (cts.prod
                                                 cts.box
                                                 cts.box
                                                 cts.box
                                                 cts.I
                                                 nat
                                                 (x => nat)))) =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat
                                        (x0 =>
                                         cts.prod
                                           cts.box
                                           cts.star
                                           cts.star
                                           cts.I
                                           nat
                                           (x1 => logic.eq nat O (x O))))
                                     (sym_eq_plus_body_O
                                        (x:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 (cts.prod
                                                    cts.box
                                                    cts.box
                                                    cts.box
                                                    cts.I
                                                    nat
                                                    (x => nat)))) =>
                                         cts.prod
                                           cts.box
                                           cts.star
                                           cts.star
                                           cts.I
                                           nat
                                           (x0 =>
                                            cts.prod
                                              cts.box
                                              cts.star
                                              cts.star
                                              cts.I
                                              nat
                                              (x1 => logic.eq nat O (x O))))
                                        (_y:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         _z:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         logic.refl nat O)))))))))))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     nat
                     (x0 =>
                      logic.eq
                        nat
                        (times x_366 (plus x x0))
                        (plus (times x_366 x) (times x_366 x0)))))) =>
     y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     z:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_times
       (S x_366)
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (times (S x_366) (plus y z)) (plus (times (S x_366) y) (x z)))
       (sym_eq_times
          (S x_366)
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (times (S x_366) (plus y z))
             (plus
                (x y)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   times_body
                   (S x_366)
                   z)))
          (sym_eq_times
             (S x_366)
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (x (plus y z))
                (plus
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                      times_body
                      (S x_366)
                      y)
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                      times_body
                      (S x_366)
                      z)))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                x_366
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq
                   nat
                   (x (plus y z))
                   (plus
                      (filter_nat_type
                         (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                         times_body
                         (S x_366)
                         y)
                      (filter_nat_type
                         (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                         times_body
                         (S x_366)
                         z)))
                (sym_eq_filter_nat_type_S
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   times_body
                   x_366
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq
                      nat
                      (times_body (S x_366) (plus y z))
                      (plus
                         (x y)
                         (filter_nat_type
                            (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                            times_body
                            (S x_366)
                            z)))
                   (sym_eq_filter_nat_type_S
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      times_body
                      x_366
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq
                         nat
                         (times_body (S x_366) (plus y z))
                         (plus (times_body (S x_366) y) (x z)))
                      (sym_eq_times_body_S
                         x_366
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          logic.eq
                            nat
                            (times_body (S x_366) (plus y z))
                            (plus (times_body (S x_366) y) (x z)))
                         (sym_eq_times_body_S
                            x_366
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             logic.eq
                               nat
                               (times_body (S x_366) (plus y z))
                               (plus (x y) (plus z (times x_366 z))))
                            (sym_eq_times_body_S
                               x_366
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                logic.eq
                                  nat
                                  (x (plus y z))
                                  (plus (plus y (times x_366 y)) (plus z (times x_366 z))))
                               (logic.rewrite_r
                                  nat
                                  (plus y (plus z (times x_366 (plus y z))))
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat)) =>
                                   logic.eq
                                     nat
                                     __
                                     (plus
                                        (plus y (times x_366 y))
                                        (plus z (times x_366 z))))
                                  (logic.rewrite_r
                                     nat
                                     (plus
                                        y
                                        (plus (times x_366 y) (plus z (times x_366 z))))
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat)) =>
                                      logic.eq
                                        nat
                                        (plus y (plus z (times x_366 (plus y z))))
                                        __)
                                     (logic.rewrite_r
                                        nat
                                        (plus z (plus (times x_366 y) (times x_366 z)))
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         logic.eq
                                           nat
                                           (plus y (plus z (times x_366 (plus y z))))
                                           (plus y __))
                                        (logic.rewrite_l
                                           nat
                                           (times x_366 (plus y z))
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat)) =>
                                            logic.eq
                                              nat
                                              (plus y (plus z (times x_366 (plus y z))))
                                              (plus y (plus z __)))
                                           (logic.refl
                                              nat
                                              (plus y (plus z (times x_366 (plus y z)))))
                                           (plus (times x_366 y) (times x_366 z))
                                           (_x_368 y z))
                                        (plus (times x_366 y) (plus z (times x_366 z)))
                                        (logic.rewrite_l
                                           nat
                                           (plus
                                              (plus z (times x_366 y))
                                              (times x_366 z))
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat)) =>
                                            logic.eq
                                              nat
                                              (plus
                                                 (times x_366 y)
                                                 (plus z (times x_366 z)))
                                              __)
                                           (assoc_plus1
                                              (times x_366 z)
                                              z
                                              (times x_366 y))
                                           (plus
                                              z
                                              (plus (times x_366 y) (times x_366 z)))
                                           (associative_plus
                                              z
                                              (times x_366 y)
                                              (times x_366 z))))
                                     (plus
                                        (plus y (times x_366 y))
                                        (plus z (times x_366 z)))
                                     (associative_plus
                                        y
                                        (times x_366 y)
                                        (plus z (times x_366 z))))
                                  (plus (plus y z) (times x_366 (plus y z)))
                                  (associative_plus y z (times x_366 (plus y z)))))))))))))
    n.

def distributive_times_plus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (times (plus x0 x1) x) (plus (times x0 x) (times x1 x))))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.rewrite_r
    nat
    (times a (plus b c))
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat __ (plus (times b a) (times c a)))
    (logic.rewrite_r
       nat
       (times a b)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat (times a (plus b c)) (plus __ (times c a)))
       (logic.rewrite_r
          nat
          (times a c)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat (times a (plus b c)) (plus (times a b) __))
          (logic.rewrite_l
             nat
             (times a (plus b c))
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat (times a (plus b c)) __)
             (logic.refl nat (times a (plus b c)))
             (plus (times a b) (times a c))
             (distributive_times_plus a b c))
          (times c a)
          (commutative_times c a))
       (times b a)
       (commutative_times b a))
    (times (plus b c) a)
    (commutative_times (plus b c) a).

def associative_times :
  cts.Term cts.star (relations.associative nat times)
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (times (times _x_365 x) x0) (times _x_365 (times x x0)))))
    (sym_eq_times
       O
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (times (times O x0) x1) (x (times x0 x1)))))
       (sym_eq_times
          O
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x0 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x1 =>
                 logic.eq
                   nat
                   (times (x x0) x1)
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                      times_body
                      O
                      (times x0 x1)))))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             times_body
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x0 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x1 =>
                    logic.eq
                      nat
                      (times (x x0) x1)
                      (filter_nat_type
                         (cts.prod cts.box cts.box cts.box cts.I nat (x2 => nat))
                         times_body
                         O
                         (times x0 x1)))))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x0 =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat
                      (x1 => logic.eq nat (times (times_body O x0) x1) (x (times x0 x1)))))
                (sym_eq_times_body_O
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      nat
                      (x0 =>
                       cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat
                         (x1 => logic.eq nat (times (times_body O x0) x1) (x (times x0 x1)))))
                   (sym_eq_times_body_O
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat
                         (x0 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat
                            (x1 => logic.eq nat (times (x x0) x1) O)))
                      (sym_eq_times
                         O
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat
                            (x0 =>
                             cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat
                               (x1 => logic.eq nat (x x1) O)))
                         (sym_eq_filter_nat_type_O
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                            times_body
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat
                               (x0 =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat
                                  (x1 => logic.eq nat (x x1) O)))
                            (sym_eq_times_body_O
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat
                                  (x0 =>
                                   cts.prod
                                     cts.box
                                     cts.star
                                     cts.star
                                     cts.I
                                     nat
                                     (x1 => logic.eq nat (x x1) O)))
                               (_y:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                _z:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                logic.refl nat O))))))))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     nat
                     (x0 => logic.eq nat (times (times x_366 x) x0) (times x_366 (times x x0)))))) =>
     y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     z:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_times
       (S x_366)
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (times (times (S x_366) y) z) (x (times y z)))
       (sym_eq_times
          (S x_366)
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (times (x y) z)
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                times_body
                (S x_366)
                (times y z)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             times_body
             x_366
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (times (x y) z)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   times_body
                   (S x_366)
                   (times y z)))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                times_body
                x_366
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (times (times_body (S x_366) y) z) (x (times y z)))
                (sym_eq_times_body_S
                   x_366
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (times (times_body (S x_366) y) z) (x (times y z)))
                   (sym_eq_times_body_S
                      x_366
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq
                         nat
                         (times (x y) z)
                         (plus (times y z) (times x_366 (times y z))))
                      (logic.rewrite_r
                         nat
                         (plus (times y z) (times x_366 (times y z)))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq nat __ (plus (times y z) (times x_366 (times y z))))
                         (logic.refl nat (plus (times y z) (times x_366 (times y z))))
                         (times (plus y (times x_366 y)) z)
                         (logic.rewrite_l
                            nat
                            (times (times x_366 y) z)
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             logic.eq
                               nat
                               (times (plus y (times x_366 y)) z)
                               (plus (times y z) __))
                            (distributive_times_plus_r z y (times x_366 y))
                            (times x_366 (times y z))
                            (_x_368 y z)))))))))
    n.

def times_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (times x (times x0 x1)) (times x0 (times x x1))))))
  :=
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  z:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.rewrite_r
    nat
    (times y (times x z))
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat __ (times y (times x z)))
    (logic.refl nat (times y (times x z)))
    (times x (times y z))
    (logic.rewrite_l
       nat
       (times (times x y) z)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat __ (times y (times x z)))
       (logic.rewrite_l
          nat
          (times y x)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat (times __ z) (times y (times x z)))
          (associative_times y x z)
          (times x y)
          (commutative_times y x))
       (times x (times y z))
       (associative_times x y z)).

def times_n_1 :
  cts.Term
    cts.star
    (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat x (times x (S O))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.rewrite_l
    nat
    (plus n (times n O))
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat n __)
    (logic.rewrite_l
       nat
       O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat n (plus n __))
       (logic.rewrite_l
          nat
          n
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat n __)
          (logic.refl nat n)
          (plus n O)
          (plus_n_O n))
       (times n O)
       (times_n_O n))
    (times n (S O))
    (times_n_Sm n O).

def minus_S_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (minus (S x) (S x0)) (minus x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  eq_match_nat_type_S
    nat
    (S n)
    (q:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     minus n q)
    m
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     logic.eq nat (minus (S n) (S m)) y)
    (eq_minus_body_S
       n
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (minus (S n) (S m)) (y (S m)))
       (eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          n
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (minus (S n) (S m)) (y (S m)))
          (eq_minus
             (S n)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat (minus (S n) (S m)) (y (S m)))
             (logic.refl nat (minus (S n) (S m)))))).

def minus_O_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (minus O x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  match_nat_prop
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat O (minus O __))
    (sym_eq_minus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat O (y O))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat O (y O))
          (sym_eq_minus_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat O (y O))
             (logic.refl nat O))))
    (sym_eq_minus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (y (S x))))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (y (S x))))
          (sym_eq_minus_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (y (S x))))
             (auto:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
              logic.refl nat O))))
    n.

def minus_n_O :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat x (minus x O)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  match_nat_prop
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat __ (minus __ O))
    (logic.rewrite_l
       nat
       O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat O __)
       (logic.refl nat O)
       (minus O O)
       (minus_O_n O))
    (auto:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
     sym_eq_minus
       (S auto)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (S auto) (y O))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          auto
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq nat (S auto) (y O))
          (sym_eq_minus_body_S
             auto
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq nat (S auto) (y O))
             (sym_eq_match_nat_type_O
                nat
                (S auto)
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 minus auto q)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 logic.eq nat (S auto) y)
                (logic.refl nat (S auto))))))
    n.

def minus_n_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq nat O (minus x x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     logic.eq nat O (minus _x_365 _x_365))
    (logic.rewrite_l
       nat
       O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat O __)
       (logic.refl nat O)
       (minus O O)
       (minus_O_n O))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term cts.star (logic.eq nat O (minus x_366 x_366))) =>
     logic.rewrite_r
       nat
       (minus x_366 x_366)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat O __)
       (logic.rewrite_l
          nat
          O
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat O __)
          (logic.refl nat O)
          (minus x_366 x_366)
          _x_368)
       (minus (S x_366) (S x_366))
       (minus_S_S x_366 x_366))
    n.

def eq_minus_S_pred :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => logic.eq nat (minus x (S x0)) (pred (minus x x0)))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat (minus __ (S _0)) (pred (minus __ _0)))
    (_n:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     sym_eq_minus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (minus O (S _n)) (pred (y _n)))
       (sym_eq_minus
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (y (S _n))
             (pred
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   minus_body
                   O
                   _n)))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (y (S _n))
                (pred
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      minus_body
                      O
                      _n)))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                minus_body
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (minus_body O (S _n)) (pred (y _n)))
                (sym_eq_minus_body_O
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (minus_body O (S _n)) (pred (y _n)))
                   (sym_eq_minus_body_O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq
                         nat
                         (y (S _n))
                         (match_nat_type
                            nat
                            O
                            (p:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat)) =>
                             p)
                            O))
                      (sym_eq_match_nat_type_O
                         nat
                         O
                         (p:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat)) =>
                          p)
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat)) =>
                          logic.eq nat O y)
                         (logic.refl nat O))))))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_minus
       (S n)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        logic.eq nat (minus (S n) (S O)) (pred (y O)))
       (sym_eq_minus
          (S n)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           logic.eq
             nat
             (y (S O))
             (pred
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   minus_body
                   (S n)
                   O)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              logic.eq
                nat
                (y (S O))
                (pred
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      minus_body
                      (S n)
                      O)))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                minus_body
                n
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 logic.eq nat (minus_body (S n) (S O)) (pred (y O)))
                (sym_eq_minus_body_S
                   n
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    logic.eq nat (minus_body (S n) (S O)) (pred (y O)))
                   (sym_eq_minus_body_S
                      n
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       logic.eq
                         nat
                         (y (S O))
                         (pred
                            (match_nat_type
                               nat
                               (S n)
                               (q:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat)) =>
                                minus n q)
                               O)))
                      (sym_eq_match_nat_type_S
                         nat
                         (S n)
                         (q:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat)) =>
                          minus n q)
                         O
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat)) =>
                          logic.eq
                            nat
                            y
                            (match_nat_type
                               nat
                               O
                               (p:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat)) =>
                                p)
                               (match_nat_type
                                  nat
                                  (S n)
                                  (q:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat)) =>
                                   minus n q)
                                  O)))
                         (sym_eq_match_nat_type_O
                            nat
                            (S n)
                            (q:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat)) =>
                             minus n q)
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat)) =>
                             logic.eq
                               nat
                               (minus n O)
                               (match_nat_type
                                  nat
                                  O
                                  (p:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat)) =>
                                   p)
                                  y))
                            (sym_eq_match_nat_type_S
                               nat
                               O
                               (q:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat)) =>
                                q)
                               n
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat)) =>
                                logic.eq nat (minus n O) y)
                               (logic.rewrite_l
                                  nat
                                  n
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat)) =>
                                   logic.eq nat __ n)
                                  (logic.refl nat n)
                                  (minus n O)
                                  (minus_n_O n)))))))))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_minus
       (S n)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (logic.eq nat (minus n (S m)) (pred (minus n m)))
          (x => logic.eq nat (minus (S n) (S (S m))) (pred (y (S m)))))
       (sym_eq_minus
          (S n)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat (minus n (S m)) (pred (minus n m)))
             (x =>
              logic.eq
                nat
                (y (S (S m)))
                (pred
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                      minus_body
                      (S n)
                      (S m)))))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat (minus n (S m)) (pred (minus n m)))
                (x =>
                 logic.eq
                   nat
                   (y (S (S m)))
                   (pred
                      (filter_nat_type
                         (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                         minus_body
                         (S n)
                         (S m)))))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                minus_body
                n
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat (minus n (S m)) (pred (minus n m)))
                   (x => logic.eq nat (minus_body (S n) (S (S m))) (pred (y (S m)))))
                (sym_eq_minus_body_S
                   n
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat (minus n (S m)) (pred (minus n m)))
                      (x => logic.eq nat (minus_body (S n) (S (S m))) (pred (y (S m)))))
                   (sym_eq_minus_body_S
                      n
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat (minus n (S m)) (pred (minus n m)))
                         (x =>
                          logic.eq
                            nat
                            (y (S (S m)))
                            (pred
                               (match_nat_type
                                  nat
                                  (S n)
                                  (q:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat)) =>
                                   minus n q)
                                  (S m)))))
                      (sym_eq_match_nat_type_S
                         nat
                         (S n)
                         (q:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat)) =>
                          minus n q)
                         (S m)
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat)) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat (minus n (S m)) (pred (minus n m)))
                            (x =>
                             logic.eq
                               nat
                               y
                               (match_nat_type
                                  nat
                                  O
                                  (p:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat)) =>
                                   p)
                                  (match_nat_type
                                     nat
                                     (S n)
                                     (q:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat)) =>
                                      minus n q)
                                     (S m)))))
                         (sym_eq_match_nat_type_S
                            nat
                            (S n)
                            (q:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat)) =>
                             minus n q)
                            m
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat)) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (logic.eq nat (minus n (S m)) (pred (minus n m)))
                               (x =>
                                logic.eq
                                  nat
                                  (minus n (S m))
                                  (match_nat_type
                                     nat
                                     O
                                     (p:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat)) =>
                                      p)
                                     y)))
                            (auto:(cts.Term
                                     cts.star
                                     (logic.eq
                                        nat
                                        (minus n (S m))
                                        (match_nat_type
                                           nat
                                           O
                                           (p:(cts.Term
                                                 cts.diamond
                                                 (cts.cast
                                                    cts.triangle
                                                    cts.sinf
                                                    (cts.univ
                                                       cts.box
                                                       cts.triangle
                                                       cts.I)
                                                    (cts.univ
                                                       cts.diamond
                                                       cts.sinf
                                                       cts.I)
                                                    cts.I
                                                    nat)) =>
                                            p)
                                           (minus n m)))) =>
                             logic.rewrite_r
                               nat
                               (match_nat_type
                                  nat
                                  O
                                  (p:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat)) =>
                                   p)
                                  (minus n m))
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                logic.eq
                                  nat
                                  __
                                  (match_nat_type
                                     nat
                                     O
                                     (p:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat)) =>
                                      p)
                                     (minus n m)))
                               (logic.refl
                                  nat
                                  (match_nat_type
                                     nat
                                     O
                                     (p:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat)) =>
                                      p)
                                     (minus n m)))
                               (minus n (S m))
                               auto))))))))).

def not_eq_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (logic.eq nat x x0))
             (x1 => connectives.Not (logic.eq nat (S x) (S x0))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (connectives.Not (logic.eq nat n m))) =>
  logic.not_to_not
    (logic.eq nat (S n) (S m))
    (logic.eq nat n m)
    (auto':(cts.Term cts.star (logic.eq nat (S n) (S m))) =>
     logic.rewrite_l
       nat
       m
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat __ m)
       (logic.refl nat m)
       n
       (logic.rewrite_r
          nat
          (pred (S n))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat m __)
          (logic.rewrite_r
             nat
             (S m)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat m (pred __))
             (pred_Sn m)
             (S n)
             auto')
          n
          (pred_Sn n)))
    auto.

def not_eq_O_S :
  cts.Term
    cts.star
    (cts.prod cts.box cts.star cts.star cts.I nat (x => connectives.Not (logic.eq nat O (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.nmk
    (logic.eq nat O (S n))
    (eqOS:(cts.Term cts.star (logic.eq nat O (S n))) =>
     eq_match_nat_type_O
       (cts.univ cts.star cts.box cts.I)
       connectives.False
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        connectives.True)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.univ cts.star cts.box cts.I))) =>
        y)
       (logic.eq_ind_r
          nat
          (S n)
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           not_zero x)
          (sym_eq_match_nat_type_S
             (cts.univ cts.star cts.box cts.I)
             connectives.False
             (p:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              connectives.True)
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.univ cts.star cts.box cts.I))) =>
              y)
             connectives.I)
          O
          eqOS)).

def lt_to_not_zero :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (lt x x0) (x1 => not_zero x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  Hlt:(cts.Term cts.star (lt n m)) =>
  le_ind
    (S n)
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     not_zero x_417)
    (sym_eq_match_nat_type_S
       (cts.univ cts.star cts.box cts.I)
       connectives.False
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        connectives.True)
       n
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.univ cts.star cts.box cts.I))) =>
        y)
       connectives.I)
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le (S n) m0)) =>
     _x_421:(cts.Term cts.star (not_zero m0)) =>
     sym_eq_match_nat_type_S
       (cts.univ cts.star cts.box cts.I)
       connectives.False
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        connectives.True)
       m0
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.univ cts.star cts.box cts.I))) =>
        y)
       connectives.I)
    m
    Hlt.

def le_S_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (le x x0) (x1 => le (S x) (S x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lenm:(cts.Term cts.star (le n m)) =>
  le_ind
    n
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     le (S n) (S x_417))
    (le_n (S n))
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le n m0)) =>
     _x_421:(cts.Term cts.star (le (S n) (S m0))) => le_S (S n) (S m0) _x_421)
    m
    lenm.

def le_O_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => le O x))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (le O)
    (le_n O)
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term cts.star (le O x_366)) => le_S O x_366 _x_368)
    n.

def le_n_Sn :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => le x (S x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  le_S n n (le_n n).

def transitive_le :
  cts.Term cts.star (relations.transitive nat le)
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leab:(cts.Term cts.star (le a b)) =>
  lebc:(cts.Term cts.star (le b c)) =>
  le_ind
    b
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     le a x_417)
    leab
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     _x_419:(cts.Term cts.star (le b m)) => _x_421:(cts.Term cts.star (le a m)) => le_S a m _x_421)
    c
    lebc.

def le_pred_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => le (pred x) x))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     le (pred _x_365) _x_365)
    (eq_match_nat_type_O
       nat
       O
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        p)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        le
          (match_nat_type
             nat
             O
             (p:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              p)
             O)
          y)
       (le_n (pred O)))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term cts.star (le (pred x_366) x_366)) =>
     eq_match_nat_type_S
       nat
       O
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        p)
       x_366
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        le (pred (S x_366)) (S y))
       (le_n_Sn (pred (S x_366))))
    n.

def monotonic_pred :
  cts.Term cts.star (relations.monotonic nat le pred)
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lenm:(cts.Term cts.star (le n m)) =>
  le_ind
    n
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     le (pred n) (pred x_417))
    (le_n (pred n))
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le n m0)) =>
     _x_421:(cts.Term cts.star (le (pred n) (pred m0))) =>
     transitive_le
       (pred n)
       n
       (pred (S m0))
       (le_pred_n n)
       (sym_eq_match_nat_type_S
          nat
          O
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           p)
          m0
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           le n y)
          _x_419))
    m
    lenm.

def le_S_S_to_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (le (S x) (S x0)) (x1 => le x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (le (S n) (S m))) =>
  eq_match_nat_type_S
    nat
    O
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     p)
    m
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     le n y)
    (eq_match_nat_type_S
       nat
       O
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        p)
       n
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        le
          y
          (match_nat_type
             nat
             O
             (p:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              p)
             (S m)))
       (monotonic_pred (S n) (S m) auto)).

def monotonic_le_plus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        relations.monotonic
          nat
          le
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus x m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod cts.star cts.star cts.star cts.I (le a b) (x => le (plus _x_365 a) (plus _x_365 b)))
    (sym_eq_plus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.star cts.star cts.star cts.I (le a b) (x => le (plus O a) (y b)))
       (sym_eq_plus
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le a b)
             (x =>
              le
                (y a)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   plus_body
                   O
                   b)))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le a b)
                (x =>
                 le
                   (y a)
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                      plus_body
                      O
                      b)))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le a b)
                   (x => le (plus_body O a) (y b)))
                (sym_eq_plus_body_O
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le a b)
                      (x => le (plus_body O a) (y b)))
                   (sym_eq_plus_body_O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod cts.star cts.star cts.star cts.I (le a b) (x => le (y a) b))
                      (auto:(cts.Term cts.star (le a b)) => auto)))))))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     H:(cts.Term
          cts.star
          (cts.prod cts.star cts.star cts.star cts.I (le a b) (x => le (plus m a) (plus m b)))) =>
     leab:(cts.Term cts.star (le a b)) =>
     sym_eq_plus
       (S m)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        le (plus (S m) a) (y b))
       (sym_eq_plus
          (S m)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           le
             (y a)
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                (S m)
                b))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             m
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              le
                (y a)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   plus_body
                   (S m)
                   b))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                m
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 le (plus_body (S m) a) (y b))
                (sym_eq_plus_body_S
                   m
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    le (plus_body (S m) a) (y b))
                   (sym_eq_plus_body_S
                      m
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       le (y a) (S (plus m b)))
                      (le_S_S (plus m a) (plus m b) (H leab))))))))
    n.

def monotonic_le_plus_l :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        relations.monotonic
          nat
          le
          (n:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus n x)))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (le x y)) =>
  logic.eq_coerc
    (le (plus m x) (plus m y))
    (le (plus x m) (plus y m))
    (monotonic_le_plus_r m x y auto)
    (logic.rewrite_r
       nat
       (plus m x)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le (plus m x) (plus m y)) (le __ (plus y m)))
       (logic.rewrite_r
          nat
          (plus m y)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le (plus m x) (plus m y)) (le (plus m x) __))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (plus m x) (plus m y)))
          (plus y m)
          (commutative_plus y m))
       (plus x m)
       (commutative_plus x m)).

def le_plus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le x x0)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le x1 x2)
                      (x4 => le (plus x x1) (plus x0 x2))))))))
  :=
  n1:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  n2:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  m1:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  m2:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  len:(cts.Term cts.star (le n1 n2)) =>
  lem:(cts.Term cts.star (le m1 m2)) =>
  transitive_le
    (plus n1 m1)
    (plus n1 m2)
    (plus n2 m2)
    (monotonic_le_plus_r n1 m1 m2 lem)
    (monotonic_le_plus_l m2 n1 n2 len).

def le_plus_n :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat (x0 => le x0 (plus x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.eq_coerc
    (le (plus O m) (plus n m))
    (le m (plus n m))
    (monotonic_le_plus_l m O n (le_O_n n))
    (logic.rewrite_l
       nat
       m
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le __ (plus n m)) (le m (plus n m)))
       (logic.refl (cts.univ cts.star cts.box cts.I) (le m (plus n m)))
       (plus O m)
       (plus_O_n m)).

def le_plus_b :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => cts.prod cts.star cts.star cts.star cts.I (le (plus x0 x) x1) (x2 => le x0 x1)))))
  :=
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (le (plus n b) m)) =>
  transitive_le
    n
    (plus n b)
    m
    (logic.eq_coerc
       (le n (plus b n))
       (le n (plus n b))
       (le_plus_n b n)
       (logic.rewrite_r
          nat
          (plus b n)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le n (plus b n)) (le n __))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le n (plus b n)))
          (plus n b)
          (commutative_plus n b)))
    auto.

def le_plus_n_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat (x0 => le x0 (plus x0 x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.eq_coerc
    (le m (plus n m))
    (le m (plus m n))
    (le_plus_n n m)
    (logic.rewrite_r
       nat
       (plus n m)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le m (plus n m)) (le m __))
       (logic.refl (cts.univ cts.star cts.box cts.I) (le m (plus n m)))
       (plus m n)
       (commutative_plus m n)).

def le_plus_to_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le (plus x x0) (plus x x1))
                (x2 => le x0 x1)))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le (plus _x_365 x) (plus _x_365 x0))
             (x1 => le x x0))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.star cts.star cts.star cts.I (le (plus O n) (y m)) (x => le n m))
       (sym_eq_plus
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le
                (y n)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   plus_body
                   O
                   m))
             (x => le n m))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le
                   (y n)
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      plus_body
                      O
                      m))
                (x => le n m))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le (plus_body O n) (y m))
                   (x => le n m))
                (sym_eq_plus_body_O
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (plus_body O n) (y m))
                      (x => le n m))
                   (sym_eq_plus_body_O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod cts.star cts.star cts.star cts.I (le (y n) m) (x => le n m))
                      (auto:(cts.Term cts.star (le n m)) => auto)))))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat
                  (x =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     nat
                     (x0 =>
                      cts.prod
                        cts.star
                        cts.star
                        cts.star
                        cts.I
                        (le (plus x_366 x) (plus x_366 x0))
                        (x1 => le x x0))))) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_plus
       (S x_366)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.star cts.star cts.star cts.I (le (plus (S x_366) n) (y m)) (x => le n m))
       (sym_eq_plus
          (S x_366)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le
                (y n)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   plus_body
                   (S x_366)
                   m))
             (x => le n m))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             plus_body
             x_366
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le
                   (y n)
                   (filter_nat_type
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                      plus_body
                      (S x_366)
                      m))
                (x => le n m))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                plus_body
                x_366
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le (plus_body (S x_366) n) (y m))
                   (x => le n m))
                (sym_eq_plus_body_S
                   x_366
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (plus_body (S x_366) n) (y m))
                      (x => le n m))
                   (sym_eq_plus_body_S
                      x_366
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le (y n) (S (plus x_366 m)))
                         (x => le n m))
                      (auto:(cts.Term cts.star (le (S (plus x_366 n)) (S (plus x_366 m)))) =>
                       logic.eq_coerc
                         (le (pred (S n)) (pred (S m)))
                         (le n m)
                         (monotonic_pred
                            (S n)
                            (S m)
                            (_x_368
                               (S n)
                               (S m)
                               (logic.eq_coerc
                                  (le (S (plus x_366 n)) (S (plus x_366 m)))
                                  (le (plus x_366 (S n)) (plus x_366 (S m)))
                                  auto
                                  (logic.rewrite_r
                                     nat
                                     (plus x_366 (S n))
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat)) =>
                                      logic.eq
                                        (cts.univ cts.star cts.box cts.I)
                                        (le __ (S (plus x_366 m)))
                                        (le (plus x_366 (S n)) (plus x_366 (S m))))
                                     (logic.rewrite_r
                                        nat
                                        (plus x_366 (S m))
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         logic.eq
                                           (cts.univ cts.star cts.box cts.I)
                                           (le (plus x_366 (S n)) __)
                                           (le (plus x_366 (S n)) (plus x_366 (S m))))
                                        (logic.refl
                                           (cts.univ cts.star cts.box cts.I)
                                           (le (plus x_366 (S n)) (plus x_366 (S m))))
                                        (S (plus x_366 m))
                                        (plus_n_Sm x_366 m))
                                     (S (plus x_366 n))
                                     (plus_n_Sm x_366 n)))))
                         (logic.rewrite_l
                            nat
                            n
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             logic.eq
                               (cts.univ cts.star cts.box cts.I)
                               (le __ (pred (S m)))
                               (le n m))
                            (logic.rewrite_l
                               nat
                               m
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                logic.eq
                                  (cts.univ cts.star cts.box cts.I)
                                  (le n __)
                                  (le n m))
                               (logic.refl (cts.univ cts.star cts.box cts.I) (le n m))
                               (pred (S m))
                               (pred_Sn m))
                            (pred (S n))
                            (pred_Sn n)))))))))
    a.

def le_plus_to_le_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le (plus x0 x) (plus x1 x))
                (x2 => le x0 x1)))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (le (plus n a) (plus m a))) =>
  le_plus_to_le
    a
    n
    m
    (logic.eq_coerc
       (le (plus n a) (plus m a))
       (le (plus a n) (plus a m))
       auto
       (logic.rewrite_r
          nat
          (plus a n)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le __ (plus m a)) (le (plus a n) (plus a m)))
          (logic.rewrite_r
             nat
             (plus a m)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (le (plus a n) __)
                (le (plus a n) (plus a m)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (plus a n) (plus a m)))
             (plus m a)
             (commutative_plus m a))
          (plus n a)
          (commutative_plus n a))).

def monotonic_le_times_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        relations.monotonic
          nat
          le
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           times x m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lexy:(cts.Term cts.star (le x y)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     le (times _x_365 x) (times _x_365 y))
    (sym_eq_times
       O
       (z:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
        le (times O x) (z y))
       (sym_eq_times
          O
          (z:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
           le
             (z x)
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                times_body
                O
                y))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
             times_body
             (z:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
              le
                (z x)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   times_body
                   O
                   y))
             (sym_eq_filter_nat_type_O
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                times_body
                (z:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
                 le (times_body O x) (z y))
                (sym_eq_times_body_O
                   (z:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
                    le (times_body O x) (z y))
                   (sym_eq_times_body_O
                      (z:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
                       le (z x) O)
                      (le_O_n O)))))))
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     lea:(cts.Term cts.star (le (times a x) (times a y))) =>
     sym_eq_times
       (S a)
       (z:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
        le (times (S a) x) (z y))
       (sym_eq_times
          (S a)
          (z:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
           le
             (z x)
             (filter_nat_type
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                times_body
                (S a)
                y))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
             times_body
             a
             (z:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
              le
                (z x)
                (filter_nat_type
                   (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                   times_body
                   (S a)
                   y))
             (sym_eq_filter_nat_type_S
                (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                times_body
                a
                (z:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
                 le (times_body (S a) x) (z y))
                (sym_eq_times_body_S
                   a
                   (z:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
                    le (times_body (S a) x) (z y))
                   (sym_eq_times_body_S
                      a
                      (z:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat)))) =>
                       le (z x) (plus y (times a y)))
                      (le_plus x y (times a x) (times a y) lexy lea)))))))
    n.

def le_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le x x0)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le x1 x2)
                      (x4 => le (times x x1) (times x0 x2))))))))
  :=
  n1:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  n2:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  m1:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  m2:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat)) =>
  len:(cts.Term cts.star (le n1 n2)) =>
  lem:(cts.Term cts.star (le m1 m2)) =>
  transitive_le
    (times n1 m1)
    (times n1 m2)
    (times n2 m2)
    (monotonic_le_times_r n1 m1 m2 lem)
    (logic.eq_coerc
       (le (times m2 n1) (times m2 n2))
       (le (times n1 m2) (times n2 m2))
       (monotonic_le_times_r m2 n1 n2 len)
       (logic.rewrite_r
          nat
          (times n1 m2)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le __ (times m2 n2))
             (le (times n1 m2) (times n2 m2)))
          (logic.rewrite_r
             nat
             (times n2 m2)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (le (times n1 m2) __)
                (le (times n1 m2) (times n2 m2)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (times n1 m2) (times n2 m2)))
             (times m2 n2)
             (commutative_times m2 n2))
          (times m2 n1)
          (commutative_times m2 n1))).

def le_plus_minus_m_m :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat (x0 => le x (plus (minus x x0) x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod cts.box cts.star cts.star cts.I nat (x => le _x_365 (plus (minus _x_365 x) x)))
    (sym_eq_minus
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.box cts.star cts.star cts.I nat (x => le O (plus (y x) x)))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod cts.box cts.star cts.star cts.I nat (x => le O (plus (y x) x)))
          (sym_eq_minus_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod cts.box cts.star cts.star cts.I nat (x => le O (plus (y x) x)))
             (m:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              le_plus_n_r m O))))
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     Hind:(cts.Term
             cts.star
             (cts.prod cts.box cts.star cts.star cts.I nat (x => le a (plus (minus a x) x)))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_prop
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        le (S a) (plus (minus (S a) __) __))
       (sym_eq_minus
          (S a)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           le (S a) (plus (y O) O))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             a
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              le (S a) (plus (y O) O))
             (sym_eq_minus_body_S
                a
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 le (S a) (plus (y O) O))
                (sym_eq_match_nat_type_O
                   nat
                   (S a)
                   (q:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    minus a q)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    le (S a) (plus y O))
                   (le_plus_n_r O (S a))))))
       (n0:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        sym_eq_minus
          (S a)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           le (S a) (plus (y (S n0)) (S n0)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             a
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              le (S a) (plus (y (S n0)) (S n0)))
             (sym_eq_minus_body_S
                a
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 le (S a) (plus (y (S n0)) (S n0)))
                (sym_eq_match_nat_type_S
                   nat
                   (S a)
                   (q:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    minus a q)
                   n0
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    le (S a) (plus y (S n0)))
                   (logic.eq_coerc
                      (le (S a) (S (plus (minus a n0) n0)))
                      (le (S a) (plus (minus a n0) (S n0)))
                      (le_S_S a (plus (minus a n0) n0) (Hind n0))
                      (logic.rewrite_r
                         nat
                         (plus (minus a n0) (S n0))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq
                            (cts.univ cts.star cts.box cts.I)
                            (le (S a) __)
                            (le (S a) (plus (minus a n0) (S n0))))
                         (logic.refl
                            (cts.univ cts.star cts.box cts.I)
                            (le (S a) (plus (minus a n0) (S n0))))
                         (S (plus (minus a n0) n0))
                         (plus_n_Sm (minus a n0) n0)))))))
       m)
    n.

def le_plus_to_minus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le (plus x x0) x1)
                (x2 => le x (minus x1 x0))))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (le (plus a b) c)) =>
  le_plus_to_le_r
    b
    a
    (minus c b)
    (transitive_le (plus a b) c (plus (minus c b) b) H (le_plus_minus_m_m c b)).

def lt_to_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (lt x x0) (x1 => le x x0))))
  :=
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (lt x y)) =>
  le_plus_b
    (S O)
    x
    y
    (logic.eq_coerc
       (le (S x) y)
       (le (plus x (S O)) y)
       auto
       (logic.rewrite_r
          nat
          (plus x (S O))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le __ y) (le (plus x (S O)) y))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (plus x (S O)) y))
          (S x)
          (logic.rewrite_r
             nat
             (plus x O)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat (S __) (plus x (S O)))
             (plus_n_Sm x O)
             x
             (plus_n_O x)))).

def transitive_lt :
  cts.Term cts.star (relations.transitive nat lt)
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  ltab:(cts.Term cts.star (lt a b)) =>
  ltbc:(cts.Term cts.star (lt b c)) =>
  le_ind
    (S b)
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     lt a x_417)
    (le_S (S a) b ltab)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     _x_419:(cts.Term cts.star (le (S b) m)) =>
     _x_421:(cts.Term cts.star (lt a m)) => le_S (S a) m _x_421)
    c
    ltbc.

def lt_to_le_to_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (lt x x0)
                (x2 => cts.prod cts.star cts.star cts.star cts.I (le x0 x1) (x3 => lt x x1))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (lt n m)) =>
  H1:(cts.Term cts.star (le m p)) =>
  le_ind
    m
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     lt n x_417)
    H
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le m m0)) =>
     _x_421:(cts.Term cts.star (lt n m0)) =>
     transitive_lt
       n
       m0
       (S m0)
       _x_421
       (logic.eq_coerc
          (le (S m0) (plus O (S m0)))
          (le (S m0) (S m0))
          (le_plus_n O (S m0))
          (logic.rewrite_l
             nat
             (S m0)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq (cts.univ cts.star cts.box cts.I) (le (S m0) __) (le (S m0) (S m0)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (S m0) (S m0)))
             (plus O (S m0))
             (plus_O_n (S m0)))))
    p
    H1.

def le_to_lt_to_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x x0)
                (x2 => cts.prod cts.star cts.star cts.star cts.I (lt x0 x1) (x3 => lt x x1))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (le n m)) =>
  le_ind
    n
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     cts.prod cts.star cts.star cts.star cts.I (lt x_417 p) (x => lt n p))
    (auto:(cts.Term cts.star (lt n p)) => auto)
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le n m0)) =>
     _x_421:(cts.Term cts.star (cts.prod cts.star cts.star cts.star cts.I (lt m0 p) (x => lt n p))) =>
     auto:(cts.Term cts.star (lt (S m0) p)) =>
     _x_421
       (transitive_lt
          m0
          (S m0)
          p
          (logic.eq_coerc
             (le (S m0) (plus O (S m0)))
             (le (S m0) (S m0))
             (le_plus_n O (S m0))
             (logic.rewrite_l
                nat
                (S m0)
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (le (S m0) __) (le (S m0) (S m0)))
                (logic.refl (cts.univ cts.star cts.box cts.I) (le (S m0) (S m0)))
                (plus O (S m0))
                (plus_O_n (S m0))))
          auto))
    m
    H.

def lt_S_to_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (lt (S x) x0) (x1 => lt x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (lt (S n) m)) =>
  transitive_lt
    n
    (S n)
    m
    (logic.eq_coerc
       (le (S n) (plus O (S n)))
       (le (S n) (S n))
       (le_plus_n O (S n))
       (logic.rewrite_l
          nat
          (S n)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le (S n) __) (le (S n) (S n)))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (S n) (S n)))
          (plus O (S n))
          (plus_O_n (S n))))
    auto.

def ltn_to_ltO :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (lt x x0) (x1 => lt O x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (lt n m)) =>
  lt_to_le_to_lt
    O
    (S n)
    m
    (logic.eq_coerc
       (le (S O) (plus n (S O)))
       (le (S O) (S n))
       (le_plus_n n (S O))
       (logic.rewrite_l
          nat
          (S n)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le (S O) __) (le (S O) (S n)))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (S O) (S n)))
          (plus n (S O))
          (logic.rewrite_r
             nat
             (plus n O)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat (S __) (plus n (S O)))
             (plus_n_Sm n O)
             n
             (plus_n_O n))))
    auto.

def lt_O_S :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => lt O (S x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  ltn_to_ltO
    n
    (S n)
    (logic.eq_coerc
       (le (S n) (plus O (S n)))
       (le (S n) (S n))
       (le_plus_n O (S n))
       (logic.rewrite_l
          nat
          (S n)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le (S n) __) (le (S n) (S n)))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (S n) (S n)))
          (plus O (S n))
          (plus_O_n (S n)))).

def monotonic_lt_plus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        relations.monotonic
          nat
          lt
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus x m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (lt x y)) =>
  logic.eq_coerc
    (le (plus n (S x)) (plus n y))
    (le (S (plus n x)) (plus n y))
    (monotonic_le_plus_r n (S x) y auto)
    (logic.rewrite_r
       nat
       (plus n (S x))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le (plus n (S x)) (plus n y)) (le __ (plus n y)))
       (logic.refl (cts.univ cts.star cts.box cts.I) (le (plus n (S x)) (plus n y)))
       (S (plus n x))
       (plus_n_Sm n x)).

def monotonic_lt_plus_l :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        relations.monotonic
          nat
          lt
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           plus m x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (lt x y)) =>
  logic.eq_coerc
    (le (plus n (S x)) (plus n y))
    (le (S (plus x n)) (plus y n))
    (monotonic_le_plus_r n (S x) y auto)
    (logic.rewrite_r
       nat
       (plus n x)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq
          (cts.univ cts.star cts.box cts.I)
          (le (plus n (S x)) (plus n y))
          (le (S __) (plus y n)))
       (logic.rewrite_r
          nat
          (plus n (S x))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le (plus n (S x)) (plus n y))
             (le __ (plus y n)))
          (logic.rewrite_r
             nat
             (plus n y)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (le (plus n (S x)) (plus n y))
                (le (plus n (S x)) __))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (plus n (S x)) (plus n y)))
             (plus y n)
             (commutative_plus y n))
          (S (plus n x))
          (plus_n_Sm n x))
       (plus x n)
       (commutative_plus x n)).

def monotonic_lt_times_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (lt O x)
          (x0 =>
           relations.monotonic
             nat
             lt
             (t:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              times x t))))
  :=
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  posc:(cts.Term cts.star (lt O c)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  ltnm:(cts.Term cts.star (lt n m)) =>
  le_ind
    (S n)
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     lt (times c n) (times c x_417))
    (logic.eq_coerc
       (le (S (plus O (times c n))) (plus c (times c n)))
       (le (S (times c n)) (times c (S n)))
       (monotonic_lt_plus_l (times c n) O c posc)
       (logic.rewrite_r
          nat
          (plus O (S (times c n)))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le __ (plus c (times c n)))
             (le (S (times c n)) (times c (S n))))
          (logic.rewrite_l
             nat
             (plus c (times c n))
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (le (plus O (S (times c n))) (plus c (times c n)))
                (le (S (times c n)) __))
             (logic.rewrite_l
                nat
                (S (times c n))
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq
                   (cts.univ cts.star cts.box cts.I)
                   (le __ (plus c (times c n)))
                   (le (S (times c n)) (plus c (times c n))))
                (logic.refl
                   (cts.univ cts.star cts.box cts.I)
                   (le (S (times c n)) (plus c (times c n))))
                (plus O (S (times c n)))
                (plus_O_n (S (times c n))))
             (times c (S n))
             (times_n_Sm c n))
          (S (plus O (times c n)))
          (plus_n_Sm O (times c n))))
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     __:(cts.Term cts.star (le (S n) a)) =>
     lt1:(cts.Term cts.star (le (S (times c n)) (times c a))) =>
     transitive_le
       (S (times c n))
       (times c a)
       (times c (S a))
       lt1
       (logic.eq_coerc
          (le (times c a) (plus (times c a) c))
          (le (times c a) (times c (S a)))
          (le_plus_n_r c (times c a))
          (logic.rewrite_l
             nat
             (plus c (times c a))
             (__1:(cts.Term
                     cts.diamond
                     (cts.cast
                        cts.triangle
                        cts.sinf
                        (cts.univ cts.box cts.triangle cts.I)
                        (cts.univ cts.diamond cts.sinf cts.I)
                        cts.I
                        nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (le (times c a) (plus (times c a) c))
                (le (times c a) __1))
             (logic.rewrite_r
                nat
                (plus c (times c a))
                (__1:(cts.Term
                        cts.diamond
                        (cts.cast
                           cts.triangle
                           cts.sinf
                           (cts.univ cts.box cts.triangle cts.I)
                           (cts.univ cts.diamond cts.sinf cts.I)
                           cts.I
                           nat)) =>
                 logic.eq
                   (cts.univ cts.star cts.box cts.I)
                   (le (times c a) __1)
                   (le (times c a) (plus c (times c a))))
                (logic.refl
                   (cts.univ cts.star cts.box cts.I)
                   (le (times c a) (plus c (times c a))))
                (plus (times c a) c)
                (commutative_plus (times c a) c))
             (times c (S a))
             (times_n_Sm c a))))
    m
    ltnm.

def monotonic_lt_times_l :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (lt O x)
          (x0 =>
           relations.monotonic
             nat
             lt
             (t:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              times t x))))
  :=
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (lt O c)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto':(cts.Term cts.star (lt x y)) =>
  logic.eq_coerc
    (le (S (times c x)) (times c y))
    (le (S (times x c)) (times y c))
    (monotonic_lt_times_r c auto x y auto')
    (logic.rewrite_r
       nat
       (times c x)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq
          (cts.univ cts.star cts.box cts.I)
          (le (S (times c x)) (times c y))
          (le (S __) (times y c)))
       (logic.rewrite_r
          nat
          (times c y)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le (S (times c x)) (times c y))
             (le (S (times c x)) __))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (S (times c x)) (times c y)))
          (times y c)
          (commutative_times y c))
       (times x c)
       (commutative_times x c)).

def lt_to_le_to_lt_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (lt x x0)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le x1 x2)
                      (x4 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (lt O x2)
                         (x5 => lt (times x x1) (times x0 x2)))))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  q:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  ltnm:(cts.Term cts.star (lt n m)) =>
  lepq:(cts.Term cts.star (le p q)) =>
  posq:(cts.Term cts.star (lt O q)) =>
  le_to_lt_to_lt
    (times n p)
    (times n q)
    (times m q)
    (monotonic_le_times_r n p q lepq)
    (monotonic_lt_times_l q posq n m ltnm).

def lt_times :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (lt x x0)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (lt x1 x2)
                      (x4 => lt (times x x1) (times x0 x2))))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  q:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  ltnm:(cts.Term cts.star (lt n m)) =>
  ltpq:(cts.Term cts.star (lt p q)) =>
  lt_to_le_to_lt_times n m p q ltnm (lt_to_le p q ltpq) (ltn_to_ltO p q ltpq).

def lt_plus_to_minus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (lt (plus x x0) x1)
                (x2 => lt x (minus x1 x0))))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (lt (plus a b) c)) =>
  le_plus_to_minus_r
    (S a)
    b
    c
    (sym_eq_plus
       (S a)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        le (y b) c)
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          plus_body
          a
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           le (y b) c)
          (sym_eq_plus_body_S
             a
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              le (y b) c)
             H))).

def lt_plus_Sn_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod cts.box cts.star cts.star cts.I nat (x1 => lt x (plus (plus x x0) (S x1))))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.eq_coerc
    (le (S a) (S (plus (plus a x) n)))
    (le (S a) (plus (plus a x) (S n)))
    (le_S_S
       a
       (plus (plus a x) n)
       (logic.eq_coerc
          (le a (plus a (plus x n)))
          (le a (plus (plus a x) n))
          (le_plus_n_r (plus x n) a)
          (logic.rewrite_r
             nat
             (plus n (plus a x))
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq (cts.univ cts.star cts.box cts.I) (le a (plus a (plus x n))) (le a __))
             (logic.rewrite_r
                nat
                (plus a (plus n x))
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (le a (plus a (plus x n))) (le a __))
                (logic.rewrite_r
                   nat
                   (plus x n)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq
                      (cts.univ cts.star cts.box cts.I)
                      (le a (plus a (plus x n)))
                      (le a (plus a __)))
                   (logic.refl (cts.univ cts.star cts.box cts.I) (le a (plus a (plus x n))))
                   (plus n x)
                   (commutative_plus n x))
                (plus n (plus a x))
                (logic.rewrite_l
                   nat
                   (plus (plus a n) x)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq nat (plus n (plus a x)) __)
                   (assoc_plus1 x a n)
                   (plus a (plus n x))
                   (associative_plus a n x)))
             (plus (plus a x) n)
             (commutative_plus (plus a x) n))))
    (logic.rewrite_r
       nat
       (plus a (plus x (S n)))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le (S a) (S (plus (plus a x) n))) (le (S a) __))
       (logic.rewrite_r
          nat
          (plus (plus a x) (S n))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le (S a) __)
             (le (S a) (plus a (plus x (S n)))))
          (logic.rewrite_r
             nat
             (plus a (plus x (S n)))
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (le (S a) __)
                (le (S a) (plus a (plus x (S n)))))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (S a) (plus a (plus x (S n)))))
             (plus (plus a x) (S n))
             (associative_plus a x (S n)))
          (S (plus (plus a x) n))
          (plus_n_Sm (plus a x) n))
       (plus (plus a x) (S n))
       (associative_plus a x (S n))).

def not_le_Sn_O :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => connectives.Not (le (S x) O)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.nmk
    (le (S n) O)
    (Hlen0:(cts.Term cts.star (le (S n) O)) =>
     eq_match_nat_type_O
       (cts.univ cts.star cts.box cts.I)
       connectives.False
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        connectives.True)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.univ cts.star cts.box cts.I))) =>
        y)
       (lt_to_not_zero n O Hlen0)).

def not_le_to_not_le_S_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (le x x0))
             (x1 => connectives.Not (le (S x) (S x0))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (connectives.Not (le n m))) =>
  logic.not_to_not
    (le (S n) (S m))
    (le n m)
    (auto':(cts.Term cts.star (le (S n) (S m))) =>
     logic.eq_coerc
       (le (pred (S n)) (pred (S m)))
       (le n m)
       (monotonic_pred (S n) (S m) auto')
       (logic.rewrite_l
          nat
          n
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le __ (pred (S m))) (le n m))
          (logic.rewrite_l
             nat
             m
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq (cts.univ cts.star cts.box cts.I) (le n __) (le n m))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le n m))
             (pred (S m))
             (pred_Sn m))
          (pred (S n))
          (pred_Sn n)))
    auto.

def not_le_S_S_to_not_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (le (S x) (S x0)))
             (x1 => connectives.Not (le x x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (connectives.Not (le (S n) (S m)))) =>
  logic.not_to_not
    (le n m)
    (le (S n) (S m))
    (auto':(cts.Term cts.star (le n m)) => le_S_S n m auto')
    auto.

def not_le_Sn_n :
  cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => connectives.Not (le (S x) x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     connectives.Not (le (S _x_365) _x_365))
    (not_le_Sn_O O)
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term cts.star (connectives.Not (le (S x_366) x_366))) =>
     not_le_to_not_le_S_S (S x_366) x_366 _x_368)
    n.

def lt_to_not_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod cts.star cts.star cts.star cts.I (lt x x0) (x1 => connectives.Not (le x0 x)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  Hltnm:(cts.Term cts.star (lt n m)) =>
  le_ind
    (S n)
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     connectives.Not (le x_417 n))
    (not_le_Sn_n n)
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le (S n) m0)) =>
     _x_421:(cts.Term cts.star (connectives.Not (le m0 n))) =>
     logic.not_to_not
       (le (S m0) n)
       (le m0 n)
       (auto:(cts.Term cts.star (le (S m0) n)) => lt_to_le m0 n auto)
       _x_421)
    m
    Hltnm.

def not_le_to_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod cts.star cts.star cts.star cts.I (connectives.Not (le x x0)) (x1 => lt x0 x))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod cts.star cts.star cts.star cts.I (connectives.Not (le __ _0)) (x => lt _0 __))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     abs:(cts.Term cts.star (connectives.Not (le O n))) =>
     connectives.falsity
       (lt n O)
       (logic.absurd
          (le O n)
          (logic.eq_coerc
             (le O (plus n O))
             (le O n)
             (le_plus_n n O)
             (logic.rewrite_l
                nat
                n
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (le O __) (le O n))
                (logic.refl (cts.univ cts.star cts.box cts.I) (le O n))
                (plus n O)
                (plus_n_O n)))
          abs))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     auto:(cts.Term cts.star (connectives.Not (le (S n) O))) => lt_O_S n)
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     Hind:(cts.Term
             cts.star
             (cts.prod cts.star cts.star cts.star cts.I (connectives.Not (le n m)) (x => lt m n))) =>
     HnotleSS:(cts.Term cts.star (connectives.Not (le (S n) (S m)))) =>
     le_S_S (S m) n (Hind (not_le_S_S_to_not_le n m HnotleSS))).

def not_lt_to_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod cts.star cts.star cts.star cts.I (connectives.Not (lt x x0)) (x1 => le x0 x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (connectives.Not (lt n m))) =>
  le_S_S_to_le
    m
    n
    (not_le_to_lt
       (S n)
       m
       (logic.not_to_not (le (S n) m) (lt n m) (auto:(cts.Term cts.star (le (S n) m)) => auto) H)).

def le_to_not_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod cts.star cts.star cts.star cts.I (le x x0) (x1 => connectives.Not (lt x0 x)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (le n m)) =>
  lt_to_not_le
    n
    (S m)
    (le_to_lt_to_lt
       n
       m
       (S m)
       H
       (logic.eq_coerc
          (le (S m) (plus O (S m)))
          (le (S m) (S m))
          (le_plus_n O (S m))
          (logic.rewrite_l
             nat
             (S m)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq (cts.univ cts.star cts.box cts.I) (le (S m) __) (le (S m) (S m)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (S m) (S m)))
             (plus O (S m))
             (plus_O_n (S m))))).

def decidable_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat (x0 => logic.decidable (le x x0))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.decidable (le __ _0))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     connectives.or_introl (le O n) (connectives.Not (le O n)) (le_O_n n))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     connectives.or_intror (le (S n) O) (connectives.Not (le (S n) O)) (not_le_Sn_O n))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     _clearme:(cts.Term cts.star (logic.decidable (le n m))) =>
     connectives.match_Or_prop
       (le n m)
       (connectives.Not (le n m))
       (logic.decidable (le (S n) (S m)))
       (auto:(cts.Term cts.star (le n m)) =>
        connectives.or_introl (le (S n) (S m)) (connectives.Not (le (S n) (S m))) (le_S_S n m auto))
       (auto:(cts.Term cts.star (connectives.Not (le n m))) =>
        connectives.or_intror
          (le (S n) (S m))
          (connectives.Not (le (S n) (S m)))
          (not_le_to_not_le_S_S n m auto))
       _clearme).

def decidable_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat (x0 => logic.decidable (lt x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  decidable_le (S n) m.

def le_to_or_lt_eq :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le x x0)
             (x1 => connectives.Or (lt x x0) (logic.eq nat x x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lenm:(cts.Term cts.star (le n m)) =>
  le_ind
    n
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     connectives.Or (lt n x_417) (logic.eq nat n x_417))
    (relations.RC_reflexive nat lt n)
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _x_419:(cts.Term cts.star (le n m0)) =>
     _x_421:(cts.Term cts.star (connectives.Or (lt n m0) (logic.eq nat n m0))) =>
     connectives.or_introl
       (lt n (S m0))
       (logic.eq nat n (S m0))
       (le_to_lt_to_lt
          n
          m0
          (S m0)
          _x_419
          (logic.eq_coerc
             (le (S m0) (plus O (S m0)))
             (le (S m0) (S m0))
             (le_plus_n O (S m0))
             (logic.rewrite_l
                nat
                (S m0)
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (le (S m0) __) (le (S m0) (S m0)))
                (logic.refl (cts.univ cts.star cts.box cts.I) (le (S m0) (S m0)))
                (plus O (S m0))
                (plus_O_n (S m0))))))
    m
    lenm.

def lt_O_n_elim :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (lt O x)
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => cts.univ cts.star cts.box cts.I))
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.box cts.star cts.star cts.I nat (x2 => x1 (S x2)))
                (x2 => x1 x)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (lt O _x_365)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.star cts.star cts.I nat (x1 => x0 (S x1)))
             (x1 => x0 _x_365))))
    (abs:(cts.Term cts.star (lt O O)) =>
     connectives.falsity
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I))
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.star cts.star cts.I nat (x0 => x (S x0)))
             (x0 => x O)))
       (logic.absurd (le (S O) O) abs (not_le_Sn_O O)))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     _x_368:(cts.Term
               cts.star
               (cts.prod
                  cts.star
                  cts.star
                  cts.star
                  cts.I
                  (lt O x_366)
                  (x =>
                   cts.prod
                     cts.box
                     cts.star
                     cts.star
                     cts.I
                     (cts.prod
                        cts.box
                        cts.box
                        cts.box
                        cts.I
                        nat
                        (x0 => cts.univ cts.star cts.box cts.I))
                     (x0 =>
                      cts.prod
                        cts.star
                        cts.star
                        cts.star
                        cts.I
                        (cts.prod cts.box cts.star cts.star cts.I nat (x1 => x0 (S x1)))
                        (x1 => x0 x_366))))) =>
     auto:(cts.Term cts.star (lt O (S x_366))) =>
     P:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I)))) =>
     auto':(cts.Term cts.star (cts.prod cts.box cts.star cts.star cts.I nat (x => P (S x)))) =>
     auto' x_366)
    n.

def le_n_O_elim :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (le x O)
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x1 => cts.univ cts.star cts.box cts.I))
             (x1 => cts.prod cts.star cts.star cts.star cts.I (x1 O) (x2 => x1 x)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  match_nat_prop
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (le __ O)
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => cts.univ cts.star cts.box cts.I))
          (x0 => cts.prod cts.star cts.star cts.star cts.I (x0 O) (x1 => x0 __))))
    (auto:(cts.Term cts.star (le O O)) =>
     P:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I)))) =>
     auto':(cts.Term cts.star (P O)) => auto')
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     abs:(cts.Term cts.star (le (S a) O)) =>
     connectives.falsity
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat (x => cts.univ cts.star cts.box cts.I))
          (x => cts.prod cts.star cts.star cts.star cts.I (x O) (x0 => x (S a))))
       (logic.absurd (le (S a) O) abs (not_le_Sn_O a)))
    n.

def lt_to_not_eq :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (lt x x0)
             (x1 => connectives.Not (logic.eq nat x x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (lt n m)) =>
  logic.not_to_not
    (logic.eq nat n m)
    connectives.False
    (auto:(cts.Term cts.star (logic.eq nat n m)) =>
     logic.absurd
       (le (S n) n)
       (logic.eq_coerc
          (le (S n) m)
          (le (S n) n)
          H
          (logic.rewrite_l
             nat
             n
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq (cts.univ cts.star cts.box cts.I) (le (S n) __) (le (S n) n))
             (logic.refl (cts.univ cts.star cts.box cts.I) (le (S n) n))
             m
             auto))
       (not_le_Sn_n n))
    (connectives.nmk connectives.False (auto:(cts.Term cts.star connectives.False) => auto)).

def le_n_O_to_eq :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.star cts.star cts.star cts.I (le x O) (x0 => logic.eq nat O x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  match_nat_prop
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod cts.star cts.star cts.star cts.I (le __ O) (x => logic.eq nat O __))
    (auto:(cts.Term cts.star (le O O)) => logic.refl nat O)
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     abs:(cts.Term cts.star (le (S a) O)) =>
     connectives.falsity (logic.eq nat O (S a)) (logic.absurd (le (S a) O) abs (not_le_Sn_O a)))
    n.

def le_to_le_to_eq :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le x x0)
             (x1 => cts.prod cts.star cts.star cts.star cts.I (le x0 x) (x2 => logic.eq nat x x0)))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (le __ _0)
       (x => cts.prod cts.star cts.star cts.star cts.I (le _0 __) (x0 => logic.eq nat __ _0)))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     auto:(cts.Term cts.star (le O n)) =>
     auto':(cts.Term cts.star (le n O)) =>
     logic.sym_eq
       nat
       n
       O
       (logic.sym_eq
          nat
          O
          n
          (logic.eq_coerc
             (logic.eq nat O n)
             (logic.eq nat O n)
             (le_n_O_to_eq n auto')
             (logic.refl (cts.univ cts.star cts.box cts.I) (logic.eq nat O n)))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     auto:(cts.Term cts.star (le (S n) O)) =>
     auto':(cts.Term cts.star (le O (S n))) => logic.sym_eq nat O (S n) (le_n_O_to_eq (S n) auto))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     auto:(cts.Term
             cts.star
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le n m)
                (x =>
                 cts.prod cts.star cts.star cts.star cts.I (le m n) (x0 => logic.eq nat n m)))) =>
     auto':(cts.Term cts.star (le (S n) (S m))) =>
     auto'':(cts.Term cts.star (le (S m) (S n))) =>
     logic.eq_f
       nat
       nat
       S
       n
       m
       (auto
          (logic.eq_coerc
             (le (pred (S n)) (pred (S m)))
             (le n m)
             (monotonic_pred (S n) (S m) auto')
             (logic.rewrite_l
                nat
                n
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (le __ (pred (S m))) (le n m))
                (logic.rewrite_l
                   nat
                   m
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq (cts.univ cts.star cts.box cts.I) (le n __) (le n m))
                   (logic.refl (cts.univ cts.star cts.box cts.I) (le n m))
                   (pred (S m))
                   (pred_Sn m))
                (pred (S n))
                (pred_Sn n)))
          (logic.eq_coerc
             (le (pred (S m)) (pred (S n)))
             (le m n)
             (monotonic_pred (S m) (S n) auto'')
             (logic.rewrite_l
                nat
                m
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (le __ (pred (S n))) (le m n))
                (logic.rewrite_l
                   nat
                   n
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq (cts.univ cts.star cts.box cts.I) (le m __) (le m n))
                   (logic.refl (cts.univ cts.star cts.box cts.I) (le m n))
                   (pred (S n))
                   (pred_Sn n))
                (pred (S m))
                (pred_Sn m))))).

def plus_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x x0)
                (x2 => logic.eq nat (plus (minus x0 x) x1) (minus (plus x0 x1) x))))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (le __ _0)
          (x0 => logic.eq nat (plus (minus _0 __) x) (minus (plus _0 x) __))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     auto:(cts.Term cts.star (le O n)) =>
     logic.rewrite_l
       nat
       n
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat (plus __ p) (minus (plus n p) O))
       (logic.rewrite_l
          nat
          (plus n p)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat (plus n p) __)
          (logic.refl nat (plus n p))
          (minus (plus n p) O)
          (minus_n_O (plus n p)))
       (minus n O)
       (minus_n_O n))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     abs:(cts.Term cts.star (le (S n) O)) =>
     connectives.falsity
       (logic.eq nat (plus (minus O (S n)) p) (minus (plus O p) (S n)))
       (logic.absurd (le (S n) O) abs (not_le_Sn_O n)))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_minus
       (S m)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le n m)
                (x0 => logic.eq nat (plus (minus m n) x) (minus (plus m x) n))))
          (x =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le (S n) (S m))
                (x1 => logic.eq nat (plus (y (S n)) x0) (minus (plus (S m) x0) (S n))))))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          m
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le n m)
                   (x0 => logic.eq nat (plus (minus m n) x) (minus (plus m x) n))))
             (x =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le (S n) (S m))
                   (x1 => logic.eq nat (plus (y (S n)) x0) (minus (plus (S m) x0) (S n))))))
          (sym_eq_minus_body_S
             m
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le n m)
                      (x0 => logic.eq nat (plus (minus m n) x) (minus (plus m x) n))))
                (x =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (S n) (S m))
                      (x1 => logic.eq nat (plus (y (S n)) x0) (minus (plus (S m) x0) (S n))))))
             (auto:(cts.Term
                      cts.star
                      (cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat
                         (x =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le n m)
                            (x0 => logic.eq nat (plus (minus m n) x) (minus (plus m x) n))))) =>
              p:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              sym_eq_match_nat_type_S
                nat
                (S m)
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 minus m q)
                n
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le (S n) (S m))
                   (x => logic.eq nat (plus y p) (minus (plus (S m) p) (S n))))
                (sym_eq_minus
                   (plus (S m) p)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (S n) (S m))
                      (x => logic.eq nat (plus (minus m n) p) (y (S n))))
                   (sym_eq_plus
                      (S m)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le (S n) (S m))
                         (x =>
                          logic.eq
                            nat
                            (plus (minus m n) p)
                            (filter_nat_type
                               (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                               minus_body
                               (y p)
                               (S n))))
                      (sym_eq_filter_nat_type_S
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                         plus_body
                         m
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le (S n) (S m))
                            (x =>
                             logic.eq
                               nat
                               (plus (minus m n) p)
                               (filter_nat_type
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x0 => nat))
                                  minus_body
                                  (y p)
                                  (S n))))
                         (sym_eq_plus_body_S
                            m
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (le (S n) (S m))
                               (x =>
                                logic.eq
                                  nat
                                  (plus (minus m n) p)
                                  (filter_nat_type
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x0 => nat))
                                     minus_body
                                     (y p)
                                     (S n))))
                            (sym_eq_filter_nat_type_S
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                               minus_body
                               (plus m p)
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (le (S n) (S m))
                                  (x => logic.eq nat (plus (minus m n) p) (y (S n))))
                               (eq_plus_body_S
                                  m
                                  (y:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           (cts.prod
                                              cts.box
                                              cts.box
                                              cts.box
                                              cts.I
                                              nat
                                              (x => nat)))) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (le (S n) (S m))
                                     (x =>
                                      logic.eq
                                        nat
                                        (plus (minus m n) p)
                                        (minus_body (y p) (S n))))
                                  (eq_filter_nat_type_S
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat))
                                     plus_body
                                     m
                                     (y:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              (cts.prod
                                                 cts.box
                                                 cts.box
                                                 cts.box
                                                 cts.I
                                                 nat
                                                 (x => nat)))) =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (le (S n) (S m))
                                        (x =>
                                         logic.eq
                                           nat
                                           (plus (minus m n) p)
                                           (minus_body (y p) (S n))))
                                     (eq_plus
                                        (S m)
                                        (y:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 (cts.prod
                                                    cts.box
                                                    cts.box
                                                    cts.box
                                                    cts.I
                                                    nat
                                                    (x => nat)))) =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (le (S n) (S m))
                                           (x =>
                                            logic.eq
                                              nat
                                              (plus (minus m n) p)
                                              (minus_body (y p) (S n))))
                                        (sym_eq_plus
                                           (S m)
                                           (y:(cts.Term
                                                 cts.diamond
                                                 (cts.cast
                                                    cts.triangle
                                                    cts.sinf
                                                    (cts.univ
                                                       cts.box
                                                       cts.triangle
                                                       cts.I)
                                                    (cts.univ
                                                       cts.diamond
                                                       cts.sinf
                                                       cts.I)
                                                    cts.I
                                                    (cts.prod
                                                       cts.box
                                                       cts.box
                                                       cts.box
                                                       cts.I
                                                       nat
                                                       (x => nat)))) =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (le (S n) (S m))
                                              (x =>
                                               logic.eq
                                                 nat
                                                 (plus (minus m n) p)
                                                 (minus_body (y p) (S n))))
                                           (sym_eq_filter_nat_type_S
                                              (cts.prod
                                                 cts.box
                                                 cts.box
                                                 cts.box
                                                 cts.I
                                                 nat
                                                 (x => nat))
                                              plus_body
                                              m
                                              (y:(cts.Term
                                                    cts.diamond
                                                    (cts.cast
                                                       cts.triangle
                                                       cts.sinf
                                                       (cts.univ
                                                          cts.box
                                                          cts.triangle
                                                          cts.I)
                                                       (cts.univ
                                                          cts.diamond
                                                          cts.sinf
                                                          cts.I)
                                                       cts.I
                                                       (cts.prod
                                                          cts.box
                                                          cts.box
                                                          cts.box
                                                          cts.I
                                                          nat
                                                          (x => nat)))) =>
                                               cts.prod
                                                 cts.star
                                                 cts.star
                                                 cts.star
                                                 cts.I
                                                 (le (S n) (S m))
                                                 (x =>
                                                  logic.eq
                                                    nat
                                                    (plus (minus m n) p)
                                                    (minus_body (y p) (S n))))
                                              (sym_eq_plus_body_S
                                                 m
                                                 (y:(cts.Term
                                                       cts.diamond
                                                       (cts.cast
                                                          cts.triangle
                                                          cts.sinf
                                                          (cts.univ
                                                             cts.box
                                                             cts.triangle
                                                             cts.I)
                                                          (cts.univ
                                                             cts.diamond
                                                             cts.sinf
                                                             cts.I)
                                                          cts.I
                                                          (cts.prod
                                                             cts.box
                                                             cts.box
                                                             cts.box
                                                             cts.I
                                                             nat
                                                             (x => nat)))) =>
                                                  cts.prod
                                                    cts.star
                                                    cts.star
                                                    cts.star
                                                    cts.I
                                                    (le (S n) (S m))
                                                    (x =>
                                                     logic.eq
                                                       nat
                                                       (plus (minus m n) p)
                                                       (minus_body (y p) (S n))))
                                                 (sym_eq_minus_body_S
                                                    (plus m p)
                                                    (y:(cts.Term
                                                          cts.diamond
                                                          (cts.cast
                                                             cts.triangle
                                                             cts.sinf
                                                             (cts.univ
                                                                cts.box
                                                                cts.triangle
                                                                cts.I)
                                                             (cts.univ
                                                                cts.diamond
                                                                cts.sinf
                                                                cts.I)
                                                             cts.I
                                                             (cts.prod
                                                                cts.box
                                                                cts.box
                                                                cts.box
                                                                cts.I
                                                                nat
                                                                (x => nat)))) =>
                                                     cts.prod
                                                       cts.star
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       (le (S n) (S m))
                                                       (x =>
                                                        logic.eq
                                                          nat
                                                          (plus (minus m n) p)
                                                          (y (S n))))
                                                    (sym_eq_match_nat_type_S
                                                       nat
                                                       (S (plus m p))
                                                       (q:(cts.Term
                                                             cts.diamond
                                                             (cts.cast
                                                                cts.triangle
                                                                cts.sinf
                                                                (cts.univ
                                                                   cts.box
                                                                   cts.triangle
                                                                   cts.I)
                                                                (cts.univ
                                                                   cts.diamond
                                                                   cts.sinf
                                                                   cts.I)
                                                                cts.I
                                                                nat)) =>
                                                        minus (plus m p) q)
                                                       n
                                                       (y:(cts.Term
                                                             cts.diamond
                                                             (cts.cast
                                                                cts.triangle
                                                                cts.sinf
                                                                (cts.univ
                                                                   cts.box
                                                                   cts.triangle
                                                                   cts.I)
                                                                (cts.univ
                                                                   cts.diamond
                                                                   cts.sinf
                                                                   cts.I)
                                                                cts.I
                                                                nat)) =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (le (S n) (S m))
                                                          (x =>
                                                           logic.eq
                                                             nat
                                                             (plus (minus m n) p)
                                                             y))
                                                       (auto':(cts.Term
                                                                 cts.star
                                                                 (le (S n) (S m))) =>
                                                        auto
                                                          p
                                                          (logic.eq_coerc
                                                             (le
                                                                (pred (S n))
                                                                (pred (S m)))
                                                             (le n m)
                                                             (monotonic_pred
                                                                (S n)
                                                                (S m)
                                                                auto')
                                                             (logic.rewrite_l
                                                                nat
                                                                n
                                                                (__:(
                                                                 cts.Term
                                                                   cts.diamond
                                                                   (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat)) =>
                                                                 logic.eq
                                                                   (cts.univ
                                                                    cts.star
                                                                    cts.box
                                                                    cts.I)
                                                                   (le
                                                                    __
                                                                    (pred
                                                                    (S m)))
                                                                   (le n m))
                                                                (logic.rewrite_l
                                                                   nat
                                                                   m
                                                                   (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat)) =>
                                                                    logic.eq
                                                                    (cts.univ
                                                                    cts.star
                                                                    cts.box
                                                                    cts.I)
                                                                    (le n __)
                                                                    (le n m))
                                                                   (logic.refl
                                                                    (cts.univ
                                                                    cts.star
                                                                    cts.box
                                                                    cts.I)
                                                                    (le n m))
                                                                   (pred (S m))
                                                                   (pred_Sn m))
                                                                (pred (S n))
                                                                (pred_Sn n))))))))))))))))))))).

def minus_plus_m_m :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod cts.box cts.star cts.star cts.I nat (x0 => logic.eq nat x (minus (plus x x0) x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.eq_coerc
    (logic.eq nat (plus (minus m m) n) (minus (plus m n) m))
    (logic.eq nat n (minus (plus n m) m))
    (plus_minus m m n (le_n m))
    (logic.rewrite_l
       nat
       O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq
          (cts.univ cts.star cts.box cts.I)
          (logic.eq nat (plus __ n) (minus (plus m n) m))
          (logic.eq nat n (minus (plus n m) m)))
       (logic.rewrite_l
          nat
          n
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (logic.eq nat __ (minus (plus m n) m))
             (logic.eq nat n (minus (plus n m) m)))
          (logic.rewrite_r
             nat
             (plus n m)
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (logic.eq nat n (minus __ m))
                (logic.eq nat n (minus (plus n m) m)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (logic.eq nat n (minus (plus n m) m)))
             (plus m n)
             (commutative_plus m n))
          (plus O n)
          (plus_O_n n))
       (minus m m)
       (minus_n_n m)).

def plus_minus_m_m :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le x0 x)
             (x1 => logic.eq nat x (plus (minus x x0) x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lemn:(cts.Term cts.star (le m n)) =>
  logic.sym_eq
    nat
    (plus (minus n m) m)
    n
    (logic.eq_coerc
       (logic.eq nat (plus (minus n m) m) (minus (plus n m) m))
       (logic.eq nat (plus (minus n m) m) n)
       (plus_minus m n m lemn)
       (logic.rewrite_r
          nat
          (plus m (minus n m))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (logic.eq nat (plus (minus n m) m) (minus (plus n m) m))
             (logic.eq nat __ n))
          (logic.rewrite_r
             nat
             (plus m (minus n m))
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (logic.eq nat __ (minus (plus n m) m))
                (logic.eq nat (plus m (minus n m)) n))
             (logic.rewrite_l
                nat
                n
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq
                   (cts.univ cts.star cts.box cts.I)
                   (logic.eq nat (plus m (minus n m)) __)
                   (logic.eq nat (plus m (minus n m)) n))
                (logic.refl
                   (cts.univ cts.star cts.box cts.I)
                   (logic.eq nat (plus m (minus n m)) n))
                (minus (plus n m) m)
                (minus_plus_m_m n m))
             (plus (minus n m) m)
             (commutative_plus (minus n m) m))
          (plus (minus n m) m)
          (commutative_plus (minus n m) m))).

def minus_to_plus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x0 x)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat (minus x x0) x1)
                   (x3 => logic.eq nat x (plus x0 x1)))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lemn:(cts.Term cts.star (le m n)) =>
  eqp:(cts.Term cts.star (logic.eq nat (minus n m) p)) =>
  logic.eq_coerc
    (logic.eq nat n (plus (minus n m) m))
    (logic.eq nat n (plus m p))
    (plus_minus_m_m n m lemn)
    (logic.rewrite_r
       nat
       (plus m (minus n m))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (logic.eq nat n __) (logic.eq nat n (plus m p)))
       (logic.rewrite_r
          nat
          p
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (logic.eq nat n (plus m __))
             (logic.eq nat n (plus m p)))
          (logic.refl (cts.univ cts.star cts.box cts.I) (logic.eq nat n (plus m p)))
          (minus n m)
          eqp)
       (plus (minus n m) m)
       (commutative_plus (minus n m) m)).

def plus_to_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat x (plus x0 x1))
                (x2 => logic.eq nat (minus x x0) x1)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  eqp:(cts.Term cts.star (logic.eq nat n (plus m p))) =>
  logic.sym_eq
    nat
    p
    (minus n m)
    (logic.eq_coerc
       (logic.eq nat p (minus (plus p m) m))
       (logic.eq nat p (minus n m))
       (minus_plus_m_m p m)
       (logic.rewrite_r
          nat
          (plus m p)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (logic.eq nat p (minus __ m))
             (logic.eq nat p (minus n m)))
          (logic.rewrite_l
             nat
             n
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq
                (cts.univ cts.star cts.box cts.I)
                (logic.eq nat p (minus __ m))
                (logic.eq nat p (minus n m)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (logic.eq nat p (minus n m)))
             (plus m p)
             eqp)
          (plus p m)
          (commutative_plus p m))).

def monotonic_le_minus_l :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x0 x)
                (x2 => le (minus x0 x1) (minus x x1))))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod cts.star cts.star cts.star cts.I (le _0 __) (x0 => le (minus _0 x) (minus __ x))))
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     q:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     lePO:(cts.Term cts.star (le p O)) =>
     le_n_O_elim
       p
       lePO
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        le (minus __ q) (minus O q))
       (le_n (minus O q)))
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     q:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_minus
       (S p)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
        cts.prod cts.star cts.star cts.star cts.I (le O (S p)) (x => le (minus O q) (y q)))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
          minus_body
          p
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod cts.star cts.star cts.star cts.I (le O (S p)) (x => le (minus O q) (y q)))
          (sym_eq_minus_body_S
             p
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod cts.star cts.star cts.star cts.I (le O (S p)) (x => le (minus O q) (y q)))
             (eq_plus_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le O (S p))
                   (x =>
                    le
                      (minus O q)
                      (y
                         (match_nat_type
                            nat
                            (S p)
                            (q0:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             minus p q0)
                            q))))
                (eq_filter_nat_type_O
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                   plus_body
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le O (S p))
                      (x =>
                       le
                         (minus O q)
                         (y
                            (match_nat_type
                               nat
                               (S p)
                               (q0:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                minus p q0)
                               q))))
                   (eq_plus
                      O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le O (S p))
                         (x =>
                          le
                            (minus O q)
                            (y
                               (match_nat_type
                                  nat
                                  (S p)
                                  (q0:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat)) =>
                                   minus p q0)
                                  q))))
                      (eq_minus_body_O
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le O (S p))
                            (x =>
                             le
                               (minus O q)
                               (plus
                                  (y
                                     (match_nat_type
                                        nat
                                        (S p)
                                        (q0:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         minus p q0)
                                        q))
                                  (match_nat_type
                                     nat
                                     (S p)
                                     (q0:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat)) =>
                                      minus p q0)
                                     q))))
                         (eq_filter_nat_type_O
                            (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                            minus_body
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (le O (S p))
                               (x =>
                                le
                                  (minus O q)
                                  (plus
                                     (y
                                        (match_nat_type
                                           nat
                                           (S p)
                                           (q0:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat)) =>
                                            minus p q0)
                                           q))
                                     (match_nat_type
                                        nat
                                        (S p)
                                        (q0:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         minus p q0)
                                        q))))
                            (eq_minus
                               O
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat
                                           (x => nat)))) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (le O (S p))
                                  (x =>
                                   le
                                     (minus O q)
                                     (plus
                                        (y
                                           (match_nat_type
                                              nat
                                              (S p)
                                              (q0:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat)) =>
                                               minus p q0)
                                              q))
                                        (match_nat_type
                                           nat
                                           (S p)
                                           (q0:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat)) =>
                                            minus p q0)
                                           q))))
                               (eq_minus_body_O
                                  (y:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           (cts.prod
                                              cts.box
                                              cts.box
                                              cts.box
                                              cts.I
                                              nat
                                              (x => nat)))) =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (le O (S p))
                                     (x =>
                                      le
                                        (minus O q)
                                        (plus
                                           (minus
                                              (y q)
                                              (match_nat_type
                                                 nat
                                                 (S p)
                                                 (q0:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat)) =>
                                                  minus p q0)
                                                 q))
                                           (match_nat_type
                                              nat
                                              (S p)
                                              (q0:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat)) =>
                                               minus p q0)
                                              q))))
                                  (eq_filter_nat_type_O
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat))
                                     minus_body
                                     (y:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              (cts.prod
                                                 cts.box
                                                 cts.box
                                                 cts.box
                                                 cts.I
                                                 nat
                                                 (x => nat)))) =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (le O (S p))
                                        (x =>
                                         le
                                           (minus O q)
                                           (plus
                                              (minus
                                                 (y q)
                                                 (match_nat_type
                                                    nat
                                                    (S p)
                                                    (q0:(cts.Term
                                                           cts.diamond
                                                           (cts.cast
                                                              cts.triangle
                                                              cts.sinf
                                                              (cts.univ
                                                                 cts.box
                                                                 cts.triangle
                                                                 cts.I)
                                                              (cts.univ
                                                                 cts.diamond
                                                                 cts.sinf
                                                                 cts.I)
                                                              cts.I
                                                              nat)) =>
                                                     minus p q0)
                                                    q))
                                              (match_nat_type
                                                 nat
                                                 (S p)
                                                 (q0:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat)) =>
                                                  minus p q0)
                                                 q))))
                                     (eq_minus
                                        O
                                        (y:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 (cts.prod
                                                    cts.box
                                                    cts.box
                                                    cts.box
                                                    cts.I
                                                    nat
                                                    (x => nat)))) =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (le O (S p))
                                           (x =>
                                            le
                                              (minus O q)
                                              (plus
                                                 (minus
                                                    (y q)
                                                    (match_nat_type
                                                       nat
                                                       (S p)
                                                       (q0:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat)) =>
                                                        minus p q0)
                                                       q))
                                                 (match_nat_type
                                                    nat
                                                    (S p)
                                                    (q0:(cts.Term
                                                           cts.diamond
                                                           (cts.cast
                                                              cts.triangle
                                                              cts.sinf
                                                              (cts.univ
                                                                 cts.box
                                                                 cts.triangle
                                                                 cts.I)
                                                              (cts.univ
                                                                 cts.diamond
                                                                 cts.sinf
                                                                 cts.I)
                                                              cts.I
                                                              nat)) =>
                                                     minus p q0)
                                                    q))))
                                        (auto:(cts.Term cts.star (le O (S p))) =>
                                         le_plus_minus_m_m
                                           (minus O q)
                                           (match_nat_type
                                              nat
                                              (S p)
                                              (q0:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat)) =>
                                               minus p q0)
                                              q))))))))))))))
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     q:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     Hind:(cts.Term
             cts.star
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le q p)
                   (x0 => le (minus q x) (minus p x))))) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_prop
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (le (S q) (S p))
          (x => le (minus (S q) __) (minus (S p) __)))
       (sym_eq_minus
          (S q)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le (S q) (S p))
             (x => le (y O) (minus (S p) O)))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             q
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le (S q) (S p))
                (x => le (y O) (minus (S p) O)))
             (sym_eq_minus_body_S
                q
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le (S q) (S p))
                   (x => le (y O) (minus (S p) O)))
                (sym_eq_match_nat_type_O
                   nat
                   (S q)
                   (z:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    minus q z)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (S q) (S p))
                      (x => le y (minus (S p) O)))
                   (sym_eq_minus
                      (S p)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le (S q) (S p))
                         (x => le (S q) (y O)))
                      (sym_eq_filter_nat_type_S
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                         minus_body
                         p
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le (S q) (S p))
                            (x => le (S q) (y O)))
                         (sym_eq_minus_body_S
                            p
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (le (S q) (S p))
                               (x => le (S q) (y O)))
                            (sym_eq_match_nat_type_O
                               nat
                               (S p)
                               (q0:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                minus p q0)
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat)) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (le (S q) (S p))
                                  (x => le (S q) y))
                               (auto:(cts.Term cts.star (le (S q) (S p))) => auto)))))))))
       (sym_eq_minus
          (S q)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le (S q) (S p))
                (x0 => le (y (S x)) (minus (S p) (S x)))))
          (sym_eq_filter_nat_type_S
             (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
             minus_body
             q
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le (S q) (S p))
                   (x0 => le (y (S x)) (minus (S p) (S x)))))
             (sym_eq_minus_body_S
                q
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (S q) (S p))
                      (x0 => le (y (S x)) (minus (S p) (S x)))))
                (a:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 sym_eq_match_nat_type_S
                   nat
                   (S q)
                   (z:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    minus q z)
                   a
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (S q) (S p))
                      (x => le y (minus (S p) (S a))))
                   (sym_eq_minus
                      (S p)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le (S q) (S p))
                         (x => le (minus q a) (y (S a))))
                      (sym_eq_filter_nat_type_S
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => nat))
                         minus_body
                         p
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod cts.box cts.box cts.box cts.I nat (x => nat)))) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le (S q) (S p))
                            (x => le (minus q a) (y (S a))))
                         (sym_eq_minus_body_S
                            p
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat
                                        (x => nat)))) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (le (S q) (S p))
                               (x => le (minus q a) (y (S a))))
                            (sym_eq_match_nat_type_S
                               nat
                               (S p)
                               (q0:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat)) =>
                                minus p q0)
                               a
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat)) =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (le (S q) (S p))
                                  (x => le (minus q a) y))
                               (leSS:(cts.Term cts.star (le (S q) (S p))) =>
                                Hind
                                  a
                                  (logic.eq_coerc
                                     (le (pred (S q)) (pred (S p)))
                                     (le q p)
                                     (monotonic_pred (S q) (S p) leSS)
                                     (logic.rewrite_l
                                        nat
                                        q
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat)) =>
                                         logic.eq
                                           (cts.univ cts.star cts.box cts.I)
                                           (le __ (pred (S p)))
                                           (le q p))
                                        (logic.rewrite_l
                                           nat
                                           p
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat)) =>
                                            logic.eq
                                              (cts.univ cts.star cts.box cts.I)
                                              (le q __)
                                              (le q p))
                                           (logic.refl
                                              (cts.univ cts.star cts.box cts.I)
                                              (le q p))
                                           (pred (S p))
                                           (pred_Sn p))
                                        (pred (S q))
                                        (pred_Sn q))))))))))))
       n).

def le_plus_to_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x (plus x1 x0))
                (x2 => le (minus x x0) x1)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lep:(cts.Term cts.star (le n (plus p m))) =>
  logic.eq_coerc
    (le (minus n m) (minus (plus p m) m))
    (le (minus n m) p)
    (monotonic_le_minus_l (plus p m) n m lep)
    (logic.rewrite_l
       nat
       p
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le (minus n m) __) (le (minus n m) p))
       (logic.refl (cts.univ cts.star cts.box cts.I) (le (minus n m) p))
       (minus (plus p m) m)
       (minus_plus_m_m p m)).

def monotonic_le_minus_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x0 x)
                (x2 => le (minus x1 x) (minus x1 x0))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  q:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lepq:(cts.Term cts.star (le q p)) =>
  le_plus_to_minus
    n
    p
    (minus n q)
    (transitive_le
       n
       (plus (minus n q) q)
       (plus (minus n q) p)
       (le_plus_minus_m_m n q)
       (monotonic_le_plus_r (minus n q) q p lepq)).

def minus_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat (x0 => le (minus x x0) x)))
  :=
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.eq_coerc
    (le (minus x y) (minus (plus x y) y))
    (le (minus x y) x)
    (monotonic_le_minus_l (plus x y) x y (le_plus_n_r y x))
    (logic.rewrite_l
       nat
       x
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq (cts.univ cts.star cts.box cts.I) (le (minus x y) __) (le (minus x y) x))
       (logic.refl (cts.univ cts.star cts.box cts.I) (le (minus x y) x))
       (minus (plus x y) y)
       (minus_plus_m_m x y)).

def not_eq_to_le_to_lt :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (logic.eq nat x x0))
             (x1 => cts.prod cts.star cts.star cts.star cts.I (le x x0) (x2 => lt x x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  Hneq:(cts.Term cts.star (connectives.Not (logic.eq nat n m))) =>
  Hle:(cts.Term cts.star (le n m)) =>
  connectives.match_Or_prop
    (lt n m)
    (logic.eq nat n m)
    (lt n m)
    (auto:(cts.Term cts.star (lt n m)) => auto)
    (Heq:(cts.Term cts.star (logic.eq nat n m)) =>
     not_le_to_lt
       m
       n
       (logic.not_to_not
          (le m n)
          (logic.eq nat n m)
          (auto:(cts.Term cts.star (le m n)) =>
           logic.rewrite_l
             nat
             n
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat n __)
             (logic.refl nat n)
             m
             Heq)
          Hneq))
    (le_to_or_lt_eq n m Hle).

def eq_minus_O :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod cts.star cts.star cts.star cts.I (le x x0) (x1 => logic.eq nat (minus x x0) O))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lenm:(cts.Term cts.star (le n m)) =>
  le_n_O_elim
    (minus n m)
    (logic.eq_coerc
       (le (minus n m) (minus n n))
       (le (minus n m) O)
       (monotonic_le_minus_r m n n lenm)
       (logic.rewrite_l
          nat
          O
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq (cts.univ cts.star cts.box cts.I) (le (minus n m) __) (le (minus n m) O))
          (logic.refl (cts.univ cts.star cts.box cts.I) (le (minus n m) O))
          (minus n n)
          (minus_n_n n)))
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat __ O)
    (logic.refl nat O).

def distributive_times_minus :
  cts.Term cts.star (relations.distributive nat times minus)
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.match_Or_prop
    (lt b c)
    (connectives.Not (lt b c))
    (logic.eq nat (times a (minus b c)) (minus (times a b) (times a c)))
    (Hbc:(cts.Term cts.star (lt b c)) =>
     logic.eq_ind_r
       nat
       O
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        logic.eq nat (times a x) (minus (times a b) (times a c)))
       (logic.eq_ind_r
          nat
          O
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           logic.eq nat (times a O) x)
          (logic.rewrite_l
             nat
             O
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat __ O)
             (logic.refl nat O)
             (times a O)
             (times_n_O a))
          (minus (times a b) (times a c))
          (eq_minus_O (times a b) (times a c) (monotonic_le_times_r a b c (lt_to_le b c Hbc))))
       (minus b c)
       (eq_minus_O b c (lt_to_le b c Hbc)))
    (Hbc:(cts.Term cts.star (connectives.Not (lt b c))) =>
     logic.sym_eq
       nat
       (minus (times a b) (times a c))
       (times a (minus b c))
       (logic.eq_coerc
          (logic.eq nat (minus (times a b) (times a c)) (times a (minus b c)))
          (logic.eq nat (minus (times a b) (times a c)) (times a (minus b c)))
          (plus_to_minus
             (times a b)
             (times a c)
             (times a (minus b c))
             (logic.eq_ind
                nat
                (times a (plus c (minus b c)))
                (x_1:(cts.Term
                        cts.diamond
                        (cts.cast
                           cts.triangle
                           cts.sinf
                           (cts.univ cts.box cts.triangle cts.I)
                           (cts.univ cts.diamond cts.sinf cts.I)
                           cts.I
                           nat)) =>
                 logic.eq nat (times a b) x_1)
                (logic.eq_f
                   nat
                   nat
                   (times a)
                   b
                   (plus c (minus b c))
                   (logic.eq_coerc
                      (logic.eq nat b (plus (minus b c) c))
                      (logic.eq nat b (plus c (minus b c)))
                      (plus_minus_m_m b c (not_lt_to_le b c Hbc))
                      (logic.rewrite_r
                         nat
                         (plus c (minus b c))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq
                            (cts.univ cts.star cts.box cts.I)
                            (logic.eq nat b __)
                            (logic.eq nat b (plus c (minus b c))))
                         (logic.refl
                            (cts.univ cts.star cts.box cts.I)
                            (logic.eq nat b (plus c (minus b c))))
                         (plus (minus b c) c)
                         (commutative_plus (minus b c) c))))
                (plus (times a c) (times a (minus b c)))
                (distributive_times_plus a c (minus b c))))
          (logic.refl
             (cts.univ cts.star cts.box cts.I)
             (logic.eq nat (minus (times a b) (times a c)) (times a (minus b c))))))
    (decidable_lt b c).

def minus_plus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (minus (minus x x0) x1) (minus x (plus x0 x1))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.match_Or_prop
    (le (plus m p) n)
    (connectives.Not (le (plus m p) n))
    (logic.eq nat (minus (minus n m) p) (minus n (plus m p)))
    (Hlt:(cts.Term cts.star (le (plus m p) n)) =>
     plus_to_minus
       (minus n m)
       p
       (minus n (plus m p))
       (plus_to_minus
          n
          m
          (plus p (minus n (plus m p)))
          (logic.eq_ind
             nat
             (plus (plus m p) (minus n (plus m p)))
             (x_1:(cts.Term
                     cts.diamond
                     (cts.cast
                        cts.triangle
                        cts.sinf
                        (cts.univ cts.box cts.triangle cts.I)
                        (cts.univ cts.diamond cts.sinf cts.I)
                        cts.I
                        nat)) =>
              logic.eq nat n x_1)
             (minus_to_plus
                n
                (plus m p)
                (minus n (plus m p))
                Hlt
                (logic.refl nat (minus n (plus m p))))
             (plus m (plus p (minus n (plus m p))))
             (associative_plus m p (minus n (plus m p))))))
    (Hlt:(cts.Term cts.star (connectives.Not (le (plus m p) n))) =>
     logic.eq_ind_r
       nat
       O
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        logic.eq nat x (minus n (plus m p)))
       (logic.sym_eq
          nat
          (minus n (plus m p))
          O
          (logic.eq_coerc
             (logic.eq nat (minus n (plus m p)) O)
             (logic.eq nat (minus n (plus m p)) O)
             (eq_minus_O
                n
                (plus m p)
                (transitive_le n (S n) (plus m p) (le_n_Sn n) (not_le_to_lt (plus m p) n Hlt)))
             (logic.refl (cts.univ cts.star cts.box cts.I) (logic.eq nat (minus n (plus m p)) O))))
       (minus (minus n m) p)
       (eq_minus_O
          (minus n m)
          p
          (logic.eq_coerc
             (le (minus n m) (minus (plus p m) m))
             (le (minus n m) p)
             (monotonic_le_minus_l
                (plus p m)
                n
                m
                (logic.eq_coerc
                   (le n (plus m p))
                   (le n (plus p m))
                   (transitive_le n (S n) (plus m p) (le_n_Sn n) (not_le_to_lt (plus m p) n Hlt))
                   (logic.rewrite_r
                      nat
                      (plus m p)
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat)) =>
                       logic.eq (cts.univ cts.star cts.box cts.I) (le n (plus m p)) (le n __))
                      (logic.refl (cts.univ cts.star cts.box cts.I) (le n (plus m p)))
                      (plus p m)
                      (commutative_plus p m))))
             (logic.rewrite_l
                nat
                p
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq
                   (cts.univ cts.star cts.box cts.I)
                   (le (minus n m) __)
                   (le (minus n m) p))
                (logic.refl (cts.univ cts.star cts.box cts.I) (le (minus n m) p))
                (minus (plus p m) m)
                (minus_plus_m_m p m)))))
    (decidable_le (plus m p) n).

def minus_minus :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x1 x0)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (le x0 x)
                   (x3 => logic.eq nat (plus x1 (minus x x0)) (minus x (minus x0 x1))))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  lepm:(cts.Term cts.star (le p m)) =>
  lemn:(cts.Term cts.star (le m n)) =>
  logic.sym_eq
    nat
    (minus n (minus m p))
    (plus p (minus n m))
    (plus_to_minus
       n
       (minus m p)
       (plus p (minus n m))
       (logic.eq_ind
          nat
          (plus (plus (minus m p) p) (minus n m))
          (x_1:(cts.Term
                  cts.diamond
                  (cts.cast
                     cts.triangle
                     cts.sinf
                     (cts.univ cts.box cts.triangle cts.I)
                     (cts.univ cts.diamond cts.sinf cts.I)
                     cts.I
                     nat)) =>
           logic.eq nat n x_1)
          (logic.eq_ind
             nat
             m
             (x_1:(cts.Term
                     cts.diamond
                     (cts.cast
                        cts.triangle
                        cts.sinf
                        (cts.univ cts.box cts.triangle cts.I)
                        (cts.univ cts.diamond cts.sinf cts.I)
                        cts.I
                        nat)) =>
              logic.eq nat n (plus x_1 (minus n m)))
             (logic.eq_ind
                nat
                (plus (minus n m) m)
                (x_1:(cts.Term
                        cts.diamond
                        (cts.cast
                           cts.triangle
                           cts.sinf
                           (cts.univ cts.box cts.triangle cts.I)
                           (cts.univ cts.diamond cts.sinf cts.I)
                           cts.I
                           nat)) =>
                 logic.eq nat n x_1)
                (logic.eq_ind
                   nat
                   n
                   (x_1:(cts.Term
                           cts.diamond
                           (cts.cast
                              cts.triangle
                              cts.sinf
                              (cts.univ cts.box cts.triangle cts.I)
                              (cts.univ cts.diamond cts.sinf cts.I)
                              cts.I
                              nat)) =>
                    logic.eq nat n x_1)
                   (logic.refl nat n)
                   (plus (minus n m) m)
                   (plus_minus_m_m n m lemn))
                (plus m (minus n m))
                (commutative_plus (minus n m) m))
             (plus (minus m p) p)
             (plus_minus_m_m m p lepm))
          (plus (minus m p) (plus p (minus n m)))
          (associative_plus (minus m p) p (minus n m)))).

def minus_minus_comm :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (minus (minus x x0) x1) (minus (minus x x1) x0)))))
  :=
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  le_to_le_to_eq
    (minus (minus a b) c)
    (minus (minus a c) b)
    (logic.eq_coerc
       (le (minus (minus a b) c) (minus (plus (minus (minus a c) b) c) c))
       (le (minus (minus a b) c) (minus (minus a c) b))
       (monotonic_le_minus_l
          (plus (minus (minus a c) b) c)
          (minus a b)
          c
          (logic.eq_coerc
             (le (minus a b) (plus (minus (minus a b) c) c))
             (le (minus a b) (plus (minus (minus a c) b) c))
             (le_plus_minus_m_m (minus a b) c)
             (logic.rewrite_r
                nat
                (minus a (plus b c))
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq
                   (cts.univ cts.star cts.box cts.I)
                   (le (minus a b) (plus __ c))
                   (le (minus a b) (plus (minus (minus a c) b) c)))
                (logic.rewrite_r
                   nat
                   (plus c (minus a (plus b c)))
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq
                      (cts.univ cts.star cts.box cts.I)
                      (le (minus a b) __)
                      (le (minus a b) (plus (minus (minus a c) b) c)))
                   (logic.rewrite_r
                      nat
                      (plus c (minus (minus a c) b))
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat)) =>
                       logic.eq
                         (cts.univ cts.star cts.box cts.I)
                         (le (minus a b) (plus c (minus a (plus b c))))
                         (le (minus a b) __))
                      (logic.rewrite_l
                         nat
                         (minus (minus a c) b)
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq
                            (cts.univ cts.star cts.box cts.I)
                            (le (minus a b) (plus c __))
                            (le (minus a b) (plus c (minus (minus a c) b))))
                         (logic.refl
                            (cts.univ cts.star cts.box cts.I)
                            (le (minus a b) (plus c (minus (minus a c) b))))
                         (minus a (plus b c))
                         (logic.rewrite_l
                            nat
                            (plus c b)
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             logic.eq nat (minus (minus a c) b) (minus a __))
                            (minus_plus a c b)
                            (plus b c)
                            (commutative_plus c b)))
                      (plus (minus (minus a c) b) c)
                      (commutative_plus (minus (minus a c) b) c))
                   (plus (minus a (plus b c)) c)
                   (commutative_plus (minus a (plus b c)) c))
                (minus (minus a b) c)
                (minus_plus a b c))))
       (logic.rewrite_l
          nat
          (minus (minus a c) b)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le (minus (minus a b) c) __)
             (le (minus (minus a b) c) (minus (minus a c) b)))
          (logic.refl
             (cts.univ cts.star cts.box cts.I)
             (le (minus (minus a b) c) (minus (minus a c) b)))
          (minus (plus (minus (minus a c) b) c) c)
          (minus_plus_m_m (minus (minus a c) b) c)))
    (logic.eq_coerc
       (le (minus (minus a c) b) (minus (plus (minus (minus a b) c) b) b))
       (le (minus (minus a c) b) (minus (minus a b) c))
       (monotonic_le_minus_l
          (plus (minus (minus a b) c) b)
          (minus a c)
          b
          (logic.eq_coerc
             (le (minus a c) (plus (minus (minus a c) b) b))
             (le (minus a c) (plus (minus (minus a b) c) b))
             (le_plus_minus_m_m (minus a c) b)
             (logic.rewrite_r
                nat
                (minus a (plus c b))
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq
                   (cts.univ cts.star cts.box cts.I)
                   (le (minus a c) (plus __ b))
                   (le (minus a c) (plus (minus (minus a b) c) b)))
                (logic.rewrite_r
                   nat
                   (plus b (minus a (plus c b)))
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq
                      (cts.univ cts.star cts.box cts.I)
                      (le (minus a c) __)
                      (le (minus a c) (plus (minus (minus a b) c) b)))
                   (logic.rewrite_r
                      nat
                      (plus b (minus (minus a b) c))
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat)) =>
                       logic.eq
                         (cts.univ cts.star cts.box cts.I)
                         (le (minus a c) (plus b (minus a (plus c b))))
                         (le (minus a c) __))
                      (logic.rewrite_l
                         nat
                         (minus (minus a b) c)
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq
                            (cts.univ cts.star cts.box cts.I)
                            (le (minus a c) (plus b __))
                            (le (minus a c) (plus b (minus (minus a b) c))))
                         (logic.refl
                            (cts.univ cts.star cts.box cts.I)
                            (le (minus a c) (plus b (minus (minus a b) c))))
                         (minus a (plus c b))
                         (logic.rewrite_l
                            nat
                            (plus b c)
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat)) =>
                             logic.eq nat (minus (minus a b) c) (minus a __))
                            (minus_plus a b c)
                            (plus c b)
                            (commutative_plus b c)))
                      (plus (minus (minus a b) c) b)
                      (commutative_plus (minus (minus a b) c) b))
                   (plus (minus a (plus c b)) b)
                   (commutative_plus (minus a (plus c b)) b))
                (minus (minus a c) b)
                (minus_plus a c b))))
       (logic.rewrite_l
          nat
          (minus (minus a b) c)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq
             (cts.univ cts.star cts.box cts.I)
             (le (minus (minus a c) b) __)
             (le (minus (minus a c) b) (minus (minus a b) c)))
          (logic.refl
             (cts.univ cts.star cts.box cts.I)
             (le (minus (minus a c) b) (minus (minus a b) c)))
          (minus (plus (minus (minus a b) c) b) b)
          (minus_plus_m_m (minus (minus a b) c) b))).

def minus_le_minus_minus_comm :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (le x0 x)
                (x2 => logic.eq nat (minus x1 (minus x x0)) (minus (plus x1 x0) x))))))
  :=
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  c:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  H:(cts.Term cts.star (le c b)) =>
  logic.eq_ind_r
    nat
    (plus (minus b c) c)
    (x:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     logic.eq nat (minus a (minus b c)) (minus (plus a c) x))
    (logic.rewrite_r
       nat
       (plus c a)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat (minus a (minus b c)) (minus __ (plus (minus b c) c)))
       (logic.rewrite_r
          nat
          (plus c (minus b c))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat (minus a (minus b c)) (minus (plus c a) __))
          (logic.rewrite_l
             nat
             (minus (minus (plus c a) c) (minus b c))
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat (minus a (minus b c)) __)
             (logic.rewrite_r
                nat
                (minus (plus c a) c)
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat)) =>
                 logic.eq nat (minus __ (minus b c)) (minus (minus (plus c a) c) (minus b c)))
                (logic.refl nat (minus (minus (plus c a) c) (minus b c)))
                a
                (logic.rewrite_l
                   nat
                   (plus a c)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat)) =>
                    logic.eq nat a (minus __ c))
                   (minus_plus_m_m a c)
                   (plus c a)
                   (commutative_plus a c)))
             (minus (plus c a) (plus c (minus b c)))
             (minus_plus (plus c a) c (minus b c)))
          (plus (minus b c) c)
          (commutative_plus (minus b c) c))
       (plus a c)
       (commutative_plus a c))
    b
    (plus_minus_m_m b c H).

def minus_plus_plus_l :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat
             (x1 => logic.eq nat (minus (plus x x1) (plus x0 x1)) (minus x x0)))))
  :=
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  h:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  logic.rewrite_l
    nat
    (minus (minus (plus x h) y) h)
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq nat __ (minus x y))
    (logic.rewrite_r
       nat
       (minus x y)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat __ (minus x y))
       (logic.refl nat (minus x y))
       (minus (minus (plus x h) y) h)
       (logic.rewrite_r
          nat
          (minus (plus x h) h)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat)) =>
           logic.eq nat (minus (minus (plus x h) y) h) (minus __ y))
          (minus_minus_comm (plus x h) y h)
          x
          (minus_plus_m_m x h)))
    (minus (plus x h) (plus y h))
    (minus_plus (plus x h) y h).

eqb :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool)))).

eqb_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool)))).

axiom_eqb :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (eqb x)
          (filter_nat_type
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
             eqb_body
             x))).

def eq_eqb :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (eqb x)
          (filter_nat_type
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
             eqb_body
             x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (eqb n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)) eqb_body n)
    (axiom_eqb n).

def sym_eq_eqb :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (filter_nat_type
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
             eqb_body
             x)
          (eqb x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (eqb n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)) eqb_body n)
    (eq_eqb n).

axiom_eqb_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
       (eqb_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        match_nat_type
          bool.bool
          bool.true
          (q:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           bool.false)
          m)).

def eq_eqb_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
       (eqb_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        match_nat_type
          bool.bool
          bool.true
          (q:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           bool.false)
          m))
  :=
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (eqb_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       bool.bool
       bool.true
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        bool.false)
       m)
    axiom_eqb_body_O.

def sym_eq_eqb_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        match_nat_type
          bool.bool
          bool.true
          (q:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           bool.false)
          m)
       (eqb_body O))
  :=
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (eqb_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       bool.bool
       bool.true
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        bool.false)
       m)
    eq_eqb_body_O.

axiom_eqb_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (eqb_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             bool.bool
             bool.false
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              eqb x q)
             m))).

def eq_eqb_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (eqb_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             bool.bool
             bool.false
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              eqb x q)
             m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (eqb_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       bool.bool
       bool.false
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        eqb n q)
       m)
    (axiom_eqb_body_S n).

def sym_eq_eqb_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             bool.bool
             bool.false
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              eqb x q)
             m)
          (eqb_body (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (eqb_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       bool.bool
       bool.false
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        eqb n q)
       m)
    (eq_eqb_body_S n).

def eqb_elim :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x1 => cts.univ cts.star cts.box cts.I))
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat x x0)
                   (x2 => x1 bool.true))
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (logic.eq nat x x0))
                      (x3 => x1 bool.false))
                   (x3 => x1 (eqb x x0)))))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I bool.bool (x => cts.univ cts.star cts.box cts.I))
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat __ _0) (x0 => x bool.true))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (connectives.Not (logic.eq nat __ _0))
                (x1 => x bool.false))
             (x1 => x (eqb __ _0)))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_prop
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I bool.bool (x => cts.univ cts.star cts.box cts.I))
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat O __) (x0 => x bool.true))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (logic.eq nat O __))
                   (x1 => x bool.false))
                (x1 => x (eqb O __)))))
       (sym_eq_eqb
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat O O) (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (logic.eq nat O O))
                      (x1 => x bool.false))
                   (x1 => x (y O)))))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
             eqb_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat O O)
                      (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (logic.eq nat O O))
                         (x1 => x bool.false))
                      (x1 => x (y O)))))
             (sym_eq_eqb_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x => cts.univ cts.star cts.box cts.I))
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat O O)
                         (x0 => x bool.true))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (logic.eq nat O O))
                            (x1 => x bool.false))
                         (x1 => x (y O)))))
                (sym_eq_match_nat_type_O
                   bool.bool
                   bool.true
                   (q:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    bool.false)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x => cts.univ cts.star cts.box cts.I))
                      (x =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat O O)
                            (x0 => x bool.true))
                         (x0 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (logic.eq nat O O))
                               (x1 => x bool.false))
                            (x1 => x y))))
                   (P:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               bool.bool
                               (x => cts.univ cts.star cts.box cts.I)))) =>
                    auto:(cts.Term
                            cts.star
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (logic.eq nat O O)
                               (x => P bool.true))) =>
                    auto':(cts.Term
                             cts.star
                             (cts.prod
                                cts.star
                                cts.star
                                cts.star
                                cts.I
                                (connectives.Not (logic.eq nat O O))
                                (x => P bool.false))) =>
                    auto (logic.refl nat O))))))
       (auto:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
        sym_eq_eqb
          O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat O (S auto))
                   (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (logic.eq nat O (S auto)))
                      (x1 => x bool.false))
                   (x1 => x (y (S auto))))))
          (sym_eq_filter_nat_type_O
             (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
             eqb_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat O (S auto))
                      (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (logic.eq nat O (S auto)))
                         (x1 => x bool.false))
                      (x1 => x (y (S auto))))))
             (sym_eq_eqb_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x => cts.univ cts.star cts.box cts.I))
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat O (S auto))
                         (x0 => x bool.true))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (logic.eq nat O (S auto)))
                            (x1 => x bool.false))
                         (x1 => x (y (S auto))))))
                (sym_eq_match_nat_type_S
                   bool.bool
                   bool.true
                   (q:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat)) =>
                    bool.false)
                   auto
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x => cts.univ cts.star cts.box cts.I))
                      (x =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat O (S auto))
                            (x0 => x bool.true))
                         (x0 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (logic.eq nat O (S auto)))
                               (x1 => x bool.false))
                            (x1 => x y))))
                   (P:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               bool.bool
                               (x => cts.univ cts.star cts.box cts.I)))) =>
                    auto':(cts.Term
                             cts.star
                             (cts.prod
                                cts.star
                                cts.star
                                cts.star
                                cts.I
                                (logic.eq nat O (S auto))
                                (x => P bool.true))) =>
                    auto'':(cts.Term
                              cts.star
                              (cts.prod
                                 cts.star
                                 cts.star
                                 cts.star
                                 cts.I
                                 (connectives.Not (logic.eq nat O (S auto)))
                                 (x => P bool.false))) =>
                    auto'' (not_eq_O_S auto))))))
       n)
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_eqb
       (S n)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I bool.bool (x => cts.univ cts.star cts.box cts.I))
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat (S n) O) (x0 => x bool.true))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (logic.eq nat (S n) O))
                   (x1 => x bool.false))
                (x1 => x (y O)))))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          eqb_body
          n
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat (S n) O)
                   (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (logic.eq nat (S n) O))
                      (x1 => x bool.false))
                   (x1 => x (y O)))))
          (sym_eq_eqb_body_S
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat (S n) O)
                      (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (logic.eq nat (S n) O))
                         (x1 => x bool.false))
                      (x1 => x (y O)))))
             (sym_eq_match_nat_type_O
                bool.bool
                bool.false
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 eqb n q)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x => cts.univ cts.star cts.box cts.I))
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat (S n) O)
                         (x0 => x bool.true))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (logic.eq nat (S n) O))
                            (x1 => x bool.false))
                         (x1 => x y))))
                (P:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            bool.bool
                            (x => cts.univ cts.star cts.box cts.I)))) =>
                 auto:(cts.Term
                         cts.star
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat (S n) O)
                            (x => P bool.true))) =>
                 auto':(cts.Term
                          cts.star
                          (cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (connectives.Not (logic.eq nat (S n) O))
                             (x => P bool.false))) =>
                 auto' (logic.sym_not_eq nat O (S n) (not_eq_O_S n)))))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_eqb
       (S n)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (logic.eq nat n m) (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (logic.eq nat n m))
                      (x1 => x bool.false))
                   (x1 => x (eqb n m)))))
          (x =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x0 => cts.univ cts.star cts.box cts.I))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat (S n) (S m))
                   (x1 => x0 bool.true))
                (x1 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (logic.eq nat (S n) (S m)))
                      (x2 => x0 bool.false))
                   (x2 => x0 (y (S m)))))))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          eqb_body
          n
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat n m)
                      (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (logic.eq nat n m))
                         (x1 => x bool.false))
                      (x1 => x (eqb n m)))))
             (x =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x0 => cts.univ cts.star cts.box cts.I))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat (S n) (S m))
                      (x1 => x0 bool.true))
                   (x1 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (logic.eq nat (S n) (S m)))
                         (x2 => x0 bool.false))
                      (x2 => x0 (y (S m)))))))
          (sym_eq_eqb_body_S
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x => cts.univ cts.star cts.box cts.I))
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat n m)
                         (x0 => x bool.true))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (logic.eq nat n m))
                            (x1 => x bool.false))
                         (x1 => x (eqb n m)))))
                (x =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x0 => cts.univ cts.star cts.box cts.I))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat (S n) (S m))
                         (x1 => x0 bool.true))
                      (x1 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (logic.eq nat (S n) (S m)))
                            (x2 => x0 bool.false))
                         (x2 => x0 (y (S m)))))))
             (sym_eq_match_nat_type_S
                bool.bool
                bool.false
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 eqb n q)
                m
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x => cts.univ cts.star cts.box cts.I))
                      (x =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat n m)
                            (x0 => x bool.true))
                         (x0 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (logic.eq nat n m))
                               (x1 => x bool.false))
                            (x1 => x (eqb n m)))))
                   (x =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x0 => cts.univ cts.star cts.box cts.I))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat (S n) (S m))
                            (x1 => x0 bool.true))
                         (x1 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (logic.eq nat (S n) (S m)))
                               (x2 => x0 bool.false))
                            (x2 => x0 y)))))
                (auto:(cts.Term
                         cts.star
                         (cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               bool.bool
                               (x => cts.univ cts.star cts.box cts.I))
                            (x =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (logic.eq nat n m)
                                  (x0 => x bool.true))
                               (x0 =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (connectives.Not (logic.eq nat n m))
                                     (x1 => x bool.false))
                                  (x1 => x (eqb n m)))))) =>
                 P:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            bool.bool
                            (x => cts.univ cts.star cts.box cts.I)))) =>
                 auto':(cts.Term
                          cts.star
                          (cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (logic.eq nat (S n) (S m))
                             (x => P bool.true))) =>
                 auto'':(cts.Term
                           cts.star
                           (cts.prod
                              cts.star
                              cts.star
                              cts.star
                              cts.I
                              (connectives.Not (logic.eq nat (S n) (S m)))
                              (x => P bool.false))) =>
                 auto
                   P
                   (auto''':(cts.Term cts.star (logic.eq nat n m)) =>
                    auto'
                      (logic.rewrite_l
                         nat
                         n
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat)) =>
                          logic.eq nat (S n) (S __))
                         (logic.refl nat (S n))
                         m
                         auto'''))
                   (auto''':(cts.Term cts.star (connectives.Not (logic.eq nat n m))) =>
                    auto'' (not_eq_S n m auto'''))))))).

def eqb_n_n :
  cts.Term
    cts.star
    (cts.prod cts.box cts.star cts.star cts.I nat (x => logic.eq bool.bool (eqb x x) bool.true))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat)) =>
     logic.eq bool.bool (eqb _x_365 _x_365) bool.true)
    (sym_eq_eqb
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        logic.eq bool.bool (y O) bool.true)
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          eqb_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           logic.eq bool.bool (y O) bool.true)
          (sym_eq_eqb_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              logic.eq bool.bool (y O) bool.true)
             (sym_eq_match_nat_type_O
                bool.bool
                bool.true
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 bool.false)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 logic.eq bool.bool y bool.true)
                (logic.refl bool.bool bool.true)))))
    (x_366:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
     sym_eq_eqb
       (S x_366)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (logic.eq bool.bool (eqb x_366 x_366) bool.true)
          (x => logic.eq bool.bool (y (S x_366)) bool.true))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          eqb_body
          x_366
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq bool.bool (eqb x_366 x_366) bool.true)
             (x => logic.eq bool.bool (y (S x_366)) bool.true))
          (sym_eq_eqb_body_S
             x_366
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq bool.bool (eqb x_366 x_366) bool.true)
                (x => logic.eq bool.bool (y (S x_366)) bool.true))
             (sym_eq_match_nat_type_S
                bool.bool
                bool.false
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 eqb x_366 q)
                x_366
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq bool.bool (eqb x_366 x_366) bool.true)
                   (x => logic.eq bool.bool y bool.true))
                (_x_368:(cts.Term cts.star (logic.eq bool.bool (eqb x_366 x_366) bool.true)) =>
                 logic.rewrite_r
                   bool.bool
                   bool.true
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             bool.bool)) =>
                    logic.eq bool.bool __ bool.true)
                   (logic.refl bool.bool bool.true)
                   (eqb x_366 x_366)
                   _x_368)))))
    n.

def eqb_true_to_eq :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq bool.bool (eqb x x0) bool.true)
             (x1 => logic.eq nat x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  eqb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (logic.eq bool.bool __ bool.true)
       (x => logic.eq nat n m))
    (auto:(cts.Term cts.star (logic.eq nat n m)) =>
     auto':(cts.Term cts.star (logic.eq bool.bool bool.true bool.true)) =>
     logic.rewrite_l
       nat
       n
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat)) =>
        logic.eq nat n __)
       (logic.refl nat n)
       m
       auto)
    (__:(cts.Term cts.star (connectives.Not (logic.eq nat n m))) =>
     abs:(cts.Term cts.star (logic.eq bool.bool bool.false bool.true)) =>
     connectives.falsity
       (logic.eq nat n m)
       (logic.absurd
          (logic.eq bool.bool bool.true bool.false)
          (logic.rewrite_r
             bool.bool
             bool.true
             (__1:(cts.Term
                     cts.diamond
                     (cts.cast
                        cts.triangle
                        cts.sinf
                        (cts.univ cts.box cts.triangle cts.I)
                        (cts.univ cts.diamond cts.sinf cts.I)
                        cts.I
                        bool.bool)) =>
              logic.eq bool.bool bool.true __1)
             (logic.refl bool.bool bool.true)
             bool.false
             abs)
          bool.not_eq_true_false)).

def eqb_false_to_not_eq :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq bool.bool (eqb x x0) bool.false)
             (x1 => connectives.Not (logic.eq nat x x0)))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  eqb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (logic.eq bool.bool __ bool.false)
       (x => connectives.Not (logic.eq nat n m)))
    (auto:(cts.Term cts.star (logic.eq nat n m)) =>
     auto':(cts.Term cts.star (logic.eq bool.bool bool.true bool.false)) =>
     logic.not_to_not
       (logic.eq nat n m)
       (logic.eq bool.bool bool.true bool.false)
       (auto'':(cts.Term cts.star (logic.eq nat n m)) =>
        logic.rewrite_l
          bool.bool
          bool.true
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    bool.bool)) =>
           logic.eq bool.bool bool.true __)
          (logic.refl bool.bool bool.true)
          bool.false
          auto')
       bool.not_eq_true_false)
    (auto:(cts.Term cts.star (connectives.Not (logic.eq nat n m))) =>
     auto':(cts.Term cts.star (logic.eq bool.bool bool.false bool.false)) => auto).

def eq_to_eqb_true :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat x x0)
             (x1 => logic.eq bool.bool (eqb x x0) bool.true))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  auto:(cts.Term cts.star (logic.eq nat n m)) =>
  logic.rewrite_l
    nat
    n
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     logic.eq bool.bool (eqb n __) bool.true)
    (logic.rewrite_r
       bool.bool
       bool.true
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 bool.bool)) =>
        logic.eq bool.bool __ bool.true)
       (logic.refl bool.bool bool.true)
       (eqb n n)
       (eqb_n_n n))
    m
    auto.

def not_eq_to_eqb_false :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (logic.eq nat x x0))
             (x1 => logic.eq bool.bool (eqb x x0) bool.false))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  noteq:(cts.Term cts.star (connectives.Not (logic.eq nat n m))) =>
  eqb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     logic.eq bool.bool __ bool.false)
    (Heq:(cts.Term cts.star (logic.eq nat n m)) =>
     connectives.falsity
       (logic.eq bool.bool bool.true bool.false)
       (logic.absurd
          (logic.eq nat n m)
          (logic.rewrite_l
             nat
             n
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat)) =>
              logic.eq nat n __)
             (logic.refl nat n)
             m
             Heq)
          noteq))
    (auto:(cts.Term cts.star (connectives.Not (logic.eq nat n m))) => logic.refl bool.bool bool.false).

leb :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool)))).

leb_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool)))).

axiom_leb :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (leb x)
          (filter_nat_type
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
             leb_body
             x))).

def eq_leb :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (leb x)
          (filter_nat_type
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
             leb_body
             x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (leb n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)) leb_body n)
    (axiom_leb n).

def sym_eq_leb :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (filter_nat_type
             (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
             leb_body
             x)
          (leb x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (leb n)
    (filter_nat_type (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)) leb_body n)
    (eq_leb n).

axiom_leb_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
       (leb_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        bool.true)).

def eq_leb_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
       (leb_body O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        bool.true))
  :=
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (leb_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     bool.true)
    axiom_leb_body_O.

def sym_eq_leb_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        bool.true)
       (leb_body O))
  :=
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (leb_body O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     bool.true)
    eq_leb_body_O.

axiom_leb_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        connectives.equal
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (leb_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             bool.bool
             bool.false
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              leb x q)
             m))).

def eq_leb_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (leb_body (S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             bool.bool
             bool.false
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              leb x q)
             m)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  connectives.equal_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (leb_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       bool.bool
       bool.false
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        leb n q)
       m)
    (axiom_leb_body_S n).

def sym_eq_leb_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        leibniz.leibniz
          (cts.prod cts.box cts.box cts.box cts.I nat (x0 => bool.bool))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat)) =>
           match_nat_type
             bool.bool
             bool.false
             (q:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat)) =>
              leb x q)
             m)
          (leb_body (S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leibniz.sym_leibniz
    (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
    (leb_body (S n))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     match_nat_type
       bool.bool
       bool.false
       (q:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat)) =>
        leb n q)
       m)
    (eq_leb_body_S n).

def leb_elim :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x1 => cts.univ cts.star cts.box cts.I))
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (le x x0) (x2 => x1 bool.true))
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (le x x0))
                      (x3 => x1 bool.false))
                   (x3 => x1 (leb x x0)))))))
  :=
  nat_elim2
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     _0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I bool.bool (x => cts.univ cts.star cts.box cts.I))
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod cts.star cts.star cts.star cts.I (le __ _0) (x0 => x bool.true))
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (connectives.Not (le __ _0))
                (x1 => x bool.false))
             (x1 => x (leb __ _0)))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_leb
       O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I bool.bool (x => cts.univ cts.star cts.box cts.I))
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.star cts.star cts.star cts.I (le O n) (x0 => x bool.true))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (le O n))
                   (x1 => x bool.false))
                (x1 => x (y n)))))
       (sym_eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          leb_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (le O n) (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (le O n))
                      (x1 => x bool.false))
                   (x1 => x (y n)))))
          (sym_eq_leb_body_O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod cts.star cts.star cts.star cts.I (le O n) (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (le O n))
                         (x1 => x bool.false))
                      (x1 => x (y n)))))
             (P:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x => cts.univ cts.star cts.box cts.I)))) =>
              auto:(cts.Term
                      cts.star
                      (cts.prod cts.star cts.star cts.star cts.I (le O n) (x => P bool.true))) =>
              auto':(cts.Term
                       cts.star
                       (cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (connectives.Not (le O n))
                          (x => P bool.false))) =>
              auto (le_O_n n)))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_leb
       (S n)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I bool.bool (x => cts.univ cts.star cts.box cts.I))
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod cts.star cts.star cts.star cts.I (le (S n) O) (x0 => x bool.true))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (le (S n) O))
                   (x1 => x bool.false))
                (x1 => x (y O)))))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          leb_body
          n
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (le (S n) O) (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (le (S n) O))
                      (x1 => x bool.false))
                   (x1 => x (y O)))))
          (sym_eq_leb_body_S
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod cts.star cts.star cts.star cts.I (le (S n) O) (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (le (S n) O))
                         (x1 => x bool.false))
                      (x1 => x (y O)))))
             (sym_eq_match_nat_type_O
                bool.bool
                bool.false
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 leb n q)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x => cts.univ cts.star cts.box cts.I))
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le (S n) O)
                         (x0 => x bool.true))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (le (S n) O))
                            (x1 => x bool.false))
                         (x1 => x y))))
                (P:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            bool.bool
                            (x => cts.univ cts.star cts.box cts.I)))) =>
                 auto:(cts.Term
                         cts.star
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le (S n) O)
                            (x => P bool.true))) =>
                 auto':(cts.Term
                          cts.star
                          (cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (connectives.Not (le (S n) O))
                             (x => P bool.false))) =>
                 auto' (not_le_Sn_O n))))))
    (n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat)) =>
     sym_eq_leb
       (S n)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x => cts.univ cts.star cts.box cts.I))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (le n m) (x0 => x bool.true))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (le n m))
                      (x1 => x bool.false))
                   (x1 => x (leb n m)))))
          (x =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                bool.bool
                (x0 => cts.univ cts.star cts.box cts.I))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod cts.star cts.star cts.star cts.I (le (S n) (S m)) (x1 => x0 bool.true))
                (x1 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (connectives.Not (le (S n) (S m)))
                      (x2 => x0 bool.false))
                   (x2 => x0 (y (S m)))))))
       (sym_eq_filter_nat_type_S
          (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool))
          leb_body
          n
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x => cts.univ cts.star cts.box cts.I))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod cts.star cts.star cts.star cts.I (le n m) (x0 => x bool.true))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (le n m))
                         (x1 => x bool.false))
                      (x1 => x (leb n m)))))
             (x =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   bool.bool
                   (x0 => cts.univ cts.star cts.box cts.I))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (le (S n) (S m))
                      (x1 => x0 bool.true))
                   (x1 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (connectives.Not (le (S n) (S m)))
                         (x2 => x0 bool.false))
                      (x2 => x0 (y (S m)))))))
          (sym_eq_leb_body_S
             n
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat (x => bool.bool)))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x => cts.univ cts.star cts.box cts.I))
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod cts.star cts.star cts.star cts.I (le n m) (x0 => x bool.true))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (le n m))
                            (x1 => x bool.false))
                         (x1 => x (leb n m)))))
                (x =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      bool.bool
                      (x0 => cts.univ cts.star cts.box cts.I))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (le (S n) (S m))
                         (x1 => x0 bool.true))
                      (x1 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (connectives.Not (le (S n) (S m)))
                            (x2 => x0 bool.false))
                         (x2 => x0 (y (S m)))))))
             (sym_eq_match_nat_type_S
                bool.bool
                bool.false
                (q:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat)) =>
                 leb n q)
                m
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x => cts.univ cts.star cts.box cts.I))
                      (x =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le n m)
                            (x0 => x bool.true))
                         (x0 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (le n m))
                               (x1 => x bool.false))
                            (x1 => x (leb n m)))))
                   (x =>
                    cts.prod
                      cts.box
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         bool.bool
                         (x0 => cts.univ cts.star cts.box cts.I))
                      (x0 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (le (S n) (S m))
                            (x1 => x0 bool.true))
                         (x1 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (le (S n) (S m)))
                               (x2 => x0 bool.false))
                            (x2 => x0 y)))))
                (Hind:(cts.Term
                         cts.star
                         (cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               bool.bool
                               (x => cts.univ cts.star cts.box cts.I))
                            (x =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (le n m)
                                  (x0 => x bool.true))
                               (x0 =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (connectives.Not (le n m))
                                     (x1 => x bool.false))
                                  (x1 => x (leb n m)))))) =>
                 P:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            bool.bool
                            (x => cts.univ cts.star cts.box cts.I)))) =>
                 Pt:(cts.Term
                       cts.star
                       (cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (le (S n) (S m))
                          (x => P bool.true))) =>
                 Pf:(cts.Term
                       cts.star
                       (cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (connectives.Not (le (S n) (S m)))
                          (x => P bool.false))) =>
                 Hind
                   P
                   (lenm:(cts.Term cts.star (le n m)) => Pt (le_S_S n m lenm))
                   (nlenm:(cts.Term cts.star (connectives.Not (le n m))) =>
                    Pf (not_le_to_not_le_S_S n m nlenm))))))).

def leb_true_to_le :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq bool.bool (leb x x0) bool.true)
             (x1 => le x x0))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     cts.prod cts.star cts.star cts.star cts.I (logic.eq bool.bool __ bool.true) (x => le n m))
    (auto:(cts.Term cts.star (le n m)) =>
     auto':(cts.Term cts.star (logic.eq bool.bool bool.true bool.true)) => auto)
    (__:(cts.Term cts.star (connectives.Not (le n m))) =>
     abs:(cts.Term cts.star (logic.eq bool.bool bool.false bool.true)) =>
     connectives.falsity
       (le n m)
       (logic.absurd
          (logic.eq bool.bool bool.true bool.false)
          (logic.rewrite_r
             bool.bool
             bool.true
             (__1:(cts.Term
                     cts.diamond
                     (cts.cast
                        cts.triangle
                        cts.sinf
                        (cts.univ cts.box cts.triangle cts.I)
                        (cts.univ cts.diamond cts.sinf cts.I)
                        cts.I
                        bool.bool)) =>
              logic.eq bool.bool bool.true __1)
             (logic.refl bool.bool bool.true)
             bool.false
             abs)
          bool.not_eq_true_false)).

def le_to_leb_true :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (le x x0)
             (x1 => logic.eq bool.bool (leb x x0) bool.true))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     cts.prod cts.star cts.star cts.star cts.I (le n m) (x => logic.eq bool.bool __ bool.true))
    (auto:(cts.Term cts.star (le n m)) =>
     auto':(cts.Term cts.star (le n m)) => logic.refl bool.bool bool.true)
    (H:(cts.Term cts.star (connectives.Not (le n m))) =>
     H1:(cts.Term cts.star (le n m)) =>
     connectives.falsity (logic.eq bool.bool bool.false bool.true) (logic.absurd (le n m) H1 H)).

def not_le_to_leb_false :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (le x x0))
             (x1 => logic.eq bool.bool (leb x x0) bool.false))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat)) =>
  leb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (connectives.Not (le n m))
       (x => logic.eq bool.bool __ bool.false))
    (H:(cts.Term cts.star (le n m)) =>
     H1:(cts.Term cts.star (connectives.Not (le n m))) =>
     connectives.falsity (logic.eq bool.bool bool.true bool.false) (logic.absurd (le n m) H H1))
    (auto:(cts.Term cts.star (connectives.Not (le n m))) =>
     auto':(cts.Term cts.star (connectives.Not (le n m))) => logic.refl bool.bool bool.false).

