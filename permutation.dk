def injn :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x =>
           cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => cts.univ cts.star cts.box cts.I))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  cts.prod
    cts.box
    cts.star
    cts.star
    cts.I
    nat.nat
    (x =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x0 =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x n)
          (x1 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x0 n)
             (x2 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (f x) (f x0))
                (x3 => logic.eq nat.nat x x0))))).

def injn_Sn_n :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 => cts.prod cts.star cts.star cts.star cts.I (injn x (nat.S x0)) (x1 => injn x x0))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  H:(cts.Term cts.star (injn f (nat.S n))) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lei:(cts.Term cts.star (nat.le i n)) =>
  lej:(cts.Term cts.star (nat.le j n)) =>
  eqf:(cts.Term cts.star (logic.eq nat.nat (f i) (f j))) =>
  H
    i
    j
    (nat.le_S i n lei)
    (nat.le_S j n lej)
    (logic.rewrite_l
       nat.nat
       (f i)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        logic.eq nat.nat (f i) __)
       (logic.refl nat.nat (f i))
       (f j)
       eqf).

def permut :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x =>
           cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => cts.univ cts.star cts.box cts.I))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.And
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x => cts.prod cts.star cts.star cts.star cts.I (nat.le x m) (x0 => nat.le (f x) m)))
    (injn f m).

def transpose :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))))
  :=
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n (nat.eqb n j)) (nat.eqb n i).

def transpose_i_j_i :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 => logic.eq nat.nat (transpose x x0 x) x0)))
  :=
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  logic.eq_ind_r
    bool.bool
    bool.true
    (x:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             bool.bool)) =>
     logic.eq
       nat.nat
       (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i i (nat.eqb i j)) x)
       j)
    (bool.eq_match_bool_type_true
       nat.nat
       j
       (bool.match_bool_type nat.nat i i (nat.eqb i j))
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type nat.nat i i (nat.eqb i j))
             bool.true)
          y)
       (logic.refl
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type nat.nat i i (nat.eqb i j))
             bool.true)))
    (nat.eqb i i)
    (nat.eqb_n_n i).

def transpose_i_j_j :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 => logic.eq nat.nat (transpose x x0 x0) x)))
  :=
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb j i) bool.true)
    (logic.eq bool.bool (nat.eqb j i) bool.false)
    (logic.eq
       nat.nat
       (bool.match_bool_type
          nat.nat
          j
          (bool.match_bool_type nat.nat i j (nat.eqb j j))
          (nat.eqb j i))
       i)
    (Hc:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.true)) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i j (nat.eqb j j)) x)
          i)
       (bool.sym_eq_match_bool_type_true
          nat.nat
          j
          (bool.match_bool_type nat.nat i j (nat.eqb j j))
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           logic.eq nat.nat y i)
          (logic.eq_ind_r
             nat.nat
             i
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq nat.nat x i)
             (logic.refl nat.nat i)
             j
             (nat.eqb_true_to_eq j i Hc)))
       (nat.eqb j i)
       Hc)
    (Hc:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.false)) =>
     logic.eq_ind_r
       bool.bool
       bool.false
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i j (nat.eqb j j)) x)
          i)
       (logic.eq_ind_r
          bool.bool
          bool.true
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   bool.bool)) =>
           logic.eq
             nat.nat
             (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i j x) bool.false)
             i)
          (bool.sym_eq_match_bool_type_false
             nat.nat
             j
             (bool.match_bool_type nat.nat i j bool.true)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq nat.nat y i)
             (bool.eq_match_bool_type_true
                nat.nat
                i
                j
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq nat.nat (bool.match_bool_type nat.nat i j bool.true) y)
                (bool.eq_match_bool_type_false
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i j bool.true)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq nat.nat (bool.match_bool_type nat.nat i j bool.true) y)
                   (bool.eq_match_bool_type_false
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i j bool.true)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq
                         nat.nat
                         y
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j bool.true)
                            bool.false))
                      (logic.refl
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j bool.true)
                            bool.false))))))
          (nat.eqb j j)
          (nat.eqb_n_n j))
       (nat.eqb j i)
       Hc)
    (bool.true_or_false (nat.eqb j i)).

def transpose_i_j_j_i :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 => logic.eq nat.nat (transpose x x0 x1) (transpose x0 x x1)))))
  :=
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb n i) bool.true)
    (logic.eq bool.bool (nat.eqb n i) bool.false)
    (logic.eq
       nat.nat
       (bool.match_bool_type
          nat.nat
          j
          (bool.match_bool_type nat.nat i n (nat.eqb n j))
          (nat.eqb n i))
       (bool.match_bool_type
          nat.nat
          i
          (bool.match_bool_type nat.nat j n (nat.eqb n i))
          (nat.eqb n j)))
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.true)) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n (nat.eqb n j)) x)
          (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n x) (nat.eqb n j)))
       (connectives.match_Or_prop
          (logic.eq bool.bool (nat.eqb n j) bool.true)
          (logic.eq bool.bool (nat.eqb n j) bool.false)
          (logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                bool.true)
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type nat.nat j n bool.true)
                (nat.eqb n j)))
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.true)) =>
           logic.eq_ind_r
             bool.bool
             bool.true
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      bool.bool)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.true)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.true) x))
             (bool.sym_eq_match_bool_type_true
                nat.nat
                j
                (bool.match_bool_type nat.nat i n bool.true)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   y
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.true)
                      bool.true))
                (bool.sym_eq_match_bool_type_true
                   nat.nat
                   i
                   (bool.match_bool_type nat.nat j n bool.true)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq nat.nat j y)
                   (logic.eq_ind
                      nat.nat
                      n
                      (x_1:(cts.Term
                              cts.diamond
                              (cts.cast
                                 cts.triangle
                                 cts.sinf
                                 (cts.univ cts.box cts.triangle cts.I)
                                 (cts.univ cts.diamond cts.sinf cts.I)
                                 cts.I
                                 nat.nat)) =>
                       logic.eq nat.nat j x_1)
                      (logic.eq_ind
                         nat.nat
                         n
                         (x_1:(cts.Term
                                 cts.diamond
                                 (cts.cast
                                    cts.triangle
                                    cts.sinf
                                    (cts.univ cts.box cts.triangle cts.I)
                                    (cts.univ cts.diamond cts.sinf cts.I)
                                    cts.I
                                    nat.nat)) =>
                          logic.eq nat.nat x_1 n)
                         (logic.refl nat.nat n)
                         j
                         (nat.eqb_true_to_eq n j Hnj))
                      i
                      (nat.eqb_true_to_eq n i Hni))))
             (nat.eqb n j)
             Hnj)
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.false)) =>
           logic.eq_ind_r
             bool.bool
             bool.false
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      bool.bool)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.true)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.true) x))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                i
                n
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat j y bool.true)
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.true)
                      bool.false))
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   i
                   (bool.match_bool_type nat.nat j n bool.true)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq nat.nat (bool.match_bool_type nat.nat j n bool.true) y)
                   (bool.sym_eq_match_bool_type_true
                      nat.nat
                      j
                      n
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat j n bool.true) y)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         j
                         n
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat y j)
                         (logic.refl nat.nat j)))))
             (nat.eqb n j)
             Hnj)
          (bool.true_or_false (nat.eqb n j)))
       (nat.eqb n i)
       Hni)
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.false)) =>
     logic.eq_ind_r
       bool.bool
       bool.false
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n (nat.eqb n j)) x)
          (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n x) (nat.eqb n j)))
       (connectives.match_Or_prop
          (logic.eq bool.bool (nat.eqb n j) bool.true)
          (logic.eq bool.bool (nat.eqb n j) bool.false)
          (logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                bool.false)
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type nat.nat j n bool.false)
                (nat.eqb n j)))
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.true)) =>
           logic.eq_ind_r
             bool.bool
             bool.true
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      bool.bool)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.false)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.false) x))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                j
                (bool.match_bool_type nat.nat i n bool.true)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   y
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.false)
                      bool.true))
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   j
                   n
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type nat.nat i n bool.true)
                      (bool.match_bool_type nat.nat i y bool.true))
                   (bool.sym_eq_match_bool_type_true
                      nat.nat
                      i
                      n
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat i n bool.true) y)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         i
                         n
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat y i)
                         (logic.refl nat.nat i)))))
             (nat.eqb n j)
             Hnj)
          (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.false)) =>
           logic.eq_ind_r
             bool.bool
             bool.false
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      bool.bool)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat j (bool.match_bool_type nat.nat i n x) bool.false)
                (bool.match_bool_type nat.nat i (bool.match_bool_type nat.nat j n bool.false) x))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                i
                n
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat j y bool.false)
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type nat.nat j n bool.false)
                      bool.false))
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   j
                   n
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type nat.nat j n bool.false)
                      (bool.match_bool_type nat.nat i y bool.false))
                   (bool.sym_eq_match_bool_type_false
                      nat.nat
                      j
                      n
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq nat.nat y (bool.match_bool_type nat.nat i n bool.false))
                      (bool.sym_eq_match_bool_type_false
                         nat.nat
                         i
                         n
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat n y)
                         (logic.refl nat.nat n)))))
             (nat.eqb n j)
             Hnj)
          (bool.true_or_false (nat.eqb n j)))
       (nat.eqb n i)
       Hni)
    (bool.true_or_false (nat.eqb n i)).

def transpose_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 => logic.eq nat.nat (transpose x x0 (transpose x x0 x1)) x1))))
  :=
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb n i) bool.true)
    (logic.eq bool.bool (nat.eqb n i) bool.false)
    (logic.eq
       nat.nat
       (bool.match_bool_type
          nat.nat
          j
          (bool.match_bool_type
             nat.nat
             i
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (nat.eqb n i))
             (nat.eqb
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   (nat.eqb n i))
                j))
          (nat.eqb
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (nat.eqb n i))
             i))
       n)
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.true)) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                (nat.eqb
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      x)
                   j))
             (nat.eqb
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                i))
          n)
       (bool.sym_eq_match_bool_type_true
          nat.nat
          j
          (bool.match_bool_type nat.nat i n (nat.eqb n j))
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type
                   nat.nat
                   i
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      bool.true)
                   (nat.eqb
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.true)
                      j))
                (nat.eqb y i))
             n)
          (bool.sym_eq_match_bool_type_true
             nat.nat
             j
             (bool.match_bool_type nat.nat i n (nat.eqb n j))
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.true)
                      (nat.eqb y j))
                   (nat.eqb j i))
                n)
             (bool.sym_eq_match_bool_type_true
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i y (nat.eqb j j))
                      (nat.eqb j i))
                   n)
                (connectives.match_Or_prop
                   (logic.eq bool.bool (nat.eqb j i) bool.true)
                   (logic.eq bool.bool (nat.eqb j i) bool.false)
                   (logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i j (nat.eqb j j))
                         (nat.eqb j i))
                      n)
                   (Hji:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.true)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.true
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               bool.bool)) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j (nat.eqb j j))
                            x)
                         n)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i j (nat.eqb j j))
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat y n)
                         (logic.eq_ind_r
                            nat.nat
                            i
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             logic.eq nat.nat j x)
                            (nat.eqb_true_to_eq j i Hji)
                            n
                            (nat.eqb_true_to_eq n i Hni)))
                      (nat.eqb j i)
                      Hji)
                   (Hji:(cts.Term cts.star (logic.eq bool.bool (nat.eqb j i) bool.false)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.false
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               bool.bool)) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i j (nat.eqb j j))
                            x)
                         n)
                      (bool.sym_eq_match_bool_type_false
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i j (nat.eqb j j))
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat y n)
                         (logic.eq_ind_r
                            bool.bool
                            bool.true
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     bool.bool)) =>
                             logic.eq nat.nat (bool.match_bool_type nat.nat i j x) n)
                            (bool.sym_eq_match_bool_type_true
                               nat.nat
                               i
                               j
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                logic.eq nat.nat y n)
                               (logic.sym_eq nat.nat n i (nat.eqb_true_to_eq n i Hni)))
                            (nat.eqb j j)
                            (nat.eqb_n_n j)))
                      (nat.eqb j i)
                      Hji)
                   (bool.true_or_false (nat.eqb j i))))))
       (nat.eqb n i)
       Hni)
    (Hni:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n i) bool.false)) =>
     logic.eq_ind_r
       bool.bool
       bool.false
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type
             nat.nat
             j
             (bool.match_bool_type
                nat.nat
                i
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                (nat.eqb
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      x)
                   j))
             (nat.eqb
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type nat.nat i n (nat.eqb n j))
                   x)
                i))
          n)
       (bool.sym_eq_match_bool_type_false
          nat.nat
          j
          (bool.match_bool_type nat.nat i n (nat.eqb n j))
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           logic.eq
             nat.nat
             (bool.match_bool_type
                nat.nat
                j
                (bool.match_bool_type
                   nat.nat
                   i
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i n (nat.eqb n j))
                      bool.false)
                   (nat.eqb
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.false)
                      j))
                (nat.eqb y i))
             n)
          (bool.sym_eq_match_bool_type_false
             nat.nat
             j
             (bool.match_bool_type nat.nat i n (nat.eqb n j))
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type
                   nat.nat
                   j
                   (bool.match_bool_type
                      nat.nat
                      i
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i n (nat.eqb n j))
                         bool.false)
                      (nat.eqb y j))
                   (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) i))
                n)
             (bool.sym_eq_match_bool_type_false
                nat.nat
                j
                (bool.match_bool_type nat.nat i n (nat.eqb n j))
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type
                         nat.nat
                         i
                         y
                         (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) j))
                      (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) i))
                   n)
                (connectives.match_Or_prop
                   (logic.eq bool.bool (nat.eqb n j) bool.true)
                   (logic.eq bool.bool (nat.eqb n j) bool.false)
                   (logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type
                            nat.nat
                            i
                            (bool.match_bool_type nat.nat i n (nat.eqb n j))
                            (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) j))
                         (nat.eqb (bool.match_bool_type nat.nat i n (nat.eqb n j)) i))
                      n)
                   (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.true)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.true
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               bool.bool)) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type
                               nat.nat
                               i
                               (bool.match_bool_type nat.nat i n x)
                               (nat.eqb (bool.match_bool_type nat.nat i n x) j))
                            (nat.eqb (bool.match_bool_type nat.nat i n x) i))
                         n)
                      (bool.sym_eq_match_bool_type_true
                         nat.nat
                         i
                         n
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type
                                  nat.nat
                                  i
                                  (bool.match_bool_type nat.nat i n bool.true)
                                  (nat.eqb (bool.match_bool_type nat.nat i n bool.true) j))
                               (nat.eqb y i))
                            n)
                         (bool.sym_eq_match_bool_type_true
                            nat.nat
                            i
                            n
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             logic.eq
                               nat.nat
                               (bool.match_bool_type
                                  nat.nat
                                  j
                                  (bool.match_bool_type
                                     nat.nat
                                     i
                                     (bool.match_bool_type nat.nat i n bool.true)
                                     (nat.eqb y j))
                                  (nat.eqb i i))
                               n)
                            (bool.sym_eq_match_bool_type_true
                               nat.nat
                               i
                               n
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                logic.eq
                                  nat.nat
                                  (bool.match_bool_type
                                     nat.nat
                                     j
                                     (bool.match_bool_type nat.nat i y (nat.eqb i j))
                                     (nat.eqb i i))
                                  n)
                               (logic.eq_ind_r
                                  bool.bool
                                  bool.true
                                  (x:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           bool.bool)) =>
                                   logic.eq
                                     nat.nat
                                     (bool.match_bool_type
                                        nat.nat
                                        j
                                        (bool.match_bool_type nat.nat i i (nat.eqb i j))
                                        x)
                                     n)
                                  (bool.sym_eq_match_bool_type_true
                                     nat.nat
                                     j
                                     (bool.match_bool_type nat.nat i i (nat.eqb i j))
                                     (y:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat.nat)) =>
                                      logic.eq nat.nat y n)
                                     (logic.sym_eq
                                        nat.nat
                                        n
                                        j
                                        (nat.eqb_true_to_eq n j Hnj)))
                                  (nat.eqb i i)
                                  (nat.eqb_n_n i)))))
                      (nat.eqb n j)
                      Hnj)
                   (Hnj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb n j) bool.false)) =>
                    logic.eq_ind_r
                      bool.bool
                      bool.false
                      (x:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               bool.bool)) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type
                               nat.nat
                               i
                               (bool.match_bool_type nat.nat i n x)
                               (nat.eqb (bool.match_bool_type nat.nat i n x) j))
                            (nat.eqb (bool.match_bool_type nat.nat i n x) i))
                         n)
                      (bool.sym_eq_match_bool_type_false
                         nat.nat
                         i
                         n
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type
                                  nat.nat
                                  i
                                  (bool.match_bool_type nat.nat i n bool.false)
                                  (nat.eqb (bool.match_bool_type nat.nat i n bool.false) j))
                               (nat.eqb y i))
                            n)
                         (bool.sym_eq_match_bool_type_false
                            nat.nat
                            i
                            n
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             logic.eq
                               nat.nat
                               (bool.match_bool_type
                                  nat.nat
                                  j
                                  (bool.match_bool_type
                                     nat.nat
                                     i
                                     (bool.match_bool_type nat.nat i n bool.false)
                                     (nat.eqb y j))
                                  (nat.eqb n i))
                               n)
                            (bool.sym_eq_match_bool_type_false
                               nat.nat
                               i
                               n
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                logic.eq
                                  nat.nat
                                  (bool.match_bool_type
                                     nat.nat
                                     j
                                     (bool.match_bool_type nat.nat i y (nat.eqb n j))
                                     (nat.eqb n i))
                                  n)
                               (logic.eq_ind_r
                                  bool.bool
                                  bool.false
                                  (x:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           bool.bool)) =>
                                   logic.eq
                                     nat.nat
                                     (bool.match_bool_type
                                        nat.nat
                                        j
                                        (bool.match_bool_type nat.nat i n (nat.eqb n j))
                                        x)
                                     n)
                                  (logic.eq_ind_r
                                     bool.bool
                                     bool.false
                                     (x:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              bool.bool)) =>
                                      logic.eq
                                        nat.nat
                                        (bool.match_bool_type
                                           nat.nat
                                           j
                                           (bool.match_bool_type nat.nat i n x)
                                           bool.false)
                                        n)
                                     (bool.eq_match_bool_type_false
                                        nat.nat
                                        i
                                        n
                                        (y:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           (bool.match_bool_type
                                              nat.nat
                                              j
                                              (bool.match_bool_type
                                                 nat.nat
                                                 i
                                                 n
                                                 bool.false)
                                              bool.false)
                                           y)
                                        (bool.eq_match_bool_type_false
                                           nat.nat
                                           j
                                           (bool.match_bool_type nat.nat i n bool.false)
                                           (y:(cts.Term
                                                 cts.diamond
                                                 (cts.cast
                                                    cts.triangle
                                                    cts.sinf
                                                    (cts.univ
                                                       cts.box
                                                       cts.triangle
                                                       cts.I)
                                                    (cts.univ
                                                       cts.diamond
                                                       cts.sinf
                                                       cts.I)
                                                    cts.I
                                                    nat.nat)) =>
                                            logic.eq
                                              nat.nat
                                              (bool.match_bool_type
                                                 nat.nat
                                                 j
                                                 (bool.match_bool_type
                                                    nat.nat
                                                    i
                                                    n
                                                    bool.false)
                                                 bool.false)
                                              y)
                                           (logic.refl
                                              nat.nat
                                              (bool.match_bool_type
                                                 nat.nat
                                                 j
                                                 (bool.match_bool_type
                                                    nat.nat
                                                    i
                                                    n
                                                    bool.false)
                                                 bool.false))))
                                     (nat.eqb n j)
                                     Hnj)
                                  (nat.eqb n i)
                                  Hni))))
                      (nat.eqb n j)
                      Hnj)
                   (bool.true_or_false (nat.eqb n j))))))
       (nat.eqb n i)
       Hni)
    (bool.true_or_false (nat.eqb n i)).

def injective_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 => relations.injective_ nat.nat nat.nat (transpose x x0))))
  :=
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  x:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  y:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  auto:(cts.Term cts.star (logic.eq nat.nat (transpose i j x) (transpose i j y))) =>
  logic.rewrite_r
    nat.nat
    y
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat __ y)
    (logic.refl nat.nat y)
    x
    (logic.rewrite_l
       nat.nat
       (transpose i j (transpose i j x))
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        logic.eq nat.nat __ y)
       (logic.rewrite_r
          nat.nat
          (transpose i j y)
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat.nat)) =>
           logic.eq nat.nat (transpose i j __) y)
          (transpose_transpose i j y)
          (transpose i j x)
          auto)
       x
       (transpose_transpose i j x)).

def permut_S_to_permut_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permut x (nat.S x0))
             (x1 =>
              permut
                (n:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 transpose (x (nat.S x0)) (nat.S x0) (x n))
                x0))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme:(cts.Term cts.star (permut f (nat.S m))) =>
  connectives.match_And_prop
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x (nat.S m))
          (x0 => nat.le (f x) (nat.S m))))
    (injn f (nat.S m))
    (permut
       (n:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        transpose (f (nat.S m)) (nat.S m) (f n))
       m)
    (permf1:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat.nat
                  (x =>
                   cts.prod
                     cts.star
                     cts.star
                     cts.star
                     cts.I
                     (nat.le x (nat.S m))
                     (x0 => nat.le (f x) (nat.S m))))) =>
     permf2:(cts.Term cts.star (injn f (nat.S m))) =>
     connectives.conj
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x m)
             (x0 => nat.le (transpose (f (nat.S m)) (nat.S m) (f x)) m)))
       (injn
          (n:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           transpose (f (nat.S m)) (nat.S m) (f n))
          m)
       (i:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        leim:(cts.Term cts.star (nat.le i m)) =>
        logic.eq_ind_r
          bool.bool
          bool.false
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   bool.bool)) =>
           nat.le
             (bool.match_bool_type
                nat.nat
                (nat.S m)
                (bool.match_bool_type nat.nat (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))
                x)
             m)
          (bool.sym_eq_match_bool_type_false
             nat.nat
             (nat.S m)
             (bool.match_bool_type nat.nat (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              nat.le y m)
             (connectives.match_Or_prop
                (nat.lt (f i) (nat.S m))
                (logic.eq nat.nat (f i) (nat.S m))
                (nat.le
                   (bool.match_bool_type nat.nat (f (nat.S m)) (f i) (nat.eqb (f i) (nat.S m)))
                   m)
                (Hfi:(cts.Term cts.star (nat.lt (f i) (nat.S m))) =>
                 logic.eq_ind_r
                   bool.bool
                   bool.false
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    nat.le (bool.match_bool_type nat.nat (f (nat.S m)) (f i) x) m)
                   (bool.sym_eq_match_bool_type_false
                      nat.nat
                      (f (nat.S m))
                      (f i)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       nat.le y m)
                      (nat.le_S_S_to_le (f i) m Hfi))
                   (nat.eqb (f i) (nat.S m))
                   (nat.not_eq_to_eqb_false
                      (f i)
                      (nat.S m)
                      (nat.lt_to_not_eq (f i) (nat.S m) Hfi)))
                (Hfi:(cts.Term cts.star (logic.eq nat.nat (f i) (nat.S m))) =>
                 logic.eq_ind_r
                   bool.bool
                   bool.true
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    nat.le (bool.match_bool_type nat.nat (f (nat.S m)) (f i) x) m)
                   (bool.sym_eq_match_bool_type_true
                      nat.nat
                      (f (nat.S m))
                      (f i)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       nat.le y m)
                      (connectives.match_Or_prop
                         (nat.lt (f (nat.S m)) (nat.S m))
                         (logic.eq nat.nat (f (nat.S m)) (nat.S m))
                         (nat.le (f (nat.S m)) m)
                         (H:(cts.Term cts.star (nat.lt (f (nat.S m)) (nat.S m))) =>
                          nat.le_S_S_to_le (f (nat.S m)) m H)
                         (H:(cts.Term cts.star (logic.eq nat.nat (f (nat.S m)) (nat.S m))) =>
                          connectives.falsity
                            (nat.le (f (nat.S m)) m)
                            (logic.absurd
                               (logic.eq nat.nat i (nat.S m))
                               (permf2
                                  i
                                  (nat.S m)
                                  (nat.le_S i m leim)
                                  (nat.le_n (nat.S m))
                                  (logic.rewrite_l
                                     nat.nat
                                     (f i)
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat.nat)) =>
                                      logic.eq nat.nat (f i) (f __))
                                     (logic.rewrite_r
                                        nat.nat
                                        (f i)
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq nat.nat (f i) __)
                                        (logic.refl nat.nat (f i))
                                        (f (f i))
                                        (logic.rewrite_r
                                           nat.nat
                                           (nat.S m)
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat.nat)) =>
                                            logic.eq nat.nat (f (f i)) __)
                                           (logic.rewrite_r
                                              nat.nat
                                              (nat.S m)
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq nat.nat (f __) (nat.S m))
                                              H
                                              (f i)
                                              Hfi)
                                           (f i)
                                           Hfi))
                                     (nat.S m)
                                     Hfi))
                               (logic.not_to_not
                                  (logic.eq nat.nat i (nat.S m))
                                  (nat.le (nat.S m) m)
                                  (auto:(cts.Term
                                           cts.star
                                           (logic.eq nat.nat i (nat.S m))) =>
                                   logic.eq_coerc
                                     (nat.le i m)
                                     (nat.le (nat.S m) m)
                                     leim
                                     (logic.rewrite_l
                                        nat.nat
                                        i
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq
                                           (cts.univ cts.star cts.box cts.I)
                                           (nat.le i m)
                                           (nat.le __ m))
                                        (logic.refl
                                           (cts.univ cts.star cts.box cts.I)
                                           (nat.le i m))
                                        (nat.S m)
                                        auto))
                                  (nat.lt_to_not_le m (nat.S m) (nat.le_n (nat.S m))))))
                         (nat.le_to_or_lt_eq
                            (f (nat.S m))
                            (nat.S m)
                            (permf1 (nat.S m) (nat.le_n (nat.S m))))))
                   (nat.eqb (f i) (nat.S m))
                   (nat.eq_to_eqb_true (f i) (nat.S m) Hfi))
                (nat.le_to_or_lt_eq (f i) (nat.S m) (permf1 i (nat.le_S i m leim)))))
          (nat.eqb (f i) (f (nat.S m)))
          (nat.not_eq_to_eqb_false
             (f i)
             (f (nat.S m))
             (connectives.nmk
                (logic.eq nat.nat (f i) (f (nat.S m)))
                (H:(cts.Term cts.star (logic.eq nat.nat (f i) (f (nat.S m)))) =>
                 logic.absurd
                   (logic.eq nat.nat i (nat.S m))
                   (permf2 i (nat.S m) (nat.le_S i m leim) (nat.le_n (nat.S m)) H)
                   (nat.lt_to_not_eq i (nat.S m) (nat.le_S_S i m leim))))))
       (a:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        b:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        leam:(cts.Term cts.star (nat.le a m)) =>
        lebm:(cts.Term cts.star (nat.le b m)) =>
        H:(cts.Term
             cts.star
             (logic.eq
                nat.nat
                (transpose (f (nat.S m)) (nat.S m) (f a))
                (transpose (f (nat.S m)) (nat.S m) (f b)))) =>
        permf2
          a
          b
          (nat.le_S a m leam)
          (nat.le_S b m lebm)
          (injective_transpose (f (nat.S m)) (nat.S m) (f a) (f b) H)))
    _clearme.

def bijn :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x =>
           cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => cts.univ cts.star cts.box cts.I))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  cts.prod
    cts.box
    cts.star
    cts.star
    cts.I
    nat.nat
    (x =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (nat.le x n)
       (x0 =>
        connectives.ex
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (f p) x)))).

def eq_to_bijn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x2 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x2 x1)
                      (x3 => logic.eq nat.nat (x x2) (x0 x2))))
                (x2 => cts.prod cts.star cts.star cts.star cts.I (bijn x x1) (x3 => bijn x0 x1))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  g:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  H:(cts.Term
       cts.star
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x n)
             (x0 => logic.eq nat.nat (f x) (g x))))) =>
  bijf:(cts.Term cts.star (bijn f n)) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  connectives.match_ex_prop
    nat.nat
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
    (connectives.ex
       nat.nat
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le p n) (logic.eq nat.nat (g p) i)))
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
     connectives.match_And_prop
       (nat.le a n)
       (logic.eq nat.nat (f a) i)
       (connectives.ex
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (g p) i)))
       (lean:(cts.Term cts.star (nat.le a n)) =>
        fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le x n) (logic.eq nat.nat (g x) i))
          a
          (connectives.conj
             (nat.le a n)
             (logic.eq nat.nat (g a) i)
             lean
             (logic.eq_ind
                nat.nat
                (f a)
                (x_1:(cts.Term
                        cts.diamond
                        (cts.cast
                           cts.triangle
                           cts.sinf
                           (cts.univ cts.box cts.triangle cts.I)
                           (cts.univ cts.diamond cts.sinf cts.I)
                           cts.I
                           nat.nat)) =>
                 logic.eq nat.nat (g a) x_1)
                (logic.sym_eq nat.nat (f a) (g a) (H a lean))
                i
                fa)))
       _clearme)
    (bijf i lein).

def bijn_n_Sn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (bijn x x0)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (x (nat.S x0)) (nat.S x0))
                (x2 => bijn x (nat.S x0))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  bijf:(cts.Term cts.star (bijn f n)) =>
  fS:(cts.Term cts.star (logic.eq nat.nat (f (nat.S n)) (nat.S n))) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i (nat.S n))) =>
  connectives.match_Or_prop
    (nat.lt i (nat.S n))
    (logic.eq nat.nat i (nat.S n))
    (connectives.ex
       nat.nat
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le p (nat.S n)) (logic.eq nat.nat (f p) i)))
    (Hi:(cts.Term cts.star (nat.lt i (nat.S n))) =>
     connectives.match_ex_prop
       nat.nat
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
       (connectives.ex
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p (nat.S n)) (logic.eq nat.nat (f p) i)))
       (a:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
        connectives.match_And_prop
          (nat.le a n)
          (logic.eq nat.nat (f a) i)
          (connectives.ex
             nat.nat
             (p:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.And (nat.le p (nat.S n)) (logic.eq nat.nat (f p) i)))
          (lean:(cts.Term cts.star (nat.le a n)) =>
           fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
           connectives.ex_intro
             nat.nat
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.And (nat.le x (nat.S n)) (logic.eq nat.nat (f x) i))
             a
             (connectives.conj
                (nat.le a (nat.S n))
                (logic.eq nat.nat (f a) i)
                (nat.le_S a n lean)
                (logic.rewrite_r
                   nat.nat
                   i
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq nat.nat __ i)
                   (logic.refl nat.nat i)
                   (f a)
                   fa)))
          _clearme)
       (bijf i (nat.le_S_S_to_le i n Hi)))
    (Hi:(cts.Term cts.star (logic.eq nat.nat i (nat.S n))) =>
     connectives.ex_intro
       nat.nat
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le x (nat.S n)) (logic.eq nat.nat (f x) i))
       i
       (connectives.conj
          (nat.le i (nat.S n))
          (logic.eq nat.nat (f i) i)
          (logic.eq_coerc
             (nat.le i i)
             (nat.le i (nat.S n))
             (nat.le_n i)
             (logic.rewrite_l
                nat.nat
                i
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (nat.le i i) (nat.le i __))
                (logic.refl (cts.univ cts.star cts.box cts.I) (nat.le i i))
                (nat.S n)
                Hi))
          (logic.rewrite_r
             nat.nat
             i
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat.nat)) =>
              logic.eq nat.nat __ i)
             (logic.refl nat.nat i)
             (f i)
             (logic.rewrite_r
                nat.nat
                (nat.S n)
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                 logic.eq nat.nat (f i) __)
                (logic.rewrite_r
                   nat.nat
                   (nat.S n)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq nat.nat (f __) (nat.S n))
                   fS
                   i
                   Hi)
                i
                Hi))))
    (nat.le_to_or_lt_eq i (nat.S n) lein).

def bijn_fg :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (bijn x x1)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (bijn x0 x1)
                   (x3 =>
                    bijn
                      (p:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       x (x0 p))
                      x1))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  g:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  bijf:(cts.Term cts.star (bijn f n)) =>
  bijg:(cts.Term cts.star (bijn g n)) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  connectives.match_ex_prop
    nat.nat
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
    (connectives.ex
       nat.nat
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
     connectives.match_And_prop
       (nat.le a n)
       (logic.eq nat.nat (f a) i)
       (connectives.ex
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
       (lean:(cts.Term cts.star (nat.le a n)) =>
        ga:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
        connectives.match_ex_prop
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (g p) a))
          (connectives.ex
             nat.nat
             (p:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
          (b:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           _clearme0:(cts.Term
                        cts.star
                        (connectives.And (nat.le b n) (logic.eq nat.nat (g b) a))) =>
           connectives.match_And_prop
             (nat.le b n)
             (logic.eq nat.nat (g b) a)
             (connectives.ex
                nat.nat
                (p:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.And (nat.le p n) (logic.eq nat.nat (f (g p)) i)))
             (lebn:(cts.Term cts.star (nat.le b n)) =>
              gb:(cts.Term cts.star (logic.eq nat.nat (g b) a)) =>
              connectives.ex_intro
                nat.nat
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.And (nat.le x n) (logic.eq nat.nat (f (g x)) i))
                b
                (connectives.conj
                   (nat.le b n)
                   (logic.eq nat.nat (f (g b)) i)
                   lebn
                   (logic.rewrite_r
                      nat.nat
                      a
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq nat.nat (f __) i)
                      (logic.rewrite_r
                         nat.nat
                         i
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq nat.nat __ i)
                         (logic.refl nat.nat i)
                         (f a)
                         ga)
                      (g b)
                      gb)))
             _clearme0)
          (bijg a lean))
       _clearme)
    (bijf i lein).

def bijn_transpose :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x0 x)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x1 x)
                   (x3 => bijn (transpose x0 x1) x))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lean:(cts.Term cts.star (nat.le a n)) =>
  connectives.match_Or_prop
    (logic.eq bool.bool (nat.eqb a i) bool.true)
    (logic.eq bool.bool (nat.eqb a i) bool.false)
    (connectives.ex
       nat.nat
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le p n) (logic.eq nat.nat (transpose i j p) a)))
    (Hi:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a i) bool.true)) =>
     connectives.ex_intro
       nat.nat
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.And (nat.le x n) (logic.eq nat.nat (transpose i j x) a))
       j
       (connectives.conj
          (nat.le j n)
          (logic.eq nat.nat (transpose i j j) a)
          lejn
          (logic.eq_ind_r
             nat.nat
             i
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq nat.nat x a)
             (logic.sym_eq nat.nat a i (nat.eqb_true_to_eq a i Hi))
             (transpose i j j)
             (transpose_i_j_j i j))))
    (Hi:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a i) bool.false)) =>
     connectives.match_Or_prop
       (logic.eq bool.bool (nat.eqb a j) bool.true)
       (logic.eq bool.bool (nat.eqb a j) bool.false)
       (connectives.ex
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (transpose i j p) a)))
       (Hj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a j) bool.true)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le x n) (logic.eq nat.nat (transpose i j x) a))
          i
          (connectives.conj
             (nat.le i n)
             (logic.eq nat.nat (transpose i j i) a)
             lein
             (logic.eq_ind_r
                nat.nat
                j
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq nat.nat x a)
                (logic.sym_eq nat.nat a j (nat.eqb_true_to_eq a j Hj))
                (transpose i j i)
                (transpose_i_j_i i j))))
       (Hj:(cts.Term cts.star (logic.eq bool.bool (nat.eqb a j) bool.false)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le x n) (logic.eq nat.nat (transpose i j x) a))
          a
          (connectives.conj
             (nat.le a n)
             (logic.eq nat.nat (transpose i j a) a)
             lean
             (logic.eq_ind_r
                bool.bool
                bool.false
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      j
                      (bool.match_bool_type nat.nat i a (nat.eqb a j))
                      x)
                   a)
                (logic.eq_ind_r
                   bool.bool
                   bool.false
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i a x)
                         bool.false)
                      a)
                   (bool.eq_match_bool_type_false
                      nat.nat
                      i
                      a
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            j
                            (bool.match_bool_type nat.nat i a bool.false)
                            bool.false)
                         y)
                      (bool.eq_match_bool_type_false
                         nat.nat
                         j
                         (bool.match_bool_type nat.nat i a bool.false)
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type nat.nat i a bool.false)
                               bool.false)
                            y)
                         (logic.refl
                            nat.nat
                            (bool.match_bool_type
                               nat.nat
                               j
                               (bool.match_bool_type nat.nat i a bool.false)
                               bool.false))))
                   (nat.eqb a j)
                   Hj)
                (nat.eqb a i)
                Hi)))
       (bool.true_or_false (nat.eqb a j)))
    (bool.true_or_false (nat.eqb a i)).

def permut_to_bijn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
          (x0 => cts.prod cts.star cts.star cts.star cts.I (permut x0 x) (x1 => bijn x0 x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  nat.nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat.nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.star cts.star cts.star cts.I (permut x _x_365) (x0 => bijn x _x_365)))
    (f:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
     _clearme:(cts.Term
                 cts.star
                 (connectives.And
                    (cts.prod
                       cts.box
                       cts.star
                       cts.star
                       cts.I
                       nat.nat
                       (x =>
                        cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (nat.le x nat.O)
                          (x0 => nat.le (f x) nat.O)))
                    (cts.prod
                       cts.box
                       cts.star
                       cts.star
                       cts.I
                       nat.nat
                       (x =>
                        cts.prod
                          cts.box
                          cts.star
                          cts.star
                          cts.I
                          nat.nat
                          (x0 =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (nat.le x nat.O)
                             (x1 =>
                              cts.prod
                                cts.star
                                cts.star
                                cts.star
                                cts.I
                                (nat.le x0 nat.O)
                                (x2 =>
                                 cts.prod
                                   cts.star
                                   cts.star
                                   cts.star
                                   cts.I
                                   (logic.eq nat.nat (f x) (f x0))
                                   (x3 => logic.eq nat.nat x x0)))))))) =>
     connectives.match_And_prop
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x =>
           cts.prod cts.star cts.star cts.star cts.I (nat.le x nat.O) (x0 => nat.le (f x) nat.O)))
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x nat.O)
                (x1 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x0 nat.O)
                   (x2 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat (f x) (f x0))
                      (x3 => logic.eq nat.nat x x0))))))
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le x nat.O)
             (x0 =>
              connectives.ex
                nat.nat
                (p:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.And (nat.le p nat.O) (logic.eq nat.nat (f p) x)))))
       (H:(cts.Term
             cts.star
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x nat.O)
                   (x0 => nat.le (f x) nat.O)))) =>
        H1:(cts.Term
              cts.star
              (cts.prod
                 cts.box
                 cts.star
                 cts.star
                 cts.I
                 nat.nat
                 (x =>
                  cts.prod
                    cts.box
                    cts.star
                    cts.star
                    cts.I
                    nat.nat
                    (x0 =>
                     cts.prod
                       cts.star
                       cts.star
                       cts.star
                       cts.I
                       (nat.le x nat.O)
                       (x1 =>
                        cts.prod
                          cts.star
                          cts.star
                          cts.star
                          cts.I
                          (nat.le x0 nat.O)
                          (x2 =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (logic.eq nat.nat (f x) (f x0))
                             (x3 => logic.eq nat.nat x x0))))))) =>
        m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        lem0:(cts.Term cts.star (nat.le m nat.O)) =>
        connectives.ex_intro
          nat.nat
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le x nat.O) (logic.eq nat.nat (f x) m))
          nat.O
          (connectives.conj
             (nat.le nat.O nat.O)
             (logic.eq nat.nat (f nat.O) m)
             (nat.le_O_n nat.O)
             (nat.le_n_O_elim
                m
                lem0
                (logic.eq nat.nat (f nat.O))
                (logic.sym_eq
                   nat.nat
                   nat.O
                   (f nat.O)
                   (nat.le_n_O_to_eq (f nat.O) (H nat.O (nat.le_O_n nat.O)))))))
       _clearme)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     Hind:(cts.Term
             cts.star
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                (x => cts.prod cts.star cts.star cts.star cts.I (permut x m) (x0 => bijn x m)))) =>
     f:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
     permf:(cts.Term cts.star (permut f (nat.S m))) =>
     eq_to_bijn
       (p:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        transpose (f (nat.S m)) (nat.S m) (transpose (f (nat.S m)) (nat.S m) (f p)))
       f
       (nat.S m)
       (i:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        lei:(cts.Term cts.star (nat.le i (nat.S m))) =>
        transpose_transpose (f (nat.S m)) (nat.S m) (f i))
       (bijn_fg
          (transpose (f (nat.S m)) (nat.S m))
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat.nat)) =>
           transpose (f (nat.S m)) (nat.S m) (f __))
          (nat.S m)
          (connectives.match_And_prop
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x (nat.S m))
                   (x0 => nat.le (f x) (nat.S m))))
             (injn f (nat.S m))
             (bijn (transpose (f (nat.S m)) (nat.S m)) (nat.S m))
             (lef:(cts.Term
                     cts.star
                     (cts.prod
                        cts.box
                        cts.star
                        cts.star
                        cts.I
                        nat.nat
                        (x =>
                         cts.prod
                           cts.star
                           cts.star
                           cts.star
                           cts.I
                           (nat.le x (nat.S m))
                           (x0 => nat.le (f x) (nat.S m))))) =>
              __:(cts.Term cts.star (injn f (nat.S m))) =>
              bijn_transpose
                (nat.S m)
                (f (nat.S m))
                (nat.S m)
                (lef (nat.S m) (nat.le_n (nat.S m)))
                (nat.le_n (nat.S m)))
             permf)
          (bijn_n_Sn
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat.nat)) =>
              transpose (f (nat.S m)) (nat.S m) (f __))
             m
             (Hind
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                 transpose (f (nat.S m)) (nat.S m) (f __))
                (permut_S_to_permut_transpose f m permf))
             (logic.eq_ind_r
                bool.bool
                bool.true
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type
                      nat.nat
                      (nat.S m)
                      (bool.match_bool_type
                         nat.nat
                         (f (nat.S m))
                         (f (nat.S m))
                         (nat.eqb (f (nat.S m)) (nat.S m)))
                      x)
                   (nat.S m))
                (bool.eq_match_bool_type_true
                   nat.nat
                   (nat.S m)
                   (bool.match_bool_type
                      nat.nat
                      (f (nat.S m))
                      (f (nat.S m))
                      (nat.eqb (f (nat.S m)) (nat.S m)))
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         (nat.S m)
                         (bool.match_bool_type
                            nat.nat
                            (f (nat.S m))
                            (f (nat.S m))
                            (nat.eqb (f (nat.S m)) (nat.S m)))
                         bool.true)
                      y)
                   (logic.refl
                      nat.nat
                      (bool.match_bool_type
                         nat.nat
                         (nat.S m)
                         (bool.match_bool_type
                            nat.nat
                            (f (nat.S m))
                            (f (nat.S m))
                            (nat.eqb (f (nat.S m)) (nat.S m)))
                         bool.true)))
                (nat.eqb (f (nat.S m)) (f (nat.S m)))
                (nat.eqb_n_n (f (nat.S m)))))))
    n.

invert_permut :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat))))).

invert_permut_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat))))).

axiom_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        connectives.equal
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (invert_permut x)
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
                (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
             invert_permut_body
             x))).

def eq_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (invert_permut x)
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
                (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
             invert_permut_body
             x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (invert_permut n)
    (nat.filter_nat_type
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       invert_permut_body
       n)
    (axiom_invert_permut n).

def sym_eq_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
                (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
             invert_permut_body
             x)
          (invert_permut x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (invert_permut n)
    (nat.filter_nat_type
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       invert_permut_body
       n)
    (eq_invert_permut n).

axiom_invert_permut_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       (invert_permut_body nat.O)
       (f:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
        m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))).

def eq_invert_permut_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       (invert_permut_body nat.O)
       (f:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
        m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O))))
  :=
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (invert_permut_body nat.O)
    (f:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))
    axiom_invert_permut_body_O.

def sym_eq_invert_permut_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       (f:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
        m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))
       (invert_permut_body nat.O))
  :=
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (invert_permut_body nat.O)
    (f:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     bool.match_bool_type nat.nat nat.O nat.O (nat.eqb m (f nat.O)))
    eq_invert_permut_body_O.

axiom_invert_permut_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        connectives.equal
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (invert_permut_body (nat.S x))
          (f:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))) =>
           m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           bool.match_bool_type nat.nat (nat.S x) (invert_permut x f m) (nat.eqb m (f (nat.S x)))))).

def eq_invert_permut_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (invert_permut_body (nat.S x))
          (f:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))) =>
           m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           bool.match_bool_type nat.nat (nat.S x) (invert_permut x f m) (nat.eqb m (f (nat.S x))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (invert_permut_body (nat.S n))
    (f:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     bool.match_bool_type nat.nat (nat.S n) (invert_permut n f m) (nat.eqb m (f (nat.S n))))
    (axiom_invert_permut_body_S n).

def sym_eq_invert_permut_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (f:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))) =>
           m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           bool.match_bool_type nat.nat (nat.S x) (invert_permut x f m) (nat.eqb m (f (nat.S x))))
          (invert_permut_body (nat.S x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (invert_permut_body (nat.S n))
    (f:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     bool.match_bool_type nat.nat (nat.S n) (invert_permut n f m) (nat.eqb m (f (nat.S n))))
    (eq_invert_permut_body_S n).

def invert_permut_f :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x1 x0)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (injn x x0)
                   (x3 => logic.eq nat.nat (invert_permut x0 x (x x1)) x1))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lenm:(cts.Term cts.star (nat.le m n)) =>
  nat.le_ind
    m
    (x_417:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (injn f x_417)
       (x => logic.eq nat.nat (invert_permut x_417 f (f m)) m))
    (nat.match_nat_prop
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (injn f __)
          (x => logic.eq nat.nat (invert_permut __ f (f __)) __))
       (sym_eq_invert_permut
          nat.O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (injn f nat.O)
             (x => logic.eq nat.nat (y f (f nat.O)) nat.O))
          (nat.sym_eq_filter_nat_type_O
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
             invert_permut_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                         (x =>
                          cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (injn f nat.O)
                (x => logic.eq nat.nat (y f (f nat.O)) nat.O))
             (sym_eq_invert_permut_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                            (x =>
                             cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (injn f nat.O)
                   (x => logic.eq nat.nat (y f (f nat.O)) nat.O))
                (logic.eq_ind_r
                   bool.bool
                   bool.true
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat.nat
                         (x0 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x1 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (nat.le x0 nat.O)
                               (x2 =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x1 nat.O)
                                  (x3 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (f x0) (f x1))
                                     (x4 => logic.eq nat.nat x0 x1))))))
                      (x0 =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat nat.O nat.O x) nat.O))
                   (auto:(cts.Term
                            cts.star
                            (cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat.nat
                               (x =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat.nat
                                  (x0 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (nat.le x nat.O)
                                     (x1 =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (nat.le x0 nat.O)
                                        (x2 =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (logic.eq nat.nat (f x) (f x0))
                                           (x3 => logic.eq nat.nat x x0))))))) =>
                    bool.eq_match_bool_type_true
                      nat.nat
                      nat.O
                      nat.O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq nat.nat (bool.match_bool_type nat.nat nat.O nat.O bool.true) y)
                      (logic.refl nat.nat (bool.match_bool_type nat.nat nat.O nat.O bool.true)))
                   (nat.eqb (f nat.O) (f nat.O))
                   (nat.eqb_n_n (f nat.O))))))
       (a:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        sym_eq_invert_permut
          (nat.S a)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (injn f (nat.S a))
             (x => logic.eq nat.nat (y f (f (nat.S a))) (nat.S a)))
          (nat.sym_eq_filter_nat_type_S
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
             invert_permut_body
             a
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                         (x =>
                          cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (injn f (nat.S a))
                (x => logic.eq nat.nat (y f (f (nat.S a))) (nat.S a)))
             (sym_eq_invert_permut_body_S
                a
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                            (x =>
                             cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (injn f (nat.S a))
                   (x => logic.eq nat.nat (y f (f (nat.S a))) (nat.S a)))
                (logic.eq_ind_r
                   bool.bool
                   bool.true
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            bool.bool)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (cts.prod
                         cts.box
                         cts.star
                         cts.star
                         cts.I
                         nat.nat
                         (x0 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x1 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (nat.le x0 (nat.S a))
                               (x2 =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x1 (nat.S a))
                                  (x3 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (f x0) (f x1))
                                     (x4 => logic.eq nat.nat x0 x1))))))
                      (x0 =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            (nat.S a)
                            (invert_permut a f (f (nat.S a)))
                            x)
                         (nat.S a)))
                   (auto:(cts.Term
                            cts.star
                            (cts.prod
                               cts.box
                               cts.star
                               cts.star
                               cts.I
                               nat.nat
                               (x =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat.nat
                                  (x0 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (nat.le x (nat.S a))
                                     (x1 =>
                                      cts.prod
                                        cts.star
                                        cts.star
                                        cts.star
                                        cts.I
                                        (nat.le x0 (nat.S a))
                                        (x2 =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (logic.eq nat.nat (f x) (f x0))
                                           (x3 => logic.eq nat.nat x x0))))))) =>
                    bool.eq_match_bool_type_true
                      nat.nat
                      (nat.S a)
                      (invert_permut a f (f (nat.S a)))
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       logic.eq
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            (nat.S a)
                            (invert_permut a f (f (nat.S a)))
                            bool.true)
                         y)
                      (logic.refl
                         nat.nat
                         (bool.match_bool_type
                            nat.nat
                            (nat.S a)
                            (invert_permut a f (f (nat.S a)))
                            bool.true)))
                   (nat.eqb (f (nat.S a)) (f (nat.S a)))
                   (nat.eqb_n_n (f (nat.S a)))))))
       m)
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     sym_eq_invert_permut
       (nat.S m0)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                   (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le m m0)
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (injn f m0)
                (x0 => logic.eq nat.nat (invert_permut m0 f (f m)) m))
             (x0 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (injn f (nat.S m0))
                (x1 => logic.eq nat.nat (y f (f m)) m))))
       (nat.sym_eq_filter_nat_type_S
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
             (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
          invert_permut_body
          m0
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le m m0)
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (injn f m0)
                   (x0 => logic.eq nat.nat (invert_permut m0 f (f m)) m))
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (injn f (nat.S m0))
                   (x1 => logic.eq nat.nat (y f (f m)) m))))
          (sym_eq_invert_permut_body_S
             m0
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                         (x =>
                          cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le m m0)
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (injn f m0)
                      (x0 => logic.eq nat.nat (invert_permut m0 f (f m)) m))
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (injn f (nat.S m0))
                      (x1 => logic.eq nat.nat (y f (f m)) m))))
             (lem:(cts.Term cts.star (nat.le m m0)) =>
              H:(cts.Term
                   cts.star
                   (cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (injn f m0)
                      (x => logic.eq nat.nat (invert_permut m0 f (f m)) m))) =>
              H1:(cts.Term cts.star (injn f (nat.S m0))) =>
              logic.eq_ind_r
                bool.bool
                bool.false
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat (nat.S m0) (invert_permut m0 f (f m)) x)
                   m)
                (bool.sym_eq_match_bool_type_false
                   nat.nat
                   (nat.S m0)
                   (invert_permut m0 f (f m))
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq nat.nat y m)
                   (H (injn_Sn_n f m0 H1)))
                (nat.eqb (f m) (f (nat.S m0)))
                (nat.not_eq_to_eqb_false
                   (f m)
                   (f (nat.S m0))
                   (connectives.nmk
                      (logic.eq nat.nat (f m) (f (nat.S m0)))
                      (eqf:(cts.Term cts.star (logic.eq nat.nat (f m) (f (nat.S m0)))) =>
                       logic.absurd
                         (logic.eq nat.nat m (nat.S m0))
                         (H1
                            m
                            (nat.S m0)
                            (nat.le_S m m0 lem)
                            (nat.le_n (nat.S m0))
                            (logic.rewrite_l
                               nat.nat
                               (f m)
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq nat.nat (f m) __)
                               (logic.refl nat.nat (f m))
                               (f (nat.S m0))
                               eqf))
                         (nat.lt_to_not_eq m (nat.S m0) (nat.le_S_S m m0 lem)))))))))
    n
    lenm.

def let_clause_1063 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permut x x0)
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x2 x0)
                      (x4 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x3 x0)
                         (x5 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x6 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.And (nat.le x6 x0) (logic.eq nat.nat (x x6) x2))
                               (x7 =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x6 x0)
                                  (x8 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (x x6) x2)
                                     (x9 =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat.nat
                                        (x10 =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (connectives.And
                                              (nat.le x10 x0)
                                              (logic.eq nat.nat (x x10) x3))
                                           (x11 =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (nat.le x10 x0)
                                              (x12 =>
                                               cts.prod
                                                 cts.star
                                                 cts.star
                                                 cts.star
                                                 cts.I
                                                 (logic.eq nat.nat (x x10) x3)
                                                 (x13 =>
                                                  cts.prod
                                                    cts.star
                                                    cts.star
                                                    cts.star
                                                    cts.I
                                                    (cts.prod
                                                       cts.box
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       nat.nat
                                                       (x14 =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (nat.le x14 x0)
                                                          (x15 => nat.le (x x14) x0)))
                                                    (x14 =>
                                                     cts.prod
                                                       cts.star
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       (injn x x0)
                                                       (x15 =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (logic.eq nat.nat x6 x10)
                                                          (x16 =>
                                                           logic.eq
                                                             nat.nat
                                                             (x x6)
                                                             x3)))))))))))))))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  permf:(cts.Term cts.star (permut f n)) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
  lean:(cts.Term cts.star (nat.le a n)) =>
  fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme0:(cts.Term cts.star (connectives.And (nat.le b n) (logic.eq nat.nat (f b) j))) =>
  lebn:(cts.Term cts.star (nat.le b n)) =>
  fb:(cts.Term cts.star (logic.eq nat.nat (f b) j)) =>
  __:(cts.Term
        cts.star
        (cts.prod
           cts.box
           cts.star
           cts.star
           cts.I
           nat.nat
           (x => cts.prod cts.star cts.star cts.star cts.I (nat.le x n) (x0 => nat.le (f x) n)))) =>
  injf:(cts.Term cts.star (injn f n)) =>
  auto:(cts.Term cts.star (logic.eq nat.nat a b)) =>
  logic.rewrite_r
    nat.nat
    b
    (__1:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               nat.nat)) =>
     logic.eq nat.nat (f __1) j)
    fb
    a
    auto.

def let_clause_1068 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permut x x0)
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x2 x0)
                      (x4 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x3 x0)
                         (x5 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x6 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.And (nat.le x6 x0) (logic.eq nat.nat (x x6) x2))
                               (x7 =>
                                cts.prod
                                  cts.star
                                  cts.star
                                  cts.star
                                  cts.I
                                  (nat.le x6 x0)
                                  (x8 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (logic.eq nat.nat (x x6) x2)
                                     (x9 =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat.nat
                                        (x10 =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (connectives.And
                                              (nat.le x10 x0)
                                              (logic.eq nat.nat (x x10) x3))
                                           (x11 =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (nat.le x10 x0)
                                              (x12 =>
                                               cts.prod
                                                 cts.star
                                                 cts.star
                                                 cts.star
                                                 cts.I
                                                 (logic.eq nat.nat (x x10) x3)
                                                 (x13 =>
                                                  cts.prod
                                                    cts.star
                                                    cts.star
                                                    cts.star
                                                    cts.I
                                                    (cts.prod
                                                       cts.box
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       nat.nat
                                                       (x14 =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (nat.le x14 x0)
                                                          (x15 => nat.le (x x14) x0)))
                                                    (x14 =>
                                                     cts.prod
                                                       cts.star
                                                       cts.star
                                                       cts.star
                                                       cts.I
                                                       (injn x x0)
                                                       (x15 =>
                                                        cts.prod
                                                          cts.star
                                                          cts.star
                                                          cts.star
                                                          cts.I
                                                          (logic.eq nat.nat x6 x10)
                                                          (x16 =>
                                                           logic.eq
                                                             nat.nat
                                                             (x x6)
                                                             x2)))))))))))))))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  permf:(cts.Term cts.star (permut f n)) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
  lean:(cts.Term cts.star (nat.le a n)) =>
  fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme0:(cts.Term cts.star (connectives.And (nat.le b n) (logic.eq nat.nat (f b) j))) =>
  lebn:(cts.Term cts.star (nat.le b n)) =>
  fb:(cts.Term cts.star (logic.eq nat.nat (f b) j)) =>
  __:(cts.Term
        cts.star
        (cts.prod
           cts.box
           cts.star
           cts.star
           cts.I
           nat.nat
           (x => cts.prod cts.star cts.star cts.star cts.I (nat.le x n) (x0 => nat.le (f x) n)))) =>
  injf:(cts.Term cts.star (injn f n)) =>
  auto:(cts.Term cts.star (logic.eq nat.nat a b)) =>
  logic.rewrite_l
    nat.nat
    j
    (__1:(cts.Term
            cts.diamond
            (cts.cast
               cts.triangle
               cts.sinf
               (cts.univ cts.box cts.triangle cts.I)
               (cts.univ cts.diamond cts.sinf cts.I)
               cts.I
               nat.nat)) =>
     logic.eq nat.nat (f a) __1)
    (let_clause_1063 f n permf i j lein lejn a _clearme lean fa b _clearme0 lebn fb __ injf auto)
    i
    (logic.rewrite_l
       nat.nat
       (f a)
       (__1:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat.nat)) =>
        logic.eq nat.nat __1 i)
       fa
       j
       (let_clause_1063 f n permf i j lein lejn a _clearme lean fa b _clearme0 lebn fb __ injf auto)).

def injective_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permut x x0)
             (x1 => injn (invert_permut x0 x) x0))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  permf:(cts.Term cts.star (permut f n)) =>
  i:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  j:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lein:(cts.Term cts.star (nat.le i n)) =>
  lejn:(cts.Term cts.star (nat.le j n)) =>
  connectives.match_ex_prop
    nat.nat
    (p:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     connectives.And (nat.le p n) (logic.eq nat.nat (f p) i))
    (cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (logic.eq nat.nat (invert_permut n f i) (invert_permut n f j))
       (x => logic.eq nat.nat i j))
    (a:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     _clearme:(cts.Term cts.star (connectives.And (nat.le a n) (logic.eq nat.nat (f a) i))) =>
     connectives.match_And_prop
       (nat.le a n)
       (logic.eq nat.nat (f a) i)
       (cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (logic.eq nat.nat (invert_permut n f i) (invert_permut n f j))
          (x => logic.eq nat.nat i j))
       (lean:(cts.Term cts.star (nat.le a n)) =>
        fa:(cts.Term cts.star (logic.eq nat.nat (f a) i)) =>
        connectives.match_ex_prop
          nat.nat
          (p:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (nat.le p n) (logic.eq nat.nat (f p) j))
          (cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat.nat (invert_permut n f i) (invert_permut n f j))
             (x => logic.eq nat.nat i j))
          (b:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           _clearme0:(cts.Term
                        cts.star
                        (connectives.And (nat.le b n) (logic.eq nat.nat (f b) j))) =>
           connectives.match_And_prop
             (nat.le b n)
             (logic.eq nat.nat (f b) j)
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (invert_permut n f i) (invert_permut n f j))
                (x => logic.eq nat.nat i j))
             (lebn:(cts.Term cts.star (nat.le b n)) =>
              fb:(cts.Term cts.star (logic.eq nat.nat (f b) j)) =>
              connectives.match_And_prop
                (cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x n)
                      (x0 => nat.le (f x) n)))
                (injn f n)
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat.nat (invert_permut n f i) (invert_permut n f j))
                   (x => logic.eq nat.nat i j))
                (__:(cts.Term
                       cts.star
                       (cts.prod
                          cts.box
                          cts.star
                          cts.star
                          cts.I
                          nat.nat
                          (x =>
                           cts.prod
                             cts.star
                             cts.star
                             cts.star
                             cts.I
                             (nat.le x n)
                             (x0 => nat.le (f x) n)))) =>
                 injf:(cts.Term cts.star (injn f n)) =>
                 logic.eq_ind
                   nat.nat
                   (f a)
                   (x_1:(cts.Term
                           cts.diamond
                           (cts.cast
                              cts.triangle
                              cts.sinf
                              (cts.univ cts.box cts.triangle cts.I)
                              (cts.univ cts.diamond cts.sinf cts.I)
                              cts.I
                              nat.nat)) =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat (invert_permut n f x_1) (invert_permut n f j))
                      (x => logic.eq nat.nat x_1 j))
                   (logic.eq_ind
                      nat.nat
                      (f b)
                      (x_1:(cts.Term
                              cts.diamond
                              (cts.cast
                                 cts.triangle
                                 cts.sinf
                                 (cts.univ cts.box cts.triangle cts.I)
                                 (cts.univ cts.diamond cts.sinf cts.I)
                                 cts.I
                                 nat.nat)) =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (logic.eq nat.nat (invert_permut n f (f a)) (invert_permut n f x_1))
                         (x => logic.eq nat.nat (f a) x_1))
                      (logic.eq_ind_r
                         nat.nat
                         a
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (logic.eq nat.nat x (invert_permut n f (f b)))
                            (x0 => logic.eq nat.nat (f a) (f b)))
                         (logic.eq_ind_r
                            nat.nat
                            b
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (logic.eq nat.nat a x)
                               (x0 => logic.eq nat.nat (f a) (f b)))
                            (auto:(cts.Term cts.star (logic.eq nat.nat a b)) =>
                             logic.rewrite_r
                               nat.nat
                               i
                               (__1:(cts.Term
                                       cts.diamond
                                       (cts.cast
                                          cts.triangle
                                          cts.sinf
                                          (cts.univ cts.box cts.triangle cts.I)
                                          (cts.univ cts.diamond cts.sinf cts.I)
                                          cts.I
                                          nat.nat)) =>
                                logic.eq nat.nat __1 (f b))
                               (logic.rewrite_l
                                  nat.nat
                                  a
                                  (__1:(cts.Term
                                          cts.diamond
                                          (cts.cast
                                             cts.triangle
                                             cts.sinf
                                             (cts.univ cts.box cts.triangle cts.I)
                                             (cts.univ cts.diamond cts.sinf cts.I)
                                             cts.I
                                             nat.nat)) =>
                                   logic.eq nat.nat i (f __1))
                                  (logic.rewrite_r
                                     nat.nat
                                     i
                                     (__1:(cts.Term
                                             cts.diamond
                                             (cts.cast
                                                cts.triangle
                                                cts.sinf
                                                (cts.univ cts.box cts.triangle cts.I)
                                                (cts.univ cts.diamond cts.sinf cts.I)
                                                cts.I
                                                nat.nat)) =>
                                      logic.eq nat.nat i __1)
                                     (logic.refl nat.nat i)
                                     (f a)
                                     (let_clause_1068
                                        f
                                        n
                                        permf
                                        i
                                        j
                                        lein
                                        lejn
                                        a
                                        _clearme
                                        lean
                                        fa
                                        b
                                        _clearme0
                                        lebn
                                        fb
                                        __
                                        injf
                                        auto))
                                  b
                                  auto)
                               (f a)
                               (let_clause_1068
                                  f
                                  n
                                  permf
                                  i
                                  j
                                  lein
                                  lejn
                                  a
                                  _clearme
                                  lean
                                  fa
                                  b
                                  _clearme0
                                  lebn
                                  fb
                                  __
                                  injf
                                  auto))
                            (invert_permut n f (f b))
                            (invert_permut_f f n b lebn injf))
                         (invert_permut n f (f a))
                         (invert_permut_f f n a lean injf))
                      j
                      fb)
                   i
                   fa)
                permf)
             _clearme0)
          (permut_to_bijn n f permf j lejn))
       _clearme)
    (permut_to_bijn n f permf i lein).

def permut_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (permut x x0)
             (x1 => permut (invert_permut x0 x) x0))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  permf:(cts.Term cts.star (permut f n)) =>
  connectives.conj
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x n)
          (x0 => nat.le (invert_permut n f x) n)))
    (injn (invert_permut n f) n)
    (i:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     lein:(cts.Term cts.star (nat.le i n)) =>
     nat.nat_ind
       (_x_365:(cts.Term
                  cts.diamond
                  (cts.cast
                     cts.triangle
                     cts.sinf
                     (cts.univ cts.box cts.triangle cts.I)
                     (cts.univ cts.diamond cts.sinf cts.I)
                     cts.I
                     nat.nat)) =>
        nat.le (invert_permut _x_365 f i) _x_365)
       (sym_eq_invert_permut
          nat.O
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           nat.le (y f i) nat.O)
          (nat.sym_eq_filter_nat_type_O
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
             invert_permut_body
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                         (x =>
                          cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
              nat.le (y f i) nat.O)
             (sym_eq_invert_permut_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                            (x =>
                             cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
                 nat.le (y f i) nat.O)
                (bool.match_bool_prop
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             bool.bool)) =>
                    nat.le (bool.match_bool_type nat.nat nat.O nat.O __) nat.O)
                   (bool.eq_match_bool_type_true
                      nat.nat
                      nat.O
                      nat.O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       nat.le (bool.match_bool_type nat.nat nat.O nat.O bool.true) y)
                      (nat.le_n (bool.match_bool_type nat.nat nat.O nat.O bool.true)))
                   (bool.eq_match_bool_type_false
                      nat.nat
                      nat.O
                      nat.O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       nat.le (bool.match_bool_type nat.nat nat.O nat.O bool.false) y)
                      (nat.le_n (bool.match_bool_type nat.nat nat.O nat.O bool.false)))
                   (nat.eqb i (f nat.O))))))
       (n1:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        sym_eq_invert_permut
          (nat.S n1)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.le (invert_permut n1 f i) n1)
             (x => nat.le (y f i) (nat.S n1)))
          (nat.sym_eq_filter_nat_type_S
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
             invert_permut_body
             n1
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                         (x =>
                          cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le (invert_permut n1 f i) n1)
                (x => nat.le (y f i) (nat.S n1)))
             (sym_eq_invert_permut_body_S
                n1
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
                            (x =>
                             cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le (invert_permut n1 f i) n1)
                   (x => nat.le (y f i) (nat.S n1)))
                (Hind:(cts.Term cts.star (nat.le (invert_permut n1 f i) n1)) =>
                 bool.match_bool_prop
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             bool.bool)) =>
                    nat.le
                      (bool.match_bool_type nat.nat (nat.S n1) (invert_permut n1 f i) __)
                      (nat.S n1))
                   (bool.eq_match_bool_type_true
                      nat.nat
                      (nat.S n1)
                      (invert_permut n1 f i)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       nat.le
                         (bool.match_bool_type
                            nat.nat
                            (nat.S n1)
                            (invert_permut n1 f i)
                            bool.true)
                         y)
                      (nat.le_n
                         (bool.match_bool_type
                            nat.nat
                            (nat.S n1)
                            (invert_permut n1 f i)
                            bool.true)))
                   (bool.sym_eq_match_bool_type_false
                      nat.nat
                      (nat.S n1)
                      (invert_permut n1 f i)
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       nat.le y (nat.S n1))
                      (nat.le_S (invert_permut n1 f i) n1 Hind))
                   (nat.eqb i (f (nat.S n1)))))))
       n)
    (injective_invert_permut f n permf).

def f_invert_permut :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat))
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x1 x0)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (permut x x0)
                   (x3 => logic.eq nat.nat (x (invert_permut x0 x x1)) x1))))))
  :=
  f:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => nat.nat)))) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  lemn:(cts.Term cts.star (nat.le m n)) =>
  permf:(cts.Term cts.star (permut f n)) =>
  connectives.match_And_prop
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.le x n)
          (x0 => nat.le (invert_permut n f x) n)))
    (injn (invert_permut n f) n)
    (logic.eq nat.nat (f (invert_permut n f m)) m)
    (Hle:(cts.Term
            cts.star
            (cts.prod
               cts.box
               cts.star
               cts.star
               cts.I
               nat.nat
               (x =>
                cts.prod
                  cts.star
                  cts.star
                  cts.star
                  cts.I
                  (nat.le x n)
                  (x0 => nat.le (invert_permut n f x) n)))) =>
     Hinj:(cts.Term cts.star (injn (invert_permut n f) n)) =>
     connectives.match_And_prop
       (cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x => cts.prod cts.star cts.star cts.star cts.I (nat.le x n) (x0 => nat.le (f x) n)))
       (injn f n)
       (logic.eq nat.nat (f (invert_permut n f m)) m)
       (lef:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat.nat
                  (x =>
                   cts.prod
                     cts.star
                     cts.star
                     cts.star
                     cts.I
                     (nat.le x n)
                     (x0 => nat.le (f x) n)))) =>
        injf:(cts.Term cts.star (injn f n)) =>
        injective_invert_permut
          f
          n
          permf
          (f (invert_permut n f m))
          m
          (lef (invert_permut n f m) (Hle m lemn))
          lemn
          (invert_permut_f f n (invert_permut n f m) (Hle m lemn) injf))
       permf)
    (permut_invert_permut f n permf).

