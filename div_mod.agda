module div_mod where
open import Agda.Primitive
open import bool
open import connectives
open import leibniz
open import logic
open import nat
postulate mod::aux : nat.nat -> nat.nat -> nat.nat -> nat.nat
postulate mod::aux::body : nat.nat -> nat.nat -> nat.nat -> nat.nat
postulate axiom::mod::aux : forall (p : nat.nat) -> connectives.equal (nat.nat -> nat.nat -> nat.nat) (mod::aux p) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) mod::aux::body p)
eq::mod::aux : {j : Level} ->  _
eq::mod::aux {j} = \(p : nat.nat) -> ((((connectives.equal::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (mod::aux p)) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) mod::aux::body p)) ((axiom::mod::aux) (p))

sym::eq::mod::aux : {j : Level} -> _
sym::eq::mod::aux {j} = \(p : nat.nat) -> ((((leibniz.sym::leibniz {_} {j} ) (nat.nat -> nat.nat -> nat.nat)) (mod::aux p)) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) mod::aux::body p)) ((eq::mod::aux) (p))

postulate axiom::mod::aux::body::O : connectives.equal (nat.nat -> nat.nat -> nat.nat) (mod::aux::body nat.O) (\(m : nat.nat) -> \(n : nat.nat) -> m)
eq::mod::aux::body::O : {j : Level} -> _
eq::mod::aux::body::O {j} = ((((connectives.equal::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body nat.O)) (\(m : nat.nat) -> \(n : nat.nat) -> m)) (axiom::mod::aux::body::O)

sym::eq::mod::aux::body::O : {j : Level} -> _
sym::eq::mod::aux::body::O {j} = ((((leibniz.sym::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body nat.O)) (\(m : nat.nat) -> \(n : nat.nat) -> m)) (eq::mod::aux::body::O)

postulate axiom::mod::aux::body::S : forall (p : nat.nat) -> connectives.equal (nat.nat -> nat.nat -> nat.nat) (mod::aux::body (nat.S p)) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) m (mod::aux p (nat.minus m (nat.S n)) n) (nat.leb m n))
eq::mod::aux::body::S : {j : Level} -> _
eq::mod::aux::body::S {j} = \(p : nat.nat) -> ((((connectives.equal::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body (nat.S p))) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) m (mod::aux p (nat.minus m (nat.S n)) n) (nat.leb m n))) ((axiom::mod::aux::body::S) (p))

sym::eq::mod::aux::body::S : {j : Level} -> _
sym::eq::mod::aux::body::S {j} = \(p : nat.nat) -> ((((leibniz.sym::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body (nat.S p))) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) m (mod::aux p (nat.minus m (nat.S n)) n) (nat.leb m n))) ((eq::mod::aux::body::S) (p))

mod : _
mod = \(n : nat.nat) -> \(m : nat.nat) -> nat.match::nat::type (nat.nat) n (\(p : nat.nat) -> mod::aux n n p) m

postulate div::aux : nat.nat -> nat.nat -> nat.nat -> nat.nat
postulate div::aux::body : nat.nat -> nat.nat -> nat.nat -> nat.nat
postulate axiom::div::aux : forall (p : nat.nat) -> connectives.equal (nat.nat -> nat.nat -> nat.nat) (div::aux p) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) div::aux::body p)
eq::div::aux : {j : Level} -> _
eq::div::aux {j} = \(p : nat.nat) -> ((((connectives.equal::leibniz {lzero} {j}) (nat.nat -> nat.nat -> nat.nat)) (div::aux p)) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) div::aux::body p)) ((axiom::div::aux) (p))

sym::eq::div::aux : {j : Level} -> _
sym::eq::div::aux {j} = \(p : nat.nat) -> ((((leibniz.sym::leibniz {lzero} {j}) (nat.nat -> nat.nat -> nat.nat)) (div::aux p)) (nat.filter::nat::type (nat.nat -> nat.nat -> nat.nat) div::aux::body p)) ((eq::div::aux) (p))

postulate axiom::div::aux::body::O : connectives.equal (nat.nat -> nat.nat -> nat.nat) (div::aux::body nat.O) (\(m : nat.nat) -> \(n : nat.nat) -> nat.O)
eq::div::aux::body::O : {j : Level} -> _
eq::div::aux::body::O {j} = ((((connectives.equal::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (div::aux::body nat.O)) (\(m : nat.nat) -> \(n : nat.nat) -> nat.O)) (axiom::div::aux::body::O)

sym::eq::div::aux::body::O : {j : Level} -> _
sym::eq::div::aux::body::O {j} = ((((leibniz.sym::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (div::aux::body nat.O)) (\(m : nat.nat) -> \(n : nat.nat) -> nat.O)) (eq::div::aux::body::O)

postulate axiom::div::aux::body::S : forall (p : nat.nat) -> connectives.equal (nat.nat -> nat.nat -> nat.nat) (div::aux::body (nat.S p)) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux p (nat.minus m (nat.S n)) n)) (nat.leb m n))
eq::div::aux::body::S : {j : Level} -> _
eq::div::aux::body::S {j} = \(p : nat.nat) -> ((((connectives.equal::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (div::aux::body (nat.S p))) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux p (nat.minus m (nat.S n)) n)) (nat.leb m n))) ((axiom::div::aux::body::S) (p))

sym::eq::div::aux::body::S : {j : Level} -> _
sym::eq::div::aux::body::S {j} = \(p : nat.nat) -> ((((leibniz.sym::leibniz {_} {j}) (nat.nat -> nat.nat -> nat.nat)) (div::aux::body (nat.S p))) (\(m : nat.nat) -> \(n : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux p (nat.minus m (nat.S n)) n)) (nat.leb m n))) ((eq::div::aux::body::S) (p))

div : _
div = \(n : nat.nat) -> \(m : nat.nat) -> nat.match::nat::type (nat.nat) (nat.S n) (\(p : nat.nat) -> div::aux n n p) m

le::mod::aux::m::m : _
le::mod::aux::m::m = \(p : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n ::x::365) -> nat.le (mod::aux ::x::365 n m) m)) (\(n : nat.nat) -> \(m : nat.nat) -> (((sym::eq::mod::aux) (nat.O)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.le n nat.O) -> nat.le (y n m) m)) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.le n nat.O) -> nat.le (y n m) m)) (((sym::eq::mod::aux::body::O) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (nat.le n nat.O) -> nat.le (y n m) m)) (\(lenO : nat.le n nat.O) -> (((((nat.le::n::O::elim) (n)) (lenO)) (\(:::: : nat.nat) -> nat.le :::: m)) ((nat.le::O::n) (m)))))))) (\(q : nat.nat) -> (((sym::eq::mod::aux) (nat.S q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n q) -> nat.le (mod::aux q n m) m) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n (nat.S q)) -> nat.le (y n m) m)) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body)) (q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n q) -> nat.le (mod::aux q n m) m) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n (nat.S q)) -> nat.le (y n m) m)) ((((sym::eq::mod::aux::body::S) (q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n q) -> nat.le (mod::aux q n m) m) -> forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n (nat.S q)) -> nat.le (y n m) m)) (\(Hind : forall (n : nat.nat) -> forall (m : nat.nat) -> (nat.le n q) -> nat.le (mod::aux q n m) m) -> (\(n : nat.nat) -> \(m : nat.nat) -> \(len : nat.le n (nat.S q)) -> ((((((nat.leb::elim) (n)) (m)) (\(:::: : bool.bool) -> nat.le (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) ::::) m)) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (n)) (mod::aux q (nat.minus n (nat.S m)) m)) (\(y : nat.nat) -> (nat.le n m) -> nat.le y m)) (\(auto : nat.le n m) -> (auto)))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (n)) (mod::aux q (nat.minus n (nat.S m)) m)) (\(y : nat.nat) -> (connectives.Not (nat.le n m)) -> nat.le y m)) (\(notlenm : connectives.Not (nat.le n m)) -> ((((Hind) (nat.minus n (nat.S m))) (m)) (((((nat.le::plus::to::minus) (n)) (nat.S m)) (q)) ((((((nat.transitive::le) (n)) (nat.S q)) (nat.plus q (nat.S m))) (len)) (((((logic.eq::coerc) (nat.le (nat.S q) (nat.plus (nat.S q) m))) (nat.le (nat.S q) (nat.plus q (nat.S m)))) (((nat.le::plus::n::r) (m)) (nat.S q))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus m (nat.S q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.S q) ::::) (nat.le (nat.S q) (nat.plus q (nat.S m))))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus q (nat.S m))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.S q) ::::) (nat.le (nat.S q) (nat.plus q (nat.S m))))) (((logic.refl) (Set)) (nat.le (nat.S q) (nat.plus q (nat.S m))))) (nat.plus m (nat.S q))) (((((((logic.rewrite::l) (nat.nat)) (nat.S (nat.plus m q))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.plus q (nat.S m)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus q m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.S ::::) (nat.plus q (nat.S m)))) (((nat.plus::n::Sm) (q)) (m))) (nat.plus m q)) (((nat.commutative::plus) (q)) (m)))) (nat.plus m (nat.S q))) (((nat.plus::n::Sm) (m)) (q))))) (nat.plus (nat.S q) m)) (((nat.commutative::plus) (m)) (nat.S q)))))))))))))))) (p)

lt::mod::m::m : _
lt::mod::m::m = \(n : nat.nat) -> \(m : nat.nat) -> ((((nat.match::nat::prop) (\(:::: : nat.nat) -> (nat.lt nat.O ::::) -> nat.lt (mod n ::::) ::::)) (\(abs : nat.lt nat.O nat.O) -> (((connectives.falsity) (nat.lt (mod n nat.O) nat.O)) ((((logic.absurd) (nat.le (nat.S nat.O) nat.O)) (abs)) ((nat.not::le::Sn::O) (nat.O)))))) (\(p : nat.nat) -> ((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (n)) (\(q : nat.nat) -> mod::aux n n q)) (p)) (\(y : nat.nat) -> (nat.lt nat.O (nat.S p)) -> nat.lt y (nat.S p))) (\(:::: : nat.lt nat.O (nat.S p)) -> ((((nat.le::S::S) (mod::aux n n p)) (p)) (((((le::mod::aux::m::m) (n)) (n)) (p)) ((nat.le::n) (n))))))) (m)

div::aux::mod::aux : _
div::aux::mod::aux = \(p : nat.nat) -> ((((nat.nat::ind) (\(::x::365 : nat.nat) -> forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div::aux ::x::365 n m) (nat.S m)) (mod::aux ::x::365 n m)))) (\(n : nat.nat) -> \(m : nat.nat) -> (((sym::eq::div::aux) (nat.O)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (y n m) (nat.S m)) (mod::aux nat.O n m)))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat -> nat.nat)) (div::aux::body)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (y n m) (nat.S m)) (mod::aux nat.O n m)))) (((sym::eq::div::aux::body::O) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (y n m) (nat.S m)) (mod::aux nat.O n m)))) ((((((nat.eq::match::nat::type::O) (nat.nat)) (nat.O)) (\(q : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus n (nat.S m)) m)) (nat.leb n m))) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times y (nat.S m)) (mod::aux nat.O n m)))) ((((sym::eq::mod::aux) (nat.O)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> nat.match::nat::type (nat.nat) nat.O (\(q : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus m0 (nat.S n0)) n0)) (nat.leb m0 n0)) nat.O) n) m) (nat.S m)) (y n m)))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> nat.match::nat::type (nat.nat) nat.O (\(q : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus m0 (nat.S n0)) n0)) (nat.leb m0 n0)) nat.O) n) m) (nat.S m)) (y n m)))) (((sym::eq::mod::aux::body::O) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> nat.match::nat::type (nat.nat) nat.O (\(q : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus m0 (nat.S n0)) n0)) (nat.leb m0 n0)) nat.O) n) m) (nat.S m)) (y n m)))) ((((((nat.sym::eq::match::nat::type::O) (nat.nat)) (nat.O)) (\(q : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus n (nat.S m)) m)) (nat.leb n m))) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> y) n) m) (nat.S m)) n))) ((((nat.sym::eq::times) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) n))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.times::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) n))) (((nat.sym::eq::times::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) n))) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (y n))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (y n))) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (y n))) (((logic.refl) (nat.nat)) (n))))))))))))))))) (\(q : nat.nat) -> (((sym::eq::div::aux) (nat.S q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div::aux q n m) (nat.S m)) (mod::aux q n m))) -> forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (y n m) (nat.S m)) (mod::aux (nat.S q) n m)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat -> nat.nat)) (div::aux::body)) (q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div::aux q n m) (nat.S m)) (mod::aux q n m))) -> forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (y n m) (nat.S m)) (mod::aux (nat.S q) n m)))) ((((sym::eq::div::aux::body::S) (q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> (forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div::aux q n m) (nat.S m)) (mod::aux q n m))) -> forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (y n m) (nat.S m)) (mod::aux (nat.S q) n m)))) (\(Hind : forall (n : nat.nat) -> forall (m : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div::aux q n m) (nat.S m)) (mod::aux q n m))) -> (\(n : nat.nat) -> \(m : nat.nat) -> ((((((nat.eq::match::nat::type::S) (nat.nat)) (nat.O)) (\(q0 : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q0 (nat.minus n (nat.S m)) m)) (nat.leb n m))) (q)) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times y (nat.S m)) (mod::aux (nat.S q) n m)))) ((((sym::eq::mod::aux) (nat.S q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> nat.match::nat::type (nat.nat) nat.O (\(q0 : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q0 (nat.minus m0 (nat.S n0)) n0)) (nat.leb m0 n0)) (nat.S q)) n) m) (nat.S m)) (y n m)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat -> nat.nat)) (mod::aux::body)) (q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> nat.match::nat::type (nat.nat) nat.O (\(q0 : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q0 (nat.minus m0 (nat.S n0)) n0)) (nat.leb m0 n0)) (nat.S q)) n) m) (nat.S m)) (y n m)))) ((((sym::eq::mod::aux::body::S) (q)) (\(y : (nat.nat -> nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (nat.times (((\(m0 : nat.nat) -> \(n0 : nat.nat) -> nat.match::nat::type (nat.nat) nat.O (\(q0 : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q0 (nat.minus m0 (nat.S n0)) n0)) (nat.leb m0 n0)) (nat.S q)) n) m) (nat.S m)) (y n m)))) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.O)) (\(z : nat.nat) -> bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux z (nat.minus n (nat.S m)) m)) (nat.leb n m))) (q)) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times y (nat.S m)) (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) (nat.leb n m))))) ((((((nat.leb::elim) (n)) (m)) (\(:::: : bool.bool) -> logic.eq (nat.nat) n (nat.plus (nat.times (bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus n (nat.S m)) m)) ::::) (nat.S m)) (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) ::::)))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (nat.O)) (nat.S (div::aux q (nat.minus n (nat.S m)) m))) (\(x : nat.nat) -> (nat.le n m) -> logic.eq (nat.nat) n (nat.plus (nat.times x (nat.S m)) (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) bool.true)))) ((((nat.sym::eq::times) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> (nat.le n m) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) bool.true)))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.times::body)) (\(y : (nat.nat -> nat.nat)) -> (nat.le n m) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) bool.true)))) (((nat.sym::eq::times::body::O) (\(y : (nat.nat -> nat.nat)) -> (nat.le n m) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) (bool.match::bool::type (nat.nat) n (mod::aux q (nat.minus n (nat.S m)) m) bool.true)))) ((((((bool.sym::eq::match::bool::type::true) (nat.nat)) (n)) (mod::aux q (nat.minus n (nat.S m)) m)) (\(y : nat.nat) -> (nat.le n m) -> logic.eq (nat.nat) n (nat.plus nat.O y))) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> (nat.le n m) -> logic.eq (nat.nat) n (y n))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> (nat.le n m) -> logic.eq (nat.nat) n (y n))) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> (nat.le n m) -> logic.eq (nat.nat) n (y n))) (\(lenm : nat.le n m) -> (((logic.refl) (nat.nat)) (n)))))))))))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (n)) (mod::aux q (nat.minus n (nat.S m)) m)) (\(x : nat.nat) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (nat.times (bool.match::bool::type (nat.nat) nat.O (nat.S (div::aux q (nat.minus n (nat.S m)) m)) bool.false) (nat.S m)) x))) ((((((bool.sym::eq::match::bool::type::false) (nat.nat)) (nat.O)) (nat.S (div::aux q (nat.minus n (nat.S m)) m))) (\(y : nat.nat) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (nat.times y (nat.S m)) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((nat.sym::eq::times) (nat.S (div::aux q (nat.minus n (nat.S m)) m))) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.times::body)) (div::aux q (nat.minus n (nat.S m)) m)) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((nat.sym::eq::times::body::S) (div::aux q (nat.minus n (nat.S m)) m)) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (y (nat.S m)) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((nat.sym::eq::plus) (nat.S m)) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (y (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m))) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.plus::body)) (m)) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (y (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m))) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((nat.sym::eq::plus::body::S) (m)) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (nat.plus (y (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m))) (mod::aux q (nat.minus n (nat.S m)) m)))) ((((nat.sym::eq::plus) (nat.S (nat.plus m (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m))))) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (y (mod::aux q (nat.minus n (nat.S m)) m)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.plus::body)) (nat.plus m (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m)))) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (y (mod::aux q (nat.minus n (nat.S m)) m)))) ((((nat.sym::eq::plus::body::S) (nat.plus m (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m)))) (\(y : (nat.nat -> nat.nat)) -> (connectives.Not (nat.le n m)) -> logic.eq (nat.nat) n (y (mod::aux q (nat.minus n (nat.S m)) m)))) (\(lenm : connectives.Not (nat.le n m)) -> (((((((logic.eq::ind::r) (nat.nat)) (nat.plus m (nat.plus (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m)) (mod::aux q (nat.minus n (nat.S m)) m)))) (\(x : nat.nat) -> logic.eq (nat.nat) n (nat.S x))) (((((((logic.eq::ind) (nat.nat)) (nat.minus n (nat.S m))) (\(x::1 : nat.nat) -> logic.eq (nat.nat) n (nat.S (nat.plus m x::1)))) (((((logic.eq::coerc) (logic.eq (nat.nat) n (nat.plus (nat.minus n (nat.S m)) (nat.S m)))) (logic.eq (nat.nat) n (nat.S (nat.plus m (nat.minus n (nat.S m)))))) ((((nat.plus::minus::m::m) (n)) (nat.S m)) ((((nat.not::le::to::lt) (n)) (m)) (lenm)))) (((((((logic.rewrite::r) (nat.nat)) (nat.pred (nat.minus n m))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n (nat.plus :::: (nat.S m))) (logic.eq (nat.nat) n (nat.S (nat.plus m (nat.minus n (nat.S m))))))) (((((((logic.rewrite::r) (nat.nat)) (nat.pred (nat.minus n m))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n (nat.plus (nat.pred (nat.minus n m)) (nat.S m))) (logic.eq (nat.nat) n (nat.S (nat.plus m ::::))))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus m (nat.S (nat.pred (nat.minus n m))))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n (nat.plus (nat.pred (nat.minus n m)) (nat.S m))) (logic.eq (nat.nat) n ::::))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus m (nat.S (nat.pred (nat.minus n m))))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) n ::::) (logic.eq (nat.nat) n (nat.plus m (nat.S (nat.pred (nat.minus n m))))))) (((logic.refl) (Set)) (logic.eq (nat.nat) n (nat.plus m (nat.S (nat.pred (nat.minus n m))))))) (nat.plus (nat.pred (nat.minus n m)) (nat.S m))) (((((((logic.rewrite::l) (nat.nat)) (nat.S (nat.plus (nat.pred (nat.minus n m)) m))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.plus m (nat.S (nat.pred (nat.minus n m)))))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus m (nat.pred (nat.minus n m)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.S ::::) (nat.plus m (nat.S (nat.pred (nat.minus n m)))))) (((nat.plus::n::Sm) (m)) (nat.pred (nat.minus n m)))) (nat.plus (nat.pred (nat.minus n m)) m)) (((nat.commutative::plus) (m)) (nat.pred (nat.minus n m))))) (nat.plus (nat.pred (nat.minus n m)) (nat.S m))) (((nat.plus::n::Sm) (nat.pred (nat.minus n m))) (m))))) (nat.S (nat.plus m (nat.pred (nat.minus n m))))) (((nat.plus::n::Sm) (m)) (nat.pred (nat.minus n m))))) (nat.minus n (nat.S m))) (((nat.eq::minus::S::pred) (n)) (m)))) (nat.minus n (nat.S m))) (((nat.eq::minus::S::pred) (n)) (m))))) (nat.plus (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m)) (mod::aux q (nat.minus n (nat.S m)) m))) (((Hind) (nat.minus n (nat.S m))) (m)))) (nat.plus (nat.plus m (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m))) (mod::aux q (nat.minus n (nat.S m)) m))) ((((nat.associative::plus) (m)) (nat.times (div::aux q (nat.minus n (nat.S m)) m) (nat.S m))) (mod::aux q (nat.minus n (nat.S m)) m)))))))))))))))))))))))))) (p)

div::mod : _
div::mod = \(n : nat.nat) -> \(m : nat.nat) -> ((((nat.match::nat::prop) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div n ::::) ::::) (mod n ::::)))) ((((nat.sym::eq::times) (div n nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y nat.O) (mod n nat.O)))) ((((((nat.sym::eq::match::nat::type::O) (nat.nat)) (nat.S n)) (\(p : nat.nat) -> div::aux n n p)) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.filter::nat::type (nat.nat -> nat.nat) nat.times::body y nat.O) (nat.match::nat::type (nat.nat) n (\(p : nat.nat) -> mod::aux n n p) nat.O)))) ((((((nat.sym::eq::filter::nat::type::S) (nat.nat -> nat.nat)) (nat.times::body)) (n)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y nat.O) (mod n nat.O)))) ((((nat.sym::eq::times::body::S) (n)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y nat.O) (mod n nat.O)))) ((((((nat.sym::eq::match::nat::type::O) (nat.nat)) (n)) (\(p : nat.nat) -> mod::aux n n p)) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.plus nat.O (nat.times n nat.O)) y))) ((((nat.sym::eq::plus) (nat.O)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y (nat.times n nat.O)) n))) (((((nat.sym::eq::filter::nat::type::O) (nat.nat -> nat.nat)) (nat.plus::body)) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y (nat.times n nat.O)) n))) (((nat.sym::eq::plus::body::O) (\(y : (nat.nat -> nat.nat)) -> logic.eq (nat.nat) n (nat.plus (y (nat.times n nat.O)) n))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus :::: n))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus n nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((logic.refl) (nat.nat)) (n))) (nat.plus n nat.O)) ((nat.plus::n::O) (n)))) (nat.plus nat.O n)) (((nat.commutative::plus) (nat.O)) (n)))) (nat.times n nat.O)) ((nat.times::n::O) (n)))))))))))) (\(auto : nat.nat) -> ((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (nat.S n)) (\(p : nat.nat) -> div::aux n n p)) (auto)) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times y (nat.S auto)) (nat.match::nat::type (nat.nat) n (\(p : nat.nat) -> mod::aux n n p) (nat.S auto))))) (((((((nat.sym::eq::match::nat::type::S) (nat.nat)) (n)) (\(p : nat.nat) -> mod::aux n n p)) (auto)) (\(y : nat.nat) -> logic.eq (nat.nat) n (nat.plus (nat.times (div::aux n n auto) (nat.S auto)) y))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus (nat.times (div::aux n n auto) (nat.S auto)) (mod::aux n n auto))) (\(:::: : nat.nat) -> logic.eq (nat.nat) :::: (nat.plus (nat.times (div::aux n n auto) (nat.S auto)) (mod::aux n n auto)))) (((logic.refl) (nat.nat)) (nat.plus (nat.times (div::aux n n auto) (nat.S auto)) (mod::aux n n auto)))) (n)) ((((div::aux::mod::aux) (n)) (n)) (auto)))))) (m)

eq::times::div::minus::mod : _
eq::times::div::minus::mod = \(a : nat.nat) -> \(b : nat.nat) -> ((((logic.eq::coerc) (logic.eq (nat.nat) (nat.times b (div a b)) (nat.minus (nat.plus (nat.times b (div a b)) (mod a b)) (mod a b)))) (logic.eq (nat.nat) (nat.times (div a b) b) (nat.minus a (mod a b)))) (((nat.minus::plus::m::m) (nat.times b (div a b))) (mod a b))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus (mod a b) (nat.times b (div a b)))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) (nat.times b (div a b)) (nat.minus :::: (mod a b))) (logic.eq (nat.nat) (nat.times (div a b) b) (nat.minus a (mod a b))))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b (div a b))) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) (nat.times b (div a b)) (nat.minus (nat.plus (mod a b) (nat.times b (div a b))) (mod a b))) (logic.eq (nat.nat) :::: (nat.minus a (mod a b))))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (logic.eq (nat.nat) (nat.times b (div a b)) (nat.minus :::: (mod a b))) (logic.eq (nat.nat) (nat.times b (div a b)) (nat.minus a (mod a b))))) (((logic.refl) (Set)) (logic.eq (nat.nat) (nat.times b (div a b)) (nat.minus a (mod a b))))) (nat.plus (mod a b) (nat.times b (div a b)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b (div a b)) (mod a b))) (\(:::: : nat.nat) -> logic.eq (nat.nat) a ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times (div a b) b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a (nat.plus :::: (mod a b)))) (((div::mod) (a)) (b))) (nat.times b (div a b))) (((nat.commutative::times) (div a b)) (b)))) (nat.plus (mod a b) (nat.times b (div a b)))) (((nat.commutative::plus) (nat.times b (div a b))) (mod a b))))) (nat.times (div a b) b)) (((nat.commutative::times) (div a b)) (b)))) (nat.plus (nat.times b (div a b)) (mod a b))) (((nat.commutative::plus) (nat.times b (div a b))) (mod a b)))

postulate div::mod::spec : nat.nat -> nat.nat -> nat.nat -> nat.nat -> Set
postulate div::mod::spec::intro : forall (n : nat.nat) -> forall (m : nat.nat) -> forall (q : nat.nat) -> forall (r : nat.nat) -> (nat.lt r m) -> (logic.eq (nat.nat) n (nat.plus (nat.times q m) r)) -> div::mod::spec n m q r
postulate match::div::mod::spec::prop : forall (n : nat.nat) -> forall (m : nat.nat) -> forall (q : nat.nat) -> forall (r : nat.nat) -> forall (return : Set) -> ((nat.lt r m) -> (logic.eq (nat.nat) n (nat.plus (nat.times q m) r)) -> return) -> (div::mod::spec n m q r) -> return
div::mod::spec::div::mod : _
div::mod::spec::div::mod = \(n : nat.nat) -> \(m : nat.nat) -> \(posm : nat.lt nat.O m) -> (((((((div::mod::spec::intro) (n)) (m)) (div n m)) (mod n m)) ((((lt::mod::m::m) (n)) (m)) (posm))) (((((((logic.rewrite::r) (nat.nat)) (nat.times m (div n m))) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus :::: (mod n m)))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus (mod n m) (nat.times m (div n m)))) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((logic.refl) (nat.nat)) (n))) (nat.plus (mod n m) (nat.times m (div n m)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times m (div n m)) (mod n m))) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times (div n m) m)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus :::: (mod n m)))) (((div::mod) (n)) (m))) (nat.times m (div n m))) (((nat.commutative::times) (div n m)) (m)))) (nat.plus (mod n m) (nat.times m (div n m)))) (((nat.commutative::plus) (nat.times m (div n m))) (mod n m))))) (nat.plus (nat.times m (div n m)) (mod n m))) (((nat.commutative::plus) (nat.times m (div n m))) (mod n m)))) (nat.times (div n m) m)) (((nat.commutative::times) (div n m)) (m))))

let::clause::1078 : _
let::clause::1078 = \(a : nat.nat) -> \(b : nat.nat) -> \(q : nat.nat) -> \(r : nat.nat) -> \(q1 : nat.nat) -> \(r1 : nat.nat) -> \(::clearme : div::mod::spec a b q r) -> (\(ltrb : nat.lt r b) -> (\(spec : logic.eq (nat.nat) a (nat.plus (nat.times q b) r)) -> (\(::clearme0 : div::mod::spec a b q1 r1) -> (\(ltr1b : nat.lt r1 b) -> (\(spec1 : logic.eq (nat.nat) a (nat.plus (nat.times q1 b) r1)) -> (\(leqq1 : nat.le q q1) -> (\(ltqq1 : nat.lt q q1) -> (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b q) r)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times q b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a (nat.plus :::: r))) (spec)) (nat.times b q)) (((nat.commutative::times) (q)) (b)))) (nat.plus r (nat.times b q))) (((nat.commutative::plus) (nat.times b q)) (r))))))))))

let::clause::1062 : _
let::clause::1062 = \(a : nat.nat) -> \(b : nat.nat) -> \(q : nat.nat) -> \(r : nat.nat) -> \(q1 : nat.nat) -> \(r1 : nat.nat) -> \(::clearme : div::mod::spec a b q r) -> (\(ltrb : nat.lt r b) -> (\(spec : logic.eq (nat.nat) a (nat.plus (nat.times q b) r)) -> (\(::clearme0 : div::mod::spec a b q1 r1) -> (\(ltr1b : nat.lt r1 b) -> (\(spec1 : logic.eq (nat.nat) a (nat.plus (nat.times q1 b) r1)) -> (\(leqq1 : connectives.Not (nat.le q q1)) -> (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b q1) r1)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times q1 b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a (nat.plus :::: r1))) (spec1)) (nat.times b q1)) (((nat.commutative::times) (q1)) (b)))) (nat.plus r1 (nat.times b q1))) (((nat.commutative::plus) (nat.times b q1)) (r1)))))))))

div::mod::spec::to::eq : _
div::mod::spec::to::eq = \(a : nat.nat) -> \(b : nat.nat) -> \(q : nat.nat) -> \(r : nat.nat) -> \(q1 : nat.nat) -> \(r1 : nat.nat) -> \(::clearme : div::mod::spec a b q r) -> ((((((((match::div::mod::spec::prop) (a)) (b)) (q)) (r)) ((div::mod::spec a b q1 r1) -> logic.eq (nat.nat) q q1)) (\(ltrb : nat.lt r b) -> (\(spec : logic.eq (nat.nat) a (nat.plus (nat.times q b) r)) -> (\(::clearme0 : div::mod::spec a b q1 r1) -> ((((((((match::div::mod::spec::prop) (a)) (b)) (q1)) (r1)) (logic.eq (nat.nat) q q1)) (\(ltr1b : nat.lt r1 b) -> (\(spec1 : logic.eq (nat.nat) a (nat.plus (nat.times q1 b) r1)) -> ((((((nat.leb::elim) (q)) (q1)) (\(:::: : bool.bool) -> logic.eq (nat.nat) q q1)) (\(leqq1 : nat.le q q1) -> (((((((connectives.match::Or::prop) (nat.lt q q1)) (logic.eq (nat.nat) q q1)) (logic.eq (nat.nat) q q1)) (\(ltqq1 : nat.lt q q1) -> (((connectives.falsity) (logic.eq (nat.nat) q q1)) ((((logic.absurd) (nat.le (nat.S a) a)) ((((((nat.lt::to::le::to::lt) (a)) (nat.times (nat.S q) b)) (a)) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times q b) r)) (\(x : nat.nat) -> nat.lt x (nat.times (nat.S q) b))) (((((logic.eq::coerc) (nat.lt (nat.plus (nat.times q b) r) (nat.plus (nat.times q b) b))) (nat.lt (nat.plus (nat.times q b) r) (nat.times (nat.S q) b))) (((((nat.monotonic::lt::plus::r) (nat.times q b)) (r)) (b)) (ltrb))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus :::: r) (nat.plus :::: b)) (nat.lt (nat.plus :::: r) (nat.times (nat.S q) b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q) r) (nat.plus (nat.times b q) b)) (nat.lt :::: (nat.times (nat.S q) b)))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q) r) (nat.plus (nat.times b q) b)) (nat.lt :::: (nat.times (nat.S q) b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b (nat.S q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q) r) (nat.plus (nat.times b q) b)) (nat.lt a ::::))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus b (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q) r) (nat.plus (nat.times b q) b)) (nat.lt a ::::))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt :::: (nat.plus (nat.times b q) b)) (nat.lt a (nat.plus b (nat.times b q))))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt :::: (nat.plus (nat.times b q) b)) (nat.lt a (nat.plus b (nat.times b q))))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus b (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt a ::::) (nat.lt a (nat.plus b (nat.times b q))))) (((logic.refl) (Set)) (nat.lt a (nat.plus b (nat.times b q))))) (nat.plus (nat.times b q) b)) (((nat.commutative::plus) (nat.times b q)) (b)))) (nat.plus r (nat.times b q))) (((((((((((((((let::clause::1078) (a)) (b)) (q)) (r)) (q1)) (r1)) (::clearme)) (ltrb)) (spec)) (::clearme0)) (ltr1b)) (spec1)) (leqq1)) (ltqq1)))) (nat.plus (nat.times b q) r)) (((nat.commutative::plus) (nat.times b q)) (r)))) (nat.times b (nat.S q))) (((nat.times::n::Sm) (b)) (q)))) (nat.times (nat.S q) b)) (((nat.commutative::times) (nat.S q)) (b)))) (nat.plus r (nat.times b q))) (((((((((((((((let::clause::1078) (a)) (b)) (q)) (r)) (q1)) (r1)) (::clearme)) (ltrb)) (spec)) (::clearme0)) (ltr1b)) (spec1)) (leqq1)) (ltqq1)))) (nat.plus (nat.times b q) r)) (((nat.commutative::plus) (nat.times b q)) (r)))) (nat.times q b)) (((nat.commutative::times) (q)) (b))))) (a)) (spec))) ((((((nat.transitive::le) (nat.times (nat.S q) b)) (nat.times q1 b)) (a)) (((((logic.eq::coerc) (nat.le (nat.times b (nat.S q)) (nat.times b q1))) (nat.le (nat.times (nat.S q) b) (nat.times q1 b))) (((((nat.monotonic::le::times::r) (b)) (nat.S q)) (q1)) (ltqq1))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b (nat.S q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b (nat.S q)) (nat.times b q1)) (nat.le :::: (nat.times q1 b)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus b (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b (nat.S q)) (nat.times b q1)) (nat.le :::: (nat.times q1 b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q1)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b (nat.S q)) (nat.times b q1)) (nat.le (nat.plus b (nat.times b q)) ::::))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus b (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.times b q1)) (nat.le (nat.plus b (nat.times b q)) (nat.times b q1)))) (((logic.refl) (Set)) (nat.le (nat.plus b (nat.times b q)) (nat.times b q1)))) (nat.times b (nat.S q))) (((nat.times::n::Sm) (b)) (q)))) (nat.times q1 b)) (((nat.commutative::times) (q1)) (b)))) (nat.times b (nat.S q))) (((nat.times::n::Sm) (b)) (q)))) (nat.times (nat.S q) b)) (((nat.commutative::times) (nat.S q)) (b))))) (((((logic.eq::coerc) (nat.le (nat.times q1 b) (nat.plus (nat.times q1 b) r1))) (nat.le (nat.times q1 b) a)) (((nat.le::plus::n::r) (r1)) (nat.times q1 b))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q1)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.plus :::: r1)) (nat.le :::: a))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r1 (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b q1) ::::) (nat.le (nat.times b q1) a))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b q1) ::::) (nat.le (nat.times b q1) a))) (((logic.refl) (Set)) (nat.le (nat.times b q1) a))) (nat.plus r1 (nat.times b q1))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b q1) r1)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times q1 b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a (nat.plus :::: r1))) (spec1)) (nat.times b q1)) (((nat.commutative::times) (q1)) (b)))) (nat.plus r1 (nat.times b q1))) (((nat.commutative::plus) (nat.times b q1)) (r1))))) (nat.plus (nat.times b q1) r1)) (((nat.commutative::plus) (nat.times b q1)) (r1)))) (nat.times q1 b)) (((nat.commutative::times) (q1)) (b))))))) ((nat.not::le::Sn::n) (a)))))) (\(::x::172 : logic.eq (nat.nat) q q1) -> (((((((logic.rewrite::l) (nat.nat)) (q)) (\(:::: : nat.nat) -> logic.eq (nat.nat) q ::::)) (((logic.refl) (nat.nat)) (q))) (q1)) (::x::172)))) ((((nat.le::to::or::lt::eq) (q)) (q1)) (leqq1))))) (\(leqq1 : connectives.Not (nat.le q q1)) -> (((connectives.falsity) (logic.eq (nat.nat) q q1)) ((((logic.absurd) (nat.le (nat.S a) a)) ((((((nat.lt::to::le::to::lt) (a)) (nat.times (nat.S q1) b)) (a)) (((((((logic.eq::ind::r) (nat.nat)) (nat.plus (nat.times q1 b) r1)) (\(x : nat.nat) -> nat.lt x (nat.times (nat.S q1) b))) (((((logic.eq::coerc) (nat.lt (nat.plus (nat.times q1 b) r1) (nat.plus (nat.times q1 b) b))) (nat.lt (nat.plus (nat.times q1 b) r1) (nat.times (nat.S q1) b))) (((((nat.monotonic::lt::plus::r) (nat.times q1 b)) (r1)) (b)) (ltr1b))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q1)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus :::: r1) (nat.plus :::: b)) (nat.lt (nat.plus :::: r1) (nat.times (nat.S q1) b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r1 (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q1) r1) (nat.plus (nat.times b q1) b)) (nat.lt :::: (nat.times (nat.S q1) b)))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q1) r1) (nat.plus (nat.times b q1) b)) (nat.lt :::: (nat.times (nat.S q1) b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b (nat.S q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q1) r1) (nat.plus (nat.times b q1) b)) (nat.lt a ::::))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus b (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt (nat.plus (nat.times b q1) r1) (nat.plus (nat.times b q1) b)) (nat.lt a ::::))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r1 (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt :::: (nat.plus (nat.times b q1) b)) (nat.lt a (nat.plus b (nat.times b q1))))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt :::: (nat.plus (nat.times b q1) b)) (nat.lt a (nat.plus b (nat.times b q1))))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus b (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.lt a ::::) (nat.lt a (nat.plus b (nat.times b q1))))) (((logic.refl) (Set)) (nat.lt a (nat.plus b (nat.times b q1))))) (nat.plus (nat.times b q1) b)) (((nat.commutative::plus) (nat.times b q1)) (b)))) (nat.plus r1 (nat.times b q1))) ((((((((((((((let::clause::1062) (a)) (b)) (q)) (r)) (q1)) (r1)) (::clearme)) (ltrb)) (spec)) (::clearme0)) (ltr1b)) (spec1)) (leqq1)))) (nat.plus (nat.times b q1) r1)) (((nat.commutative::plus) (nat.times b q1)) (r1)))) (nat.times b (nat.S q1))) (((nat.times::n::Sm) (b)) (q1)))) (nat.times (nat.S q1) b)) (((nat.commutative::times) (nat.S q1)) (b)))) (nat.plus r1 (nat.times b q1))) ((((((((((((((let::clause::1062) (a)) (b)) (q)) (r)) (q1)) (r1)) (::clearme)) (ltrb)) (spec)) (::clearme0)) (ltr1b)) (spec1)) (leqq1)))) (nat.plus (nat.times b q1) r1)) (((nat.commutative::plus) (nat.times b q1)) (r1)))) (nat.times q1 b)) (((nat.commutative::times) (q1)) (b))))) (a)) (spec1))) ((((((nat.transitive::le) (nat.times (nat.S q1) b)) (nat.times q b)) (a)) (((((logic.eq::coerc) (nat.le (nat.times b (nat.S q1)) (nat.times b q))) (nat.le (nat.times (nat.S q1) b) (nat.times q b))) (((((nat.monotonic::le::times::r) (b)) (nat.S q1)) (q)) ((((nat.not::le::to::lt) (q)) (q1)) (leqq1)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b (nat.S q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b (nat.S q1)) (nat.times b q)) (nat.le :::: (nat.times q b)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus b (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b (nat.S q1)) (nat.times b q)) (nat.le :::: (nat.times q b)))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b (nat.S q1)) (nat.times b q)) (nat.le (nat.plus b (nat.times b q1)) ::::))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus b (nat.times b q1))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.times b q)) (nat.le (nat.plus b (nat.times b q1)) (nat.times b q)))) (((logic.refl) (Set)) (nat.le (nat.plus b (nat.times b q1)) (nat.times b q)))) (nat.times b (nat.S q1))) (((nat.times::n::Sm) (b)) (q1)))) (nat.times q b)) (((nat.commutative::times) (q)) (b)))) (nat.times b (nat.S q1))) (((nat.times::n::Sm) (b)) (q1)))) (nat.times (nat.S q1) b)) (((nat.commutative::times) (nat.S q1)) (b))))) (((((logic.eq::coerc) (nat.le (nat.times q b) (nat.plus (nat.times q b) r))) (nat.le (nat.times q b) a)) (((nat.le::plus::n::r) (r)) (nat.times q b))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.plus :::: r)) (nat.le :::: a))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r (nat.times b q))) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b q) ::::) (nat.le (nat.times b q) a))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (nat.times b q) ::::) (nat.le (nat.times b q) a))) (((logic.refl) (Set)) (nat.le (nat.times b q) a))) (nat.plus r (nat.times b q))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b q) r)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times q b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) a (nat.plus :::: r))) (spec)) (nat.times b q)) (((nat.commutative::times) (q)) (b)))) (nat.plus r (nat.times b q))) (((nat.commutative::plus) (nat.times b q)) (r))))) (nat.plus (nat.times b q) r)) (((nat.commutative::plus) (nat.times b q)) (r)))) (nat.times q b)) (((nat.commutative::times) (q)) (b))))))) ((nat.not::le::Sn::n) (a))))))))) (::clearme0)))))) (::clearme))

div::mod::spec::to::eq2 : _
div::mod::spec::to::eq2 = \(a : nat.nat) -> \(b : nat.nat) -> \(q : nat.nat) -> \(r : nat.nat) -> \(q1 : nat.nat) -> \(r1 : nat.nat) -> \(spec : div::mod::spec a b q r) -> (\(spec1 : div::mod::spec a b q1 r1) -> ((((((((match::div::mod::spec::prop) (a)) (b)) (q)) (r)) (logic.eq (nat.nat) r r1)) (\(:::: : nat.lt r b) -> (\(eqa : logic.eq (nat.nat) a (nat.plus (nat.times q b) r)) -> ((((((((match::div::mod::spec::prop) (a)) (b)) (q1)) (r1)) (logic.eq (nat.nat) r r1)) (\(::0 : nat.lt r1 b) -> (\(eqa1 : logic.eq (nat.nat) a (nat.plus (nat.times q1 b) r1)) -> (((((nat.injective::plus::r) (nat.times q b)) (r)) (r1)) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) (nat.plus ::::1 r) (nat.plus (nat.times q b) r1))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r (nat.times b q))) (\(::::1 : nat.nat) -> logic.eq (nat.nat) ::::1 (nat.plus (nat.times q b) r1))) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) ::::1 (nat.plus (nat.times q b) r1))) (((((((logic.rewrite::r) (nat.nat)) (nat.times b q)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a (nat.plus ::::1 r1))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus r1 (nat.times b q))) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a ::::1)) (((((((logic.rewrite::l) (nat.nat)) (a)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a ::::1)) (((logic.refl) (nat.nat)) (a))) (nat.plus r1 (nat.times b q))) (((((((logic.rewrite::r) (nat.nat)) (q1)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a (nat.plus r1 (nat.times b ::::1)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b q1) r1)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a ::::1)) (((((((logic.rewrite::l) (nat.nat)) (nat.times q1 b)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a (nat.plus ::::1 r1))) (eqa1)) (nat.times b q1)) (((nat.commutative::times) (q1)) (b)))) (nat.plus r1 (nat.times b q1))) (((nat.commutative::plus) (nat.times b q1)) (r1)))) (q)) (((((((((div::mod::spec::to::eq) (a)) (b)) (q)) (r)) (q1)) (r1)) (spec)) (spec1))))) (nat.plus (nat.times b q) r1)) (((nat.commutative::plus) (nat.times b q)) (r1)))) (nat.times q b)) (((nat.commutative::times) (q)) (b)))) (nat.plus r (nat.times b q))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times b q) r)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a ::::1)) (((((((logic.rewrite::l) (nat.nat)) (nat.times q b)) (\(::::1 : nat.nat) -> logic.eq (nat.nat) a (nat.plus ::::1 r))) (eqa)) (nat.times b q)) (((nat.commutative::times) (q)) (b)))) (nat.plus r (nat.times b q))) (((nat.commutative::plus) (nat.times b q)) (r))))) (nat.plus (nat.times b q) r)) (((nat.commutative::plus) (nat.times b q)) (r)))) (nat.times q b)) (((nat.commutative::times) (q)) (b))))))) (spec1))))) (spec)))

div::times : _
div::times = \(a : nat.nat) -> \(b : nat.nat) -> \(posb : nat.lt nat.O b) -> (((((((((div::mod::spec::to::eq) (nat.times a b)) (b)) (div (nat.times a b) b)) (mod (nat.times a b) b)) (a)) (nat.O)) ((((div::mod::spec::div::mod) (nat.times a b)) (b)) (posb))) (((((((div::mod::spec::intro) (nat.times a b)) (b)) (a)) (nat.O)) (posb)) (((((((logic.rewrite::r) (nat.nat)) (nat.plus nat.O (nat.times a b))) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.times a b) ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times a b)) (\(:::: : nat.nat) -> logic.eq (nat.nat) (nat.times a b) ::::)) (((logic.refl) (nat.nat)) (nat.times a b))) (nat.plus nat.O (nat.times a b))) ((nat.plus::O::n) (nat.times a b)))) (nat.plus (nat.times a b) nat.O)) (((nat.commutative::plus) (nat.times a b)) (nat.O)))))

eq::div::O : _
eq::div::O = \(n : nat.nat) -> \(m : nat.nat) -> \(ltnm : nat.lt n m) -> (((((((((div::mod::spec::to::eq) (n)) (m)) (div n m)) (mod n m)) (nat.O)) (n)) ((((div::mod::spec::div::mod) (n)) (m)) ((((nat.ltn::to::ltO) (n)) (m)) (ltnm)))) (((((((div::mod::spec::intro) (n)) (m)) (nat.O)) (n)) (ltnm)) (((((((logic.rewrite::r) (nat.nat)) (nat.times m nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus :::: n))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n (nat.plus :::: n))) (((((((logic.rewrite::r) (nat.nat)) (nat.plus n nat.O)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((((((logic.rewrite::l) (nat.nat)) (n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) n ::::)) (((logic.refl) (nat.nat)) (n))) (nat.plus n nat.O)) ((nat.plus::n::O) (n)))) (nat.plus nat.O n)) (((nat.commutative::plus) (nat.O)) (n)))) (nat.times m nat.O)) ((nat.times::n::O) (m)))) (nat.times nat.O m)) (((nat.commutative::times) (nat.O)) (m)))))

mod::O::n : _
mod::O::n = \(n : nat.nat) -> ((((logic.sym::eq) (nat.nat)) (nat.O)) (mod nat.O n)) (((((logic.eq::coerc) (logic.eq (nat.nat) nat.O (mod nat.O n))) (logic.eq (nat.nat) nat.O (mod nat.O n))) (((nat.le::n::O::to::eq) (mod nat.O n)) (((((logic.eq::coerc) (nat.le (nat.minus (nat.plus (mod nat.O n) (nat.times n (div nat.O n))) (nat.plus nat.O (nat.times n (div nat.O n)))) (nat.plus (mod nat.O n) (nat.times n (div nat.O n))))) (nat.le (mod nat.O n) nat.O)) (((nat.minus::le) (nat.plus (mod nat.O n) (nat.times n (div nat.O n)))) (nat.plus nat.O (nat.times n (div nat.O n))))) (((((((logic.rewrite::r) (nat.nat)) (nat.minus (mod nat.O n) nat.O)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.plus (mod nat.O n) (nat.times n (div nat.O n)))) (nat.le (mod nat.O n) nat.O))) (((((((logic.rewrite::l) (nat.nat)) (mod nat.O n)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le :::: (nat.plus (mod nat.O n) (nat.times n (div nat.O n)))) (nat.le (mod nat.O n) nat.O))) (((((((logic.rewrite::l) (nat.nat)) (nat.O)) (\(:::: : nat.nat) -> logic.eq (Set) (nat.le (mod nat.O n) ::::) (nat.le (mod nat.O n) nat.O))) (((logic.refl) (Set)) (nat.le (mod nat.O n) nat.O))) (nat.plus (mod nat.O n) (nat.times n (div nat.O n)))) (((((((logic.rewrite::l) (nat.nat)) (nat.plus (nat.times n (div nat.O n)) (mod nat.O n))) (\(:::: : nat.nat) -> logic.eq (nat.nat) nat.O ::::)) (((((((logic.rewrite::l) (nat.nat)) (nat.times (div nat.O n) n)) (\(:::: : nat.nat) -> logic.eq (nat.nat) nat.O (nat.plus :::: (mod nat.O n)))) (((div::mod) (nat.O)) (n))) (nat.times n (div nat.O n))) (((nat.commutative::times) (div nat.O n)) (n)))) (nat.plus (mod nat.O n) (nat.times n (div nat.O n)))) (((nat.commutative::plus) (nat.times n (div nat.O n))) (mod nat.O n))))) (nat.minus (mod nat.O n) nat.O)) ((nat.minus::n::O) (mod nat.O n)))) (nat.minus (nat.plus (mod nat.O n) (nat.times n (div nat.O n))) (nat.plus nat.O (nat.times n (div nat.O n))))) ((((nat.minus::plus::plus::l) (mod nat.O n)) (nat.O)) (nat.times n (div nat.O n))))))) (((logic.refl) (Set)) (logic.eq (nat.nat) nat.O (mod nat.O n))))

