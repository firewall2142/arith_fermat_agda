gcd_aux :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat))))).

gcd_aux_body :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x =>
           cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat))))).

axiom_gcd_aux :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        connectives.equal
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (gcd_aux x)
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
             gcd_aux_body
             x))).

def eq_gcd_aux :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (gcd_aux x)
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
             gcd_aux_body
             x)))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (gcd_aux p)
    (nat.filter_nat_type
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       gcd_aux_body
       p)
    (axiom_gcd_aux p).

def sym_eq_gcd_aux :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (nat.filter_nat_type
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
             gcd_aux_body
             x)
          (gcd_aux x)))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (gcd_aux p)
    (nat.filter_nat_type
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       gcd_aux_body
       p)
    (eq_gcd_aux p).

axiom_gcd_aux_body_O :
  cts.Term
    cts.star
    (connectives.equal
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       (gcd_aux_body nat.O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        n:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        m)).

def eq_gcd_aux_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       (gcd_aux_body nat.O)
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        n:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        m))
  :=
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (gcd_aux_body nat.O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     m)
    axiom_gcd_aux_body_O.

def sym_eq_gcd_aux_body_O :
  cts.Term
    cts.star
    (leibniz.leibniz
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       (m:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        n:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        m)
       (gcd_aux_body nat.O))
  :=
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (gcd_aux_body nat.O)
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     m)
    eq_gcd_aux_body_O.

axiom_gcd_aux_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        connectives.equal
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (gcd_aux_body (nat.S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           n:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           bool.match_bool_type nat.nat n (gcd_aux x n (div_mod.mod m n)) (primes.dividesb n m)))).

def eq_gcd_aux_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (gcd_aux_body (nat.S x))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           n:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           bool.match_bool_type nat.nat n (gcd_aux x n (div_mod.mod m n)) (primes.dividesb n m))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.equal_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (gcd_aux_body (nat.S p))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     bool.match_bool_type nat.nat n (gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m))
    (axiom_gcd_aux_body_S p).

def sym_eq_gcd_aux_body_S :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        leibniz.leibniz
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x0 => cts.prod cts.box cts.box cts.box cts.I nat.nat (x1 => nat.nat)))
          (m:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           n:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           bool.match_bool_type nat.nat n (gcd_aux x n (div_mod.mod m n)) (primes.dividesb n m))
          (gcd_aux_body (nat.S x))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  leibniz.sym_leibniz
    (cts.prod
       cts.box
       cts.box
       cts.box
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
    (gcd_aux_body (nat.S p))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     bool.match_bool_type nat.nat n (gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m))
    (eq_gcd_aux_body_S p).

def gcd :
  cts.Term
    cts.diamond
    (cts.cast
       cts.triangle
       cts.sinf
       (cts.univ cts.box cts.triangle cts.I)
       (cts.univ cts.diamond cts.sinf cts.I)
       cts.I
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) (nat.leb n m).

def commutative_gcd :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 => logic.eq nat.nat (gcd x x0) (gcd x0 x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  nat.leb_elim
    n
    m
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              bool.bool)) =>
     logic.eq
       nat.nat
       (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) __)
       (bool.match_bool_type nat.nat (gcd_aux m n m) (gcd_aux n m n) (nat.leb m n)))
    (lenm:(cts.Term cts.star (nat.le n m)) =>
     connectives.match_Or_prop
       (nat.lt n m)
       (logic.eq nat.nat n m)
       (logic.eq
          nat.nat
          (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.true)
          (bool.match_bool_type nat.nat (gcd_aux m n m) (gcd_aux n m n) (nat.leb m n)))
       (ltnm:(cts.Term cts.star (nat.lt n m)) =>
        logic.eq_ind_r
          bool.bool
          bool.false
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   bool.bool)) =>
           logic.eq
             nat.nat
             (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.true)
             (bool.match_bool_type nat.nat (gcd_aux m n m) (gcd_aux n m n) x))
          (bool.sym_eq_match_bool_type_false
             nat.nat
             (gcd_aux m n m)
             (gcd_aux n m n)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.true)
                y)
             (bool.eq_match_bool_type_true
                nat.nat
                (gcd_aux n m n)
                (gcd_aux m n m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.true)
                   y)
                (logic.refl
                   nat.nat
                   (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.true))))
          (nat.leb m n)
          (nat.not_le_to_leb_false m n (nat.lt_to_not_le n m ltnm)))
       (eqnm:(cts.Term cts.star (logic.eq nat.nat n m)) =>
        logic.eq_ind_r
          nat.nat
          m
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           logic.eq
             nat.nat
             (bool.match_bool_type nat.nat (gcd_aux x m x) (gcd_aux m x m) bool.true)
             (bool.match_bool_type nat.nat (gcd_aux m x m) (gcd_aux x m x) (nat.leb m x)))
          (bool.match_bool_prop
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       bool.bool)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat (gcd_aux m m m) (gcd_aux m m m) bool.true)
                (bool.match_bool_type nat.nat (gcd_aux m m m) (gcd_aux m m m) __))
             (logic.refl
                nat.nat
                (bool.match_bool_type nat.nat (gcd_aux m m m) (gcd_aux m m m) bool.true))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                (gcd_aux m m m)
                (gcd_aux m m m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat (gcd_aux m m m) (gcd_aux m m m) bool.true)
                   y)
                (bool.eq_match_bool_type_true
                   nat.nat
                   (gcd_aux m m m)
                   (gcd_aux m m m)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq
                      nat.nat
                      (bool.match_bool_type nat.nat (gcd_aux m m m) (gcd_aux m m m) bool.true)
                      y)
                   (logic.refl
                      nat.nat
                      (bool.match_bool_type nat.nat (gcd_aux m m m) (gcd_aux m m m) bool.true))))
             (nat.leb m m))
          n
          eqnm)
       (nat.le_to_or_lt_eq n m lenm))
    (notlenm:(cts.Term cts.star (connectives.Not (nat.le n m))) =>
     logic.eq_ind_r
       bool.bool
       bool.true
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                bool.bool)) =>
        logic.eq
          nat.nat
          (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.false)
          (bool.match_bool_type nat.nat (gcd_aux m n m) (gcd_aux n m n) x))
       (bool.sym_eq_match_bool_type_false
          nat.nat
          (gcd_aux n m n)
          (gcd_aux m n m)
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           logic.eq
             nat.nat
             y
             (bool.match_bool_type nat.nat (gcd_aux m n m) (gcd_aux n m n) bool.true))
          (bool.sym_eq_match_bool_type_true
             nat.nat
             (gcd_aux m n m)
             (gcd_aux n m n)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq nat.nat (gcd_aux m n m) y)
             (bool.eq_match_bool_type_false
                nat.nat
                (gcd_aux n m n)
                (gcd_aux m n m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq nat.nat (gcd_aux m n m) y)
                (bool.eq_match_bool_type_false
                   nat.nat
                   (gcd_aux n m n)
                   (gcd_aux m n m)
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq
                      nat.nat
                      y
                      (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.false))
                   (logic.refl
                      nat.nat
                      (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.false))))))
       (nat.leb m n)
       (nat.le_to_leb_true
          m
          n
          (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m) (nat.not_le_to_lt n m notlenm)))).

def gcd_O_l :
  cts.Term
    cts.star
    (cts.prod cts.box cts.star cts.star cts.I nat.nat (x => logic.eq nat.nat (gcd nat.O x) x))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  bool.eq_match_bool_type_true
    nat.nat
    m
    (gcd_aux m nat.O m)
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     logic.eq nat.nat (gcd nat.O m) y)
    (nat.eq_leb_body_O
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => bool.bool)))) =>
        logic.eq nat.nat (gcd nat.O m) (bool.match_bool_type nat.nat m (gcd_aux m nat.O m) (y m)))
       (nat.eq_filter_nat_type_O
          (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => bool.bool))
          nat.leb_body
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => bool.bool)))) =>
           logic.eq
             nat.nat
             (gcd nat.O m)
             (bool.match_bool_type nat.nat m (gcd_aux m nat.O m) (y m)))
          (nat.eq_leb
             nat.O
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => bool.bool)))) =>
              logic.eq
                nat.nat
                (gcd nat.O m)
                (bool.match_bool_type nat.nat m (gcd_aux m nat.O m) (y m)))
             (eq_gcd_aux_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod
                            cts.box
                            cts.box
                            cts.box
                            cts.I
                            nat.nat
                            (x =>
                             cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
                 logic.eq
                   nat.nat
                   (gcd nat.O m)
                   (bool.match_bool_type
                      nat.nat
                      (y m nat.O)
                      (gcd_aux m nat.O m)
                      (nat.leb nat.O m)))
                (nat.eq_filter_nat_type_O
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
                   gcd_aux_body
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x =>
                                cts.prod
                                  cts.box
                                  cts.box
                                  cts.box
                                  cts.I
                                  nat.nat
                                  (x0 => nat.nat))))) =>
                    logic.eq
                      nat.nat
                      (gcd nat.O m)
                      (bool.match_bool_type
                         nat.nat
                         (y m nat.O)
                         (gcd_aux m nat.O m)
                         (nat.leb nat.O m)))
                   (eq_gcd_aux
                      nat.O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod
                                  cts.box
                                  cts.box
                                  cts.box
                                  cts.I
                                  nat.nat
                                  (x =>
                                   cts.prod
                                     cts.box
                                     cts.box
                                     cts.box
                                     cts.I
                                     nat.nat
                                     (x0 => nat.nat))))) =>
                       logic.eq
                         nat.nat
                         (gcd nat.O m)
                         (bool.match_bool_type
                            nat.nat
                            (y m nat.O)
                            (gcd_aux m nat.O m)
                            (nat.leb nat.O m)))
                      (logic.refl nat.nat (gcd nat.O m)))))))).

def divides_mod_to_divides :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.lt nat.O x1)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (primes.divides x (div_mod.mod x0 x1))
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (primes.divides x x1)
                      (x4 => primes.divides x x0)))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  _clearme:(cts.Term cts.star (primes.divides p (div_mod.mod m n))) =>
  primes.match_divides_prop
    p
    (div_mod.mod m n)
    (cts.prod cts.star cts.star cts.star cts.I (primes.divides p n) (x => primes.divides p m))
    (q1:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     eq1:(cts.Term cts.star (logic.eq nat.nat (div_mod.mod m n) (nat.times p q1))) =>
     _clearme0:(cts.Term cts.star (primes.divides p n)) =>
     primes.match_divides_prop
       p
       n
       (primes.divides p m)
       (q2:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        eq2:(cts.Term cts.star (logic.eq nat.nat n (nat.times p q2))) =>
        primes.quotient
          p
          m
          (nat.plus (nat.times q2 (div_mod.div m n)) q1)
          (logic.eq_ind_r
             nat.nat
             (nat.plus (nat.times p (nat.times q2 (div_mod.div m n))) (nat.times p q1))
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              logic.eq nat.nat m x)
             (logic.eq_ind
                nat.nat
                (div_mod.mod m n)
                (x_1:(cts.Term
                        cts.diamond
                        (cts.cast
                           cts.triangle
                           cts.sinf
                           (cts.univ cts.box cts.triangle cts.I)
                           (cts.univ cts.diamond cts.sinf cts.I)
                           cts.I
                           nat.nat)) =>
                 logic.eq nat.nat m (nat.plus (nat.times p (nat.times q2 (div_mod.div m n))) x_1))
                (logic.eq_ind
                   nat.nat
                   (nat.times (nat.times p q2) (div_mod.div m n))
                   (x_1:(cts.Term
                           cts.diamond
                           (cts.cast
                              cts.triangle
                              cts.sinf
                              (cts.univ cts.box cts.triangle cts.I)
                              (cts.univ cts.diamond cts.sinf cts.I)
                              cts.I
                              nat.nat)) =>
                    logic.eq nat.nat m (nat.plus x_1 (div_mod.mod m n)))
                   (logic.eq_ind
                      nat.nat
                      n
                      (x_1:(cts.Term
                              cts.diamond
                              (cts.cast
                                 cts.triangle
                                 cts.sinf
                                 (cts.univ cts.box cts.triangle cts.I)
                                 (cts.univ cts.diamond cts.sinf cts.I)
                                 cts.I
                                 nat.nat)) =>
                       logic.eq
                         nat.nat
                         m
                         (nat.plus (nat.times x_1 (div_mod.div m n)) (div_mod.mod m n)))
                      (logic.rewrite_r
                         nat.nat
                         (nat.plus (div_mod.mod m n) (nat.times n (div_mod.div m n)))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq nat.nat m __)
                         (logic.rewrite_l
                            nat.nat
                            m
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             logic.eq nat.nat m __)
                            (logic.refl nat.nat m)
                            (nat.plus (div_mod.mod m n) (nat.times n (div_mod.div m n)))
                            (logic.rewrite_l
                               nat.nat
                               (nat.plus (nat.times n (div_mod.div m n)) (div_mod.mod m n))
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq nat.nat m __)
                               (logic.rewrite_l
                                  nat.nat
                                  (nat.times (div_mod.div m n) n)
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat.nat)) =>
                                   logic.eq nat.nat m (nat.plus __ (div_mod.mod m n)))
                                  (div_mod.div_mod m n)
                                  (nat.times n (div_mod.div m n))
                                  (nat.commutative_times (div_mod.div m n) n))
                               (nat.plus (div_mod.mod m n) (nat.times n (div_mod.div m n)))
                               (nat.commutative_plus
                                  (nat.times n (div_mod.div m n))
                                  (div_mod.mod m n))))
                         (nat.plus (nat.times n (div_mod.div m n)) (div_mod.mod m n))
                         (nat.commutative_plus
                            (nat.times n (div_mod.div m n))
                            (div_mod.mod m n)))
                      (nat.times p q2)
                      eq2)
                   (nat.times p (nat.times q2 (div_mod.div m n)))
                   (nat.associative_times p q2 (div_mod.div m n)))
                (nat.times p q1)
                eq1)
             (nat.times p (nat.plus (nat.times q2 (div_mod.div m n)) q1))
             (nat.distributive_times_plus p (nat.times q2 (div_mod.div m n)) q1)))
       _clearme0)
    _clearme.

def divides_to_gcd_aux :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.lt nat.O x)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.lt nat.O x1)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (primes.divides x1 x0)
                      (x4 => logic.eq nat.nat (gcd_aux x x0 x1) x1)))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posp:(cts.Term cts.star (nat.lt nat.O p)) =>
  nat.lt_O_n_elim
    p
    posp
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (nat.lt nat.O n)
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (primes.divides n m)
          (x0 => logic.eq nat.nat (gcd_aux __ m n) n)))
    (l:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     sym_eq_gcd_aux
       (nat.S l)
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.lt nat.O n)
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (primes.divides n m)
             (x0 => logic.eq nat.nat (y m n) n)))
       (nat.sym_eq_filter_nat_type_S
          (cts.prod
             cts.box
             cts.box
             cts.box
             cts.I
             nat.nat
             (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
          gcd_aux_body
          l
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O n)
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (primes.divides n m)
                (x0 => logic.eq nat.nat (y m n) n)))
          (sym_eq_gcd_aux_body_S
             l
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      (cts.prod
                         cts.box
                         cts.box
                         cts.box
                         cts.I
                         nat.nat
                         (x =>
                          cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.lt nat.O n)
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (primes.divides n m)
                   (x0 => logic.eq nat.nat (y m n) n)))
             (posn:(cts.Term cts.star (nat.lt nat.O n)) =>
              divnm:(cts.Term cts.star (primes.divides n m)) =>
              logic.eq_ind_r
                bool.bool
                bool.true
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         bool.bool)) =>
                 logic.eq
                   nat.nat
                   (bool.match_bool_type nat.nat n (gcd_aux l n (div_mod.mod m n)) x)
                   n)
                (bool.sym_eq_match_bool_type_true
                   nat.nat
                   n
                   (gcd_aux
                      l
                      n
                      (nat.match_nat_type
                         nat.nat
                         m
                         (p0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          div_mod.mod_aux m m p0)
                         n))
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    logic.eq nat.nat y n)
                   (logic.refl nat.nat n))
                (primes.dividesb n m)
                (primes.divides_to_dividesb_true n m posn divnm))))).

def not_divides_to_gcd_aux :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.lt nat.O x1)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (primes.divides x1 x0))
                   (x3 =>
                    logic.eq
                      nat.nat
                      (gcd_aux (nat.S x) x0 x1)
                      (gcd_aux x x1 (div_mod.mod x0 x1))))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  sym_eq_gcd_aux
    (nat.S p)
    (y:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             (cts.prod
                cts.box
                cts.box
                cts.box
                cts.I
                nat.nat
                (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (nat.lt nat.O n)
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (connectives.Not (primes.divides n m))
          (x0 => logic.eq nat.nat (y m n) (gcd_aux p n (div_mod.mod m n)))))
    (nat.sym_eq_filter_nat_type_S
       (cts.prod
          cts.box
          cts.box
          cts.box
          cts.I
          nat.nat
          (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat)))
       gcd_aux_body
       p
       (y:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                (cts.prod
                   cts.box
                   cts.box
                   cts.box
                   cts.I
                   nat.nat
                   (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (nat.lt nat.O n)
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (connectives.Not (primes.divides n m))
             (x0 => logic.eq nat.nat (y m n) (gcd_aux p n (div_mod.mod m n)))))
       (sym_eq_gcd_aux_body_S
          p
          (y:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   (cts.prod
                      cts.box
                      cts.box
                      cts.box
                      cts.I
                      nat.nat
                      (x => cts.prod cts.box cts.box cts.box cts.I nat.nat (x0 => nat.nat))))) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O n)
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (connectives.Not (primes.divides n m))
                (x0 => logic.eq nat.nat (y m n) (gcd_aux p n (div_mod.mod m n)))))
          (lenm:(cts.Term cts.star (nat.lt nat.O n)) =>
           divnm:(cts.Term cts.star (connectives.Not (primes.divides n m))) =>
           logic.eq_ind_r
             bool.bool
             bool.false
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      bool.bool)) =>
              logic.eq
                nat.nat
                (bool.match_bool_type nat.nat n (gcd_aux p n (div_mod.mod m n)) x)
                (gcd_aux p n (div_mod.mod m n)))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                n
                (gcd_aux
                   p
                   n
                   (nat.match_nat_type
                      nat.nat
                      m
                      (p0:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       div_mod.mod_aux m m p0)
                      n))
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 logic.eq
                   nat.nat
                   y
                   (gcd_aux
                      p
                      n
                      (nat.match_nat_type
                         nat.nat
                         m
                         (p0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          div_mod.mod_aux m m p0)
                         n)))
                (logic.refl
                   nat.nat
                   (gcd_aux
                      p
                      n
                      (nat.match_nat_type
                         nat.nat
                         m
                         (p0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          div_mod.mod_aux m m p0)
                         n))))
             (primes.dividesb n m)
             (primes.not_divides_to_dividesb_false n m lenm divnm)))).

def divides_gcd_aux_mn :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.lt nat.O x1)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x1 x0)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x1 x)
                      (x4 =>
                       connectives.And
                         (primes.divides (gcd_aux x x0 x1) x0)
                         (primes.divides (gcd_aux x x0 x1) x1))))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  nat.nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat.nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O x0)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x0 x)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x0 _x_365)
                   (x3 =>
                    connectives.And
                      (primes.divides (gcd_aux _x_365 x x0) x)
                      (primes.divides (gcd_aux _x_365 x x0) x0)))))))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     posn:(cts.Term cts.star (nat.lt nat.O n)) =>
     lenm:(cts.Term cts.star (nat.le n m)) =>
     lenO:(cts.Term cts.star (nat.le n nat.O)) =>
     connectives.falsity
       (connectives.And
          (primes.divides (gcd_aux nat.O m n) m)
          (primes.divides (gcd_aux nat.O m n) n))
       (logic.absurd (nat.lt nat.O n) posn (nat.le_to_not_lt n nat.O lenO)))
    (q:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     Hind:(cts.Term
             cts.star
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.lt nat.O x0)
                      (x1 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x0 x)
                         (x2 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x0 q)
                            (x3 =>
                             connectives.And
                               (primes.divides (gcd_aux q x x0) x)
                               (primes.divides (gcd_aux q x x0) x0)))))))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     posn:(cts.Term cts.star (nat.lt nat.O n)) =>
     lenm:(cts.Term cts.star (nat.le n m)) =>
     lenS:(cts.Term cts.star (nat.le n (nat.S q))) =>
     connectives.match_Or_prop
       (primes.divides n m)
       (connectives.Not (primes.divides n m))
       (connectives.And
          (primes.divides (gcd_aux (nat.S q) m n) m)
          (primes.divides (gcd_aux (nat.S q) m n) n))
       (divnm:(cts.Term cts.star (primes.divides n m)) =>
        logic.eq_ind_r
          nat.nat
          n
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (primes.divides x m) (primes.divides x n))
          (connectives.conj (primes.divides n m) (primes.divides n n) divnm (primes.divides_n_n n))
          (gcd_aux (nat.S q) m n)
          (divides_to_gcd_aux (nat.S q) m n (nat.lt_O_S q) posn divnm))
       (ndivnm:(cts.Term cts.star (connectives.Not (primes.divides n m))) =>
        logic.eq_ind_r
          nat.nat
          (gcd_aux q n (div_mod.mod m n))
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.And (primes.divides x m) (primes.divides x n))
          (connectives.match_And_prop
             (primes.divides (gcd_aux q n (div_mod.mod m n)) n)
             (primes.divides (gcd_aux q n (div_mod.mod m n)) (div_mod.mod m n))
             (connectives.And
                (primes.divides (gcd_aux q n (div_mod.mod m n)) m)
                (primes.divides (gcd_aux q n (div_mod.mod m n)) n))
             (H:(cts.Term cts.star (primes.divides (gcd_aux q n (div_mod.mod m n)) n)) =>
              H1:(cts.Term
                    cts.star
                    (primes.divides (gcd_aux q n (div_mod.mod m n)) (div_mod.mod m n))) =>
              connectives.conj
                (primes.divides (gcd_aux q n (div_mod.mod m n)) m)
                (primes.divides (gcd_aux q n (div_mod.mod m n)) n)
                (divides_mod_to_divides (gcd_aux q n (div_mod.mod m n)) m n posn H1 H)
                H)
             (Hind
                n
                (div_mod.mod m n)
                (connectives.match_Or_prop
                   (nat.lt nat.O (div_mod.mod m n))
                   (logic.eq nat.nat nat.O (div_mod.mod m n))
                   (nat.lt nat.O (div_mod.mod m n))
                   (auto:(cts.Term cts.star (nat.lt nat.O (div_mod.mod m n))) => auto)
                   (modO:(cts.Term cts.star (logic.eq nat.nat nat.O (div_mod.mod m n))) =>
                    connectives.falsity
                      (nat.lt nat.O (div_mod.mod m n))
                      (logic.absurd
                         (primes.divides n m)
                         (primes.mod_O_to_divides
                            n
                            m
                            posn
                            (logic.rewrite_l
                               nat.nat
                               nat.O
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq nat.nat __ nat.O)
                               (logic.refl nat.nat nat.O)
                               (div_mod.mod m n)
                               modO))
                         ndivnm))
                   (nat.le_to_or_lt_eq nat.O (div_mod.mod m n) (nat.le_O_n (div_mod.mod m n))))
                (nat.lt_to_le (div_mod.mod m n) n (div_mod.lt_mod_m_m m n posn))
                (nat.le_S_S_to_le
                   (div_mod.mod m n)
                   q
                   (nat.transitive_le
                      (nat.S (div_mod.mod m n))
                      n
                      (nat.S q)
                      (div_mod.lt_mod_m_m m n posn)
                      lenS))))
          (gcd_aux (nat.S q) m n)
          (not_divides_to_gcd_aux q m n posn ndivnm))
       (primes.decidable_divides n m))
    p.

def divides_gcd_nm :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 => connectives.And (primes.divides (gcd x x0) x0) (primes.divides (gcd x x0) x))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.match_Or_prop
    (nat.lt nat.O n)
    (logic.eq nat.nat nat.O n)
    (connectives.And (primes.divides (gcd n m) m) (primes.divides (gcd n m) n))
    (posn:(cts.Term cts.star (nat.lt nat.O n)) =>
     connectives.match_Or_prop
       (nat.lt nat.O m)
       (logic.eq nat.nat nat.O m)
       (connectives.And (primes.divides (gcd n m) m) (primes.divides (gcd n m) n))
       (posm:(cts.Term cts.star (nat.lt nat.O m)) =>
        nat.leb_elim
          n
          m
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    bool.bool)) =>
           connectives.And
             (primes.divides (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) __) m)
             (primes.divides (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) __) n))
          (bool.sym_eq_match_bool_type_true
             nat.nat
             (gcd_aux n m n)
             (gcd_aux m n m)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le n m)
                (x =>
                 connectives.And
                   (primes.divides
                      (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.true)
                      m)
                   (primes.divides y n)))
             (bool.sym_eq_match_bool_type_true
                nat.nat
                (gcd_aux n m n)
                (gcd_aux m n m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le n m)
                   (x => connectives.And (primes.divides y m) (primes.divides (gcd_aux n m n) n)))
                (lenm:(cts.Term cts.star (nat.le n m)) =>
                 divides_gcd_aux_mn n m n posn lenm (nat.le_n n))))
          (bool.sym_eq_match_bool_type_false
             nat.nat
             (gcd_aux n m n)
             (gcd_aux m n m)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (connectives.Not (nat.le n m))
                (x =>
                 connectives.And
                   (primes.divides
                      (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) bool.false)
                      m)
                   (primes.divides y n)))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                (gcd_aux n m n)
                (gcd_aux m n m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (nat.le n m))
                   (x => connectives.And (primes.divides y m) (primes.divides (gcd_aux m n m) n)))
                (notlt:(cts.Term cts.star (connectives.Not (nat.le n m))) =>
                 connectives.match_And_prop
                   (primes.divides (gcd_aux m n m) n)
                   (primes.divides (gcd_aux m n m) m)
                   (connectives.And
                      (primes.divides (gcd_aux m n m) m)
                      (primes.divides (gcd_aux m n m) n))
                   (auto:(cts.Term cts.star (primes.divides (gcd_aux m n m) n)) =>
                    auto':(cts.Term cts.star (primes.divides (gcd_aux m n m) m)) =>
                    connectives.conj
                      (primes.divides (gcd_aux m n m) m)
                      (primes.divides (gcd_aux m n m) n)
                      auto'
                      auto)
                   (divides_gcd_aux_mn
                      m
                      n
                      m
                      posm
                      (nat.transitive_le
                         m
                         (nat.S m)
                         n
                         (nat.le_n_Sn m)
                         (nat.not_le_to_lt n m notlt))
                      (nat.le_n m))))))
       (eqmO:(cts.Term cts.star (logic.eq nat.nat nat.O m)) =>
        logic.eq_ind
          nat.nat
          nat.O
          (x_1:(cts.Term
                  cts.diamond
                  (cts.cast
                     cts.triangle
                     cts.sinf
                     (cts.univ cts.box cts.triangle cts.I)
                     (cts.univ cts.diamond cts.sinf cts.I)
                     cts.I
                     nat.nat)) =>
           connectives.And (primes.divides (gcd n x_1) x_1) (primes.divides (gcd n x_1) n))
          (connectives.conj
             (primes.divides (gcd n nat.O) nat.O)
             (primes.divides (gcd n nat.O) n)
             (primes.divides_n_O (gcd n nat.O))
             (logic.eq_coerc
                (primes.divides (gcd n nat.O) (gcd n nat.O))
                (primes.divides (gcd n nat.O) n)
                (primes.divides_n_n (gcd n nat.O))
                (logic.rewrite_r
                   nat.nat
                   n
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq
                      (cts.univ cts.star cts.box cts.I)
                      (primes.divides (gcd n nat.O) __)
                      (primes.divides (gcd n nat.O) n))
                   (logic.refl
                      (cts.univ cts.star cts.box cts.I)
                      (primes.divides (gcd n nat.O) n))
                   (gcd n nat.O)
                   (logic.rewrite_l
                      nat.nat
                      (gcd nat.O n)
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq nat.nat (gcd n nat.O) __)
                      (commutative_gcd n nat.O)
                      n
                      (gcd_O_l n)))))
          m
          eqmO)
       (nat.le_to_or_lt_eq nat.O m (nat.le_O_n m)))
    (eqnO:(cts.Term cts.star (logic.eq nat.nat nat.O n)) =>
     logic.eq_ind
       nat.nat
       nat.O
       (x_1:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat.nat)) =>
        connectives.And (primes.divides (gcd x_1 m) m) (primes.divides (gcd x_1 m) x_1))
       (connectives.conj
          (primes.divides (gcd nat.O m) m)
          (primes.divides (gcd nat.O m) nat.O)
          (bool.eq_match_bool_type_true
             nat.nat
             m
             (gcd_aux m nat.O m)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              primes.divides
                (bool.match_bool_type
                   nat.nat
                   (gcd_aux nat.O m nat.O)
                   (gcd_aux m nat.O m)
                   (nat.leb nat.O m))
                y)
             (nat.eq_leb_body_O
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => bool.bool)))) =>
                 primes.divides
                   (bool.match_bool_type
                      nat.nat
                      (gcd_aux nat.O m nat.O)
                      (gcd_aux m nat.O m)
                      (nat.leb nat.O m))
                   (bool.match_bool_type nat.nat m (gcd_aux m nat.O m) (y m)))
                (nat.eq_filter_nat_type_O
                   (cts.prod cts.box cts.box cts.box cts.I nat.nat (x => bool.bool))
                   nat.leb_body
                   (y:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x => bool.bool)))) =>
                    primes.divides
                      (bool.match_bool_type
                         nat.nat
                         (gcd_aux nat.O m nat.O)
                         (gcd_aux m nat.O m)
                         (nat.leb nat.O m))
                      (bool.match_bool_type nat.nat m (gcd_aux m nat.O m) (y m)))
                   (nat.eq_leb
                      nat.O
                      (y:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               (cts.prod
                                  cts.box
                                  cts.box
                                  cts.box
                                  cts.I
                                  nat.nat
                                  (x => bool.bool)))) =>
                       primes.divides
                         (bool.match_bool_type
                            nat.nat
                            (gcd_aux nat.O m nat.O)
                            (gcd_aux m nat.O m)
                            (nat.leb nat.O m))
                         (bool.match_bool_type nat.nat m (gcd_aux m nat.O m) (y m)))
                      (eq_gcd_aux_body_O
                         (y:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  (cts.prod
                                     cts.box
                                     cts.box
                                     cts.box
                                     cts.I
                                     nat.nat
                                     (x =>
                                      cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat.nat
                                        (x0 => nat.nat))))) =>
                          primes.divides
                            (gcd nat.O m)
                            (bool.match_bool_type
                               nat.nat
                               (y m nat.O)
                               (gcd_aux m nat.O m)
                               (nat.leb nat.O m)))
                         (nat.eq_filter_nat_type_O
                            (cts.prod
                               cts.box
                               cts.box
                               cts.box
                               cts.I
                               nat.nat
                               (x =>
                                cts.prod
                                  cts.box
                                  cts.box
                                  cts.box
                                  cts.I
                                  nat.nat
                                  (x0 => nat.nat)))
                            gcd_aux_body
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     (cts.prod
                                        cts.box
                                        cts.box
                                        cts.box
                                        cts.I
                                        nat.nat
                                        (x =>
                                         cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat.nat
                                           (x0 => nat.nat))))) =>
                             primes.divides
                               (gcd nat.O m)
                               (bool.match_bool_type
                                  nat.nat
                                  (y m nat.O)
                                  (gcd_aux m nat.O m)
                                  (nat.leb nat.O m)))
                            (eq_gcd_aux
                               nat.O
                               (y:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        (cts.prod
                                           cts.box
                                           cts.box
                                           cts.box
                                           cts.I
                                           nat.nat
                                           (x =>
                                            cts.prod
                                              cts.box
                                              cts.box
                                              cts.box
                                              cts.I
                                              nat.nat
                                              (x0 => nat.nat))))) =>
                                primes.divides
                                  (gcd nat.O m)
                                  (bool.match_bool_type
                                     nat.nat
                                     (y m nat.O)
                                     (gcd_aux m nat.O m)
                                     (nat.leb nat.O m)))
                               (primes.divides_n_n (gcd nat.O m)))))))))
          (primes.divides_n_O (gcd nat.O m)))
       n
       eqnO)
    (nat.le_to_or_lt_eq nat.O n (nat.le_O_n n)).

def divides_gcd_l :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat.nat (x0 => primes.divides (gcd x x0) x)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  logic.proj2 (primes.divides (gcd n m) m) (primes.divides (gcd n m) n) (divides_gcd_nm n m).

def divides_gcd_r :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x => cts.prod cts.box cts.star cts.star cts.I nat.nat (x0 => primes.divides (gcd x x0) x0)))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  logic.proj1 (primes.divides (gcd n m) m) (primes.divides (gcd n m) n) (divides_gcd_nm n m).

def let_clause_1544 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x1 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x2 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.lt nat.O x2)
                      (x3 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x2 x1)
                         (x4 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x2 x0)
                            (x5 =>
                             connectives.ex
                               nat.nat
                               (a:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.ex
                                  nat.nat
                                  (b:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat.nat)) =>
                                   connectives.Or
                                     (logic.eq
                                        nat.nat
                                        (nat.minus (nat.times a x2) (nat.times b x1))
                                        (gcd_aux x0 x1 x2))
                                     (logic.eq
                                        nat.nat
                                        (nat.minus (nat.times b x1) (nat.times a x2))
                                        (gcd_aux x0 x1 x2))))))))))
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.lt nat.O x3)
                      (x4 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x3 x2)
                         (x5 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x3 (nat.S x0))
                            (x6 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (primes.divides x3 x2))
                               (x7 =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat.nat
                                  (x8 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (connectives.ex
                                        nat.nat
                                        (b:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 nat.nat)) =>
                                         connectives.Or
                                           (logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.times x8 (div_mod.mod x2 x3))
                                                 (nat.times b x3))
                                              (gcd_aux x0 x3 (div_mod.mod x2 x3)))
                                           (logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.times b x3)
                                                 (nat.times x8 (div_mod.mod x2 x3)))
                                              (gcd_aux x0 x3 (div_mod.mod x2 x3)))))
                                     (x9 =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat.nat
                                        (x10 =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (connectives.Or
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x8 (div_mod.mod x2 x3))
                                                    (nat.times x10 x3))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3)))
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x10 x3)
                                                    (nat.times x8 (div_mod.mod x2 x3)))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3))))
                                           (x11 =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x8 (div_mod.mod x2 x3))
                                                    (nat.times x10 x3))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3)))
                                              (x12 =>
                                               logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x8 (div_mod.mod x2 x3))
                                                    (nat.times x3 x10))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3)))))))))))))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  q:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  Hind:(cts.Term
          cts.star
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.lt nat.O x0)
                   (x1 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x0 x)
                      (x2 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x0 q)
                         (x3 =>
                          connectives.ex
                            nat.nat
                            (a:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.ex
                               nat.nat
                               (b:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times a x0) (nat.times b x))
                                     (gcd_aux q x x0))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b x) (nat.times a x0))
                                     (gcd_aux q x x0))))))))))) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  lenm:(cts.Term cts.star (nat.le n m)) =>
  lenS:(cts.Term cts.star (nat.le n (nat.S q))) =>
  ndivnm:(cts.Term cts.star (connectives.Not (primes.divides n m))) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme:(cts.Term
              cts.star
              (connectives.ex
                 nat.nat
                 (b:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                  connectives.Or
                    (logic.eq
                       nat.nat
                       (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                       (gcd_aux q n (div_mod.mod m n)))
                    (logic.eq
                       nat.nat
                       (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                       (gcd_aux q n (div_mod.mod m n)))))) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme0:(cts.Term
               cts.star
               (connectives.Or
                  (logic.eq
                     nat.nat
                     (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                     (gcd_aux q n (div_mod.mod m n)))
                  (logic.eq
                     nat.nat
                     (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                     (gcd_aux q n (div_mod.mod m n))))) =>
  H:(cts.Term
       cts.star
       (logic.eq
          nat.nat
          (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
          (gcd_aux q n (div_mod.mod m n)))) =>
  logic.rewrite_l
    nat.nat
    (nat.times b n)
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat (nat.minus (nat.times a (div_mod.mod m n)) __) (gcd_aux q n (div_mod.mod m n)))
    H
    (nat.times n b)
    (nat.commutative_times b n).

def let_clause_15441 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x1 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x2 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.lt nat.O x2)
                      (x3 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x2 x1)
                         (x4 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x2 x0)
                            (x5 =>
                             connectives.ex
                               nat.nat
                               (a:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.ex
                                  nat.nat
                                  (b:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat.nat)) =>
                                   connectives.Or
                                     (logic.eq
                                        nat.nat
                                        (nat.minus (nat.times a x2) (nat.times b x1))
                                        (gcd_aux x0 x1 x2))
                                     (logic.eq
                                        nat.nat
                                        (nat.minus (nat.times b x1) (nat.times a x2))
                                        (gcd_aux x0 x1 x2))))))))))
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.lt nat.O x3)
                      (x4 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x3 x2)
                         (x5 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x3 (nat.S x0))
                            (x6 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (connectives.Not (primes.divides x3 x2))
                               (x7 =>
                                cts.prod
                                  cts.box
                                  cts.star
                                  cts.star
                                  cts.I
                                  nat.nat
                                  (x8 =>
                                   cts.prod
                                     cts.star
                                     cts.star
                                     cts.star
                                     cts.I
                                     (connectives.ex
                                        nat.nat
                                        (b:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 nat.nat)) =>
                                         connectives.Or
                                           (logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.times x8 (div_mod.mod x2 x3))
                                                 (nat.times b x3))
                                              (gcd_aux x0 x3 (div_mod.mod x2 x3)))
                                           (logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.times b x3)
                                                 (nat.times x8 (div_mod.mod x2 x3)))
                                              (gcd_aux x0 x3 (div_mod.mod x2 x3)))))
                                     (x9 =>
                                      cts.prod
                                        cts.box
                                        cts.star
                                        cts.star
                                        cts.I
                                        nat.nat
                                        (x10 =>
                                         cts.prod
                                           cts.star
                                           cts.star
                                           cts.star
                                           cts.I
                                           (connectives.Or
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x8 (div_mod.mod x2 x3))
                                                    (nat.times x10 x3))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3)))
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x10 x3)
                                                    (nat.times x8 (div_mod.mod x2 x3)))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3))))
                                           (x11 =>
                                            cts.prod
                                              cts.star
                                              cts.star
                                              cts.star
                                              cts.I
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x10 x3)
                                                    (nat.times x8 (div_mod.mod x2 x3)))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3)))
                                              (x12 =>
                                               logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times x3 x10)
                                                    (nat.times x8 (div_mod.mod x2 x3)))
                                                 (gcd_aux x0 x3 (div_mod.mod x2 x3)))))))))))))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  q:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  Hind:(cts.Term
          cts.star
          (cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x0 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.lt nat.O x0)
                   (x1 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x0 x)
                      (x2 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x0 q)
                         (x3 =>
                          connectives.ex
                            nat.nat
                            (a:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.ex
                               nat.nat
                               (b:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times a x0) (nat.times b x))
                                     (gcd_aux q x x0))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b x) (nat.times a x0))
                                     (gcd_aux q x x0))))))))))) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  lenm:(cts.Term cts.star (nat.le n m)) =>
  lenS:(cts.Term cts.star (nat.le n (nat.S q))) =>
  ndivnm:(cts.Term cts.star (connectives.Not (primes.divides n m))) =>
  a:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme:(cts.Term
              cts.star
              (connectives.ex
                 nat.nat
                 (b:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                  connectives.Or
                    (logic.eq
                       nat.nat
                       (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                       (gcd_aux q n (div_mod.mod m n)))
                    (logic.eq
                       nat.nat
                       (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                       (gcd_aux q n (div_mod.mod m n)))))) =>
  b:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme0:(cts.Term
               cts.star
               (connectives.Or
                  (logic.eq
                     nat.nat
                     (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                     (gcd_aux q n (div_mod.mod m n)))
                  (logic.eq
                     nat.nat
                     (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                     (gcd_aux q n (div_mod.mod m n))))) =>
  H:(cts.Term
       cts.star
       (logic.eq
          nat.nat
          (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
          (gcd_aux q n (div_mod.mod m n)))) =>
  logic.rewrite_l
    nat.nat
    (nat.times b n)
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat (nat.minus __ (nat.times a (div_mod.mod m n))) (gcd_aux q n (div_mod.mod m n)))
    H
    (nat.times n b)
    (nat.commutative_times b n).

def eq_minus_gcd_aux :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.lt nat.O x1)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x1 x0)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.le x1 x)
                      (x4 =>
                       connectives.ex
                         nat.nat
                         (a:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.ex
                            nat.nat
                            (b:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times a x1) (nat.times b x0))
                                  (gcd_aux x x0 x1))
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b x0) (nat.times a x1))
                                  (gcd_aux x x0 x1)))))))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  nat.nat_ind
    (_x_365:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat.nat)) =>
     cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O x0)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le x0 x)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le x0 _x_365)
                   (x3 =>
                    connectives.ex
                      nat.nat
                      (a:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (b:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.Or
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times a x0) (nat.times b x))
                               (gcd_aux _x_365 x x0))
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times b x) (nat.times a x0))
                               (gcd_aux _x_365 x x0))))))))))
    (m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     posn:(cts.Term cts.star (nat.lt nat.O n)) =>
     lenm:(cts.Term cts.star (nat.le n m)) =>
     lenO:(cts.Term cts.star (nat.le n nat.O)) =>
     connectives.falsity
       (connectives.ex
          nat.nat
          (a:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (b:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) (gcd_aux nat.O m n))
                (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) (gcd_aux nat.O m n)))))
       (logic.absurd (nat.lt nat.O n) posn (nat.le_to_not_lt n nat.O lenO)))
    (q:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     Hind:(cts.Term
             cts.star
             (cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x0 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (nat.lt nat.O x0)
                      (x1 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (nat.le x0 x)
                         (x2 =>
                          cts.prod
                            cts.star
                            cts.star
                            cts.star
                            cts.I
                            (nat.le x0 q)
                            (x3 =>
                             connectives.ex
                               nat.nat
                               (a:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.ex
                                  nat.nat
                                  (b:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat.nat)) =>
                                   connectives.Or
                                     (logic.eq
                                        nat.nat
                                        (nat.minus (nat.times a x0) (nat.times b x))
                                        (gcd_aux q x x0))
                                     (logic.eq
                                        nat.nat
                                        (nat.minus (nat.times b x) (nat.times a x0))
                                        (gcd_aux q x x0))))))))))) =>
     m:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     n:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     posn:(cts.Term cts.star (nat.lt nat.O n)) =>
     lenm:(cts.Term cts.star (nat.le n m)) =>
     lenS:(cts.Term cts.star (nat.le n (nat.S q))) =>
     connectives.match_Or_prop
       (primes.divides n m)
       (connectives.Not (primes.divides n m))
       (connectives.ex
          nat.nat
          (a:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (b:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.Or
                (logic.eq
                   nat.nat
                   (nat.minus (nat.times a n) (nat.times b m))
                   (gcd_aux (nat.S q) m n))
                (logic.eq
                   nat.nat
                   (nat.minus (nat.times b m) (nat.times a n))
                   (gcd_aux (nat.S q) m n)))))
       (divnm:(cts.Term cts.star (primes.divides n m)) =>
        logic.eq_ind_r
          nat.nat
          n
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) x)
                   (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) x))))
          (connectives.ex_intro
             nat.nat
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times x n) (nat.times b m)) n)
                   (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times x n)) n)))
             (nat.S nat.O)
             (connectives.ex_intro
                nat.nat
                (x:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times (nat.S nat.O) n) (nat.times x m)) n)
                   (logic.eq nat.nat (nat.minus (nat.times x m) (nat.times (nat.S nat.O) n)) n))
                nat.O
                (connectives.or_introl
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m))
                      n)
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times nat.O m) (nat.times (nat.S nat.O) n))
                      n)
                   (logic.rewrite_r
                      nat.nat
                      (nat.times n (nat.S nat.O))
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq nat.nat (nat.minus __ (nat.times nat.O m)) n)
                      (logic.rewrite_l
                         nat.nat
                         (nat.plus n (nat.times n nat.O))
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq nat.nat (nat.minus __ (nat.times nat.O m)) n)
                         (logic.rewrite_l
                            nat.nat
                            nat.O
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             logic.eq
                               nat.nat
                               (nat.minus (nat.plus n __) (nat.times nat.O m))
                               n)
                            (logic.rewrite_l
                               nat.nat
                               n
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq nat.nat (nat.minus __ (nat.times nat.O m)) n)
                               (logic.rewrite_r
                                  nat.nat
                                  (nat.times m nat.O)
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat.nat)) =>
                                   logic.eq nat.nat (nat.minus n __) n)
                                  (logic.rewrite_l
                                     nat.nat
                                     nat.O
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat.nat)) =>
                                      logic.eq nat.nat (nat.minus n __) n)
                                     (logic.rewrite_l
                                        nat.nat
                                        n
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq nat.nat __ n)
                                        (logic.refl nat.nat n)
                                        (nat.minus n nat.O)
                                        (nat.minus_n_O n))
                                     (nat.times m nat.O)
                                     (nat.times_n_O m))
                                  (nat.times nat.O m)
                                  (nat.commutative_times nat.O m))
                               (nat.plus n nat.O)
                               (nat.plus_n_O n))
                            (nat.times n nat.O)
                            (nat.times_n_O n))
                         (nat.times n (nat.S nat.O))
                         (nat.times_n_Sm n nat.O))
                      (nat.times (nat.S nat.O) n)
                      (nat.commutative_times (nat.S nat.O) n)))))
          (gcd_aux (nat.S q) m n)
          (divides_to_gcd_aux (nat.S q) m n (nat.lt_O_S q) posn divnm))
       (ndivnm:(cts.Term cts.star (connectives.Not (primes.divides n m))) =>
        logic.eq_ind_r
          nat.nat
          (gcd_aux q n (div_mod.mod m n))
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) x)
                   (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) x))))
          (connectives.match_ex_prop
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                      (gcd_aux q n (div_mod.mod m n)))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                      (gcd_aux q n (div_mod.mod m n)))))
             (connectives.ex
                nat.nat
                (a:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.ex
                   nat.nat
                   (b:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    connectives.Or
                      (logic.eq
                         nat.nat
                         (nat.minus (nat.times a n) (nat.times b m))
                         (gcd_aux q n (div_mod.mod m n)))
                      (logic.eq
                         nat.nat
                         (nat.minus (nat.times b m) (nat.times a n))
                         (gcd_aux q n (div_mod.mod m n))))))
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              _clearme:(cts.Term
                          cts.star
                          (connectives.ex
                             nat.nat
                             (b:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                              connectives.Or
                                (logic.eq
                                   nat.nat
                                   (nat.minus
                                      (nat.times a (div_mod.mod m n))
                                      (nat.times b n))
                                   (gcd_aux q n (div_mod.mod m n)))
                                (logic.eq
                                   nat.nat
                                   (nat.minus
                                      (nat.times b n)
                                      (nat.times a (div_mod.mod m n)))
                                   (gcd_aux q n (div_mod.mod m n)))))) =>
              connectives.match_ex_prop
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                      (gcd_aux q n (div_mod.mod m n)))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                      (gcd_aux q n (div_mod.mod m n))))
                (connectives.ex
                   nat.nat
                   (a0:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    connectives.ex
                      nat.nat
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.Or
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a0 n) (nat.times b m))
                            (gcd_aux q n (div_mod.mod m n)))
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times b m) (nat.times a0 n))
                            (gcd_aux q n (div_mod.mod m n))))))
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 _clearme0:(cts.Term
                              cts.star
                              (connectives.Or
                                 (logic.eq
                                    nat.nat
                                    (nat.minus
                                       (nat.times a (div_mod.mod m n))
                                       (nat.times b n))
                                    (gcd_aux q n (div_mod.mod m n)))
                                 (logic.eq
                                    nat.nat
                                    (nat.minus
                                       (nat.times b n)
                                       (nat.times a (div_mod.mod m n)))
                                    (gcd_aux q n (div_mod.mod m n))))) =>
                 connectives.match_Or_prop
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                      (gcd_aux q n (div_mod.mod m n)))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                      (gcd_aux q n (div_mod.mod m n)))
                   (connectives.ex
                      nat.nat
                      (a0:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (b0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          connectives.Or
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times a0 n) (nat.times b0 m))
                               (gcd_aux q n (div_mod.mod m n)))
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times b0 m) (nat.times a0 n))
                               (gcd_aux q n (div_mod.mod m n))))))
                   (H:(cts.Term
                         cts.star
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                            (gcd_aux q n (div_mod.mod m n)))) =>
                    logic.eq_ind
                      nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
                      (x_1:(cts.Term
                              cts.diamond
                              (cts.cast
                                 cts.triangle
                                 cts.sinf
                                 (cts.univ cts.box cts.triangle cts.I)
                                 (cts.univ cts.diamond cts.sinf cts.I)
                                 cts.I
                                 nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (a0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          connectives.ex
                            nat.nat
                            (b0:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times a0 n) (nat.times b0 m))
                                  x_1)
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b0 m) (nat.times a0 n))
                                  x_1))))
                      (connectives.ex_intro
                         nat.nat
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.ex
                            nat.nat
                            (b0:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times x n) (nat.times b0 m))
                                  (nat.minus
                                     (nat.times a (div_mod.mod m n))
                                     (nat.times b n)))
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b0 m) (nat.times x n))
                                  (nat.minus
                                     (nat.times a (div_mod.mod m n))
                                     (nat.times b n)))))
                         (nat.plus b (nat.times a (div_mod.div m n)))
                         (connectives.ex_intro
                            nat.nat
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n)
                                     (nat.times x m))
                                  (nat.minus
                                     (nat.times a (div_mod.mod m n))
                                     (nat.times b n)))
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times x m)
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n))
                                  (nat.minus
                                     (nat.times a (div_mod.mod m n))
                                     (nat.times b n))))
                            a
                            (connectives.or_intror
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n)
                                     (nat.times a m))
                                  (nat.minus
                                     (nat.times a (div_mod.mod m n))
                                     (nat.times b n)))
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times a m)
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n))
                                  (nat.minus
                                     (nat.times a (div_mod.mod m n))
                                     (nat.times b n)))
                               (logic.eq_ind
                                  nat.nat
                                  (nat.plus (nat.times a (div_mod.div m n)) b)
                                  (x_1:(cts.Term
                                          cts.diamond
                                          (cts.cast
                                             cts.triangle
                                             cts.sinf
                                             (cts.univ cts.box cts.triangle cts.I)
                                             (cts.univ cts.diamond cts.sinf cts.I)
                                             cts.I
                                             nat.nat)) =>
                                   logic.eq
                                     nat.nat
                                     (nat.minus (nat.times a m) (nat.times x_1 n))
                                     (nat.minus
                                        (nat.times a (div_mod.mod m n))
                                        (nat.times b n)))
                                  (logic.eq_ind_r
                                     nat.nat
                                     (nat.plus
                                        (nat.times (nat.times a (div_mod.div m n)) n)
                                        (nat.times b n))
                                     (x:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat.nat)) =>
                                      logic.eq
                                        nat.nat
                                        (nat.minus (nat.times a m) x)
                                        (nat.minus
                                           (nat.times a (div_mod.mod m n))
                                           (nat.times b n)))
                                     (logic.eq_ind_r
                                        nat.nat
                                        (nat.plus
                                           (nat.times (div_mod.div m n) n)
                                           (div_mod.mod m n))
                                        (x:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           (nat.minus
                                              (nat.times a x)
                                              (nat.plus
                                                 (nat.times
                                                    (nat.times a (div_mod.div m n))
                                                    n)
                                                 (nat.times b n)))
                                           (nat.minus
                                              (nat.times a (div_mod.mod m n))
                                              (nat.times b n)))
                                        (logic.eq_ind_r
                                           nat.nat
                                           (nat.times a (nat.times (div_mod.div m n) n))
                                           (x:(cts.Term
                                                 cts.diamond
                                                 (cts.cast
                                                    cts.triangle
                                                    cts.sinf
                                                    (cts.univ
                                                       cts.box
                                                       cts.triangle
                                                       cts.I)
                                                    (cts.univ
                                                       cts.diamond
                                                       cts.sinf
                                                       cts.I)
                                                    cts.I
                                                    nat.nat)) =>
                                            logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.times
                                                    a
                                                    (nat.plus
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)
                                                       (div_mod.mod m n)))
                                                 (nat.plus x (nat.times b n)))
                                              (nat.minus
                                                 (nat.times a (div_mod.mod m n))
                                                 (nat.times b n)))
                                           (logic.eq_ind
                                              nat.nat
                                              (nat.plus
                                                 (div_mod.mod m n)
                                                 (nat.times (div_mod.div m n) n))
                                              (x_1:(cts.Term
                                                      cts.diamond
                                                      (cts.cast
                                                         cts.triangle
                                                         cts.sinf
                                                         (cts.univ
                                                            cts.box
                                                            cts.triangle
                                                            cts.I)
                                                         (cts.univ
                                                            cts.diamond
                                                            cts.sinf
                                                            cts.I)
                                                         cts.I
                                                         nat.nat)) =>
                                               logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.times a x_1)
                                                    (nat.plus
                                                       (nat.times
                                                          a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times b n)))
                                                 (nat.minus
                                                    (nat.times a (div_mod.mod m n))
                                                    (nat.times b n)))
                                              (logic.eq_ind_r
                                                 nat.nat
                                                 (nat.plus
                                                    (nat.times a (div_mod.mod m n))
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)))
                                                 (x:(cts.Term
                                                       cts.diamond
                                                       (cts.cast
                                                          cts.triangle
                                                          cts.sinf
                                                          (cts.univ
                                                             cts.box
                                                             cts.triangle
                                                             cts.I)
                                                          (cts.univ
                                                             cts.diamond
                                                             cts.sinf
                                                             cts.I)
                                                          cts.I
                                                          nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    (nat.minus
                                                       x
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times b n)))
                                                    (nat.minus
                                                       (nat.times
                                                          a
                                                          (div_mod.mod m n))
                                                       (nat.times b n)))
                                                 (logic.eq_ind
                                                    nat.nat
                                                    (nat.minus
                                                       (nat.minus
                                                          (nat.plus
                                                             (nat.times
                                                                a
                                                                (div_mod.mod m n))
                                                             (nat.times
                                                                a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m
                                                                    n)
                                                                   n)))
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))
                                                       (nat.times b n))
                                                    (x_1:(cts.Term
                                                            cts.diamond
                                                            (cts.cast
                                                               cts.triangle
                                                               cts.sinf
                                                               (cts.univ
                                                                  cts.box
                                                                  cts.triangle
                                                                  cts.I)
                                                               (cts.univ
                                                                  cts.diamond
                                                                  cts.sinf
                                                                  cts.I)
                                                               cts.I
                                                               nat.nat)) =>
                                                     logic.eq
                                                       nat.nat
                                                       x_1
                                                       (nat.minus
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n))
                                                          (nat.times b n)))
                                                    (logic.eq_ind
                                                       nat.nat
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n)))
                                                       (x_1:(cts.Term
                                                               cts.diamond
                                                               (cts.cast
                                                                  cts.triangle
                                                                  cts.sinf
                                                                  (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                  (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                  cts.I
                                                                  nat.nat)) =>
                                                        logic.eq
                                                          nat.nat
                                                          (nat.minus
                                                             (nat.minus
                                                                x_1
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))
                                                             (nat.times b n))
                                                          (nat.minus
                                                             (nat.times
                                                                a
                                                                (div_mod.mod m n))
                                                             (nat.times b n)))
                                                       (logic.eq_ind
                                                          nat.nat
                                                          (nat.plus
                                                             (nat.minus
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n))
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))
                                                             (nat.times
                                                                a
                                                                (div_mod.mod m n)))
                                                          (x_1:(cts.Term
                                                                  cts.diamond
                                                                  (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                           logic.eq
                                                             nat.nat
                                                             (nat.minus
                                                                x_1
                                                                (nat.times b n))
                                                             (nat.minus
                                                                (nat.times
                                                                   a
                                                                   (div_mod.mod
                                                                    m
                                                                    n))
                                                                (nat.times b n)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.times
                                                                n
                                                                (div_mod.div m n))
                                                             (__:(cts.Term
                                                                    cts.diamond
                                                                    (
                                                                    cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                (nat.minus
                                                                   (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    __)
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                   (nat.times
                                                                    b
                                                                    n))
                                                                (nat.minus
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                   (nat.times
                                                                    b
                                                                    n)))
                                                             (logic.rewrite_r
                                                                nat.nat
                                                                (nat.times
                                                                   n
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                (__:(
                                                                 cts.Term
                                                                   cts.diamond
                                                                   (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                   (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                (logic.rewrite_r
                                                                   nat.nat
                                                                   (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m
                                                                    n))
                                                                   (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    a
                                                                    __))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                   (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    __)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    nat.O
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    __)
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    b
                                                                    n)))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    __))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    __)
                                                                    (logic.refl
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    n
                                                                    b))
                                                                    (let_clause_1544
                                                                    p
                                                                    q
                                                                    Hind
                                                                    m
                                                                    n
                                                                    posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm
                                                                    a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.commutative_times
                                                                    b
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.times
                                                                    n
                                                                    b))
                                                                    (let_clause_1544
                                                                    p
                                                                    q
                                                                    Hind
                                                                    m
                                                                    n
                                                                    posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm
                                                                    a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.commutative_times
                                                                    b
                                                                    n))
                                                                    (nat.plus
                                                                    nat.O
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.plus_O_n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n))))
                                                                    (nat.minus_n_n
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))))
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    (nat.times_times
                                                                    a
                                                                    n
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)
                                                                   (nat.commutative_times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n))
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                (nat.times_times
                                                                   a
                                                                   n
                                                                   (div_mod.div
                                                                    m
                                                                    n)))
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)
                                                             (nat.commutative_times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.minus
                                                             (nat.plus
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n))
                                                                (nat.times
                                                                   a
                                                                   (div_mod.mod
                                                                    m
                                                                    n)))
                                                             (nat.times
                                                                a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m
                                                                    n)
                                                                   n)))
                                                          (nat.plus_minus
                                                             (nat.times
                                                                a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m
                                                                    n)
                                                                   n))
                                                             (nat.times
                                                                a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m
                                                                    n)
                                                                   n))
                                                             (nat.times
                                                                a
                                                                (div_mod.mod m n))
                                                             (nat.le_n
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))))
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n))
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))
                                                       (nat.commutative_plus
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n))))
                                                    (nat.minus
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n))
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times b n)))
                                                    (nat.minus_plus
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n))
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))
                                                       (nat.times
                                                          a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times b n)))
                                                 (nat.times
                                                    a
                                                    (nat.plus
                                                       (div_mod.mod m n)
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)))
                                                 (nat.distributive_times_plus
                                                    a
                                                    (div_mod.mod m n)
                                                    (nat.times (div_mod.div m n) n)))
                                              (nat.plus
                                                 (nat.times (div_mod.div m n) n)
                                                 (div_mod.mod m n))
                                              (nat.commutative_plus
                                                 (div_mod.mod m n)
                                                 (nat.times (div_mod.div m n) n)))
                                           (nat.times (nat.times a (div_mod.div m n)) n)
                                           (nat.associative_times a (div_mod.div m n) n))
                                        m
                                        (div_mod.div_mod m n))
                                     (nat.times
                                        (nat.plus (nat.times a (div_mod.div m n)) b)
                                        n)
                                     (nat.distributive_times_plus_r
                                        n
                                        (nat.times a (div_mod.div m n))
                                        b))
                                  (nat.plus b (nat.times a (div_mod.div m n)))
                                  (nat.commutative_plus (nat.times a (div_mod.div m n)) b)))))
                      (gcd_aux q n (div_mod.mod m n))
                      H)
                   (H:(cts.Term
                         cts.star
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                            (gcd_aux q n (div_mod.mod m n)))) =>
                    logic.eq_ind
                      nat.nat
                      (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
                      (x_1:(cts.Term
                              cts.diamond
                              (cts.cast
                                 cts.triangle
                                 cts.sinf
                                 (cts.univ cts.box cts.triangle cts.I)
                                 (cts.univ cts.diamond cts.sinf cts.I)
                                 cts.I
                                 nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (a0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          connectives.ex
                            nat.nat
                            (b0:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times a0 n) (nat.times b0 m))
                                  x_1)
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b0 m) (nat.times a0 n))
                                  x_1))))
                      (connectives.ex_intro
                         nat.nat
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.ex
                            nat.nat
                            (b0:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times x n) (nat.times b0 m))
                                  (nat.minus
                                     (nat.times b n)
                                     (nat.times a (div_mod.mod m n))))
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b0 m) (nat.times x n))
                                  (nat.minus
                                     (nat.times b n)
                                     (nat.times a (div_mod.mod m n))))))
                         (nat.plus b (nat.times a (div_mod.div m n)))
                         (connectives.ex_intro
                            nat.nat
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n)
                                     (nat.times x m))
                                  (nat.minus
                                     (nat.times b n)
                                     (nat.times a (div_mod.mod m n))))
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times x m)
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n))
                                  (nat.minus
                                     (nat.times b n)
                                     (nat.times a (div_mod.mod m n)))))
                            a
                            (connectives.or_introl
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n)
                                     (nat.times a m))
                                  (nat.minus
                                     (nat.times b n)
                                     (nat.times a (div_mod.mod m n))))
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times a m)
                                     (nat.times
                                        (nat.plus b (nat.times a (div_mod.div m n)))
                                        n))
                                  (nat.minus
                                     (nat.times b n)
                                     (nat.times a (div_mod.mod m n))))
                               (logic.eq_ind_r
                                  nat.nat
                                  (nat.plus
                                     (nat.times b n)
                                     (nat.times (nat.times a (div_mod.div m n)) n))
                                  (x:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat.nat)) =>
                                   logic.eq
                                     nat.nat
                                     (nat.minus x (nat.times a m))
                                     (nat.minus
                                        (nat.times b n)
                                        (nat.times a (div_mod.mod m n))))
                                  (logic.eq_ind_r
                                     nat.nat
                                     (nat.plus
                                        (nat.times (div_mod.div m n) n)
                                        (div_mod.mod m n))
                                     (x:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat.nat)) =>
                                      logic.eq
                                        nat.nat
                                        (nat.minus
                                           (nat.plus
                                              (nat.times b n)
                                              (nat.times
                                                 (nat.times a (div_mod.div m n))
                                                 n))
                                           (nat.times a x))
                                        (nat.minus
                                           (nat.times b n)
                                           (nat.times a (div_mod.mod m n))))
                                     (logic.eq_ind_r
                                        nat.nat
                                        (nat.plus
                                           (nat.times a (nat.times (div_mod.div m n) n))
                                           (nat.times a (div_mod.mod m n)))
                                        (x:(cts.Term
                                              cts.diamond
                                              (cts.cast
                                                 cts.triangle
                                                 cts.sinf
                                                 (cts.univ
                                                    cts.box
                                                    cts.triangle
                                                    cts.I)
                                                 (cts.univ
                                                    cts.diamond
                                                    cts.sinf
                                                    cts.I)
                                                 cts.I
                                                 nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           (nat.minus
                                              (nat.plus
                                                 (nat.times b n)
                                                 (nat.times
                                                    (nat.times a (div_mod.div m n))
                                                    n))
                                              x)
                                           (nat.minus
                                              (nat.times b n)
                                              (nat.times a (div_mod.mod m n))))
                                        (logic.eq_ind_r
                                           nat.nat
                                           (nat.times a (nat.times (div_mod.div m n) n))
                                           (x:(cts.Term
                                                 cts.diamond
                                                 (cts.cast
                                                    cts.triangle
                                                    cts.sinf
                                                    (cts.univ
                                                       cts.box
                                                       cts.triangle
                                                       cts.I)
                                                    (cts.univ
                                                       cts.diamond
                                                       cts.sinf
                                                       cts.I)
                                                    cts.I
                                                    nat.nat)) =>
                                            logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.plus (nat.times b n) x)
                                                 (nat.plus
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n))
                                                    (nat.times a (div_mod.mod m n))))
                                              (nat.minus
                                                 (nat.times b n)
                                                 (nat.times a (div_mod.mod m n))))
                                           (logic.eq_ind
                                              nat.nat
                                              (nat.minus
                                                 (nat.minus
                                                    (nat.plus
                                                       (nat.times b n)
                                                       (nat.times
                                                          a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n)))
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)))
                                                 (nat.times a (div_mod.mod m n)))
                                              (x_1:(cts.Term
                                                      cts.diamond
                                                      (cts.cast
                                                         cts.triangle
                                                         cts.sinf
                                                         (cts.univ
                                                            cts.box
                                                            cts.triangle
                                                            cts.I)
                                                         (cts.univ
                                                            cts.diamond
                                                            cts.sinf
                                                            cts.I)
                                                         cts.I
                                                         nat.nat)) =>
                                               logic.eq
                                                 nat.nat
                                                 x_1
                                                 (nat.minus
                                                    (nat.times b n)
                                                    (nat.times a (div_mod.mod m n))))
                                              (logic.eq_ind
                                                 nat.nat
                                                 (nat.plus
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n))
                                                    (nat.times b n))
                                                 (x_1:(cts.Term
                                                         cts.diamond
                                                         (cts.cast
                                                            cts.triangle
                                                            cts.sinf
                                                            (cts.univ
                                                               cts.box
                                                               cts.triangle
                                                               cts.I)
                                                            (cts.univ
                                                               cts.diamond
                                                               cts.sinf
                                                               cts.I)
                                                            cts.I
                                                            nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    (nat.minus
                                                       (nat.minus
                                                          x_1
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))
                                                       (nat.times
                                                          a
                                                          (div_mod.mod m n)))
                                                    (nat.minus
                                                       (nat.times b n)
                                                       (nat.times
                                                          a
                                                          (div_mod.mod m n))))
                                                 (logic.eq_ind
                                                    nat.nat
                                                    (nat.plus
                                                       (nat.minus
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))
                                                       (nat.times b n))
                                                    (x_1:(cts.Term
                                                            cts.diamond
                                                            (cts.cast
                                                               cts.triangle
                                                               cts.sinf
                                                               (cts.univ
                                                                  cts.box
                                                                  cts.triangle
                                                                  cts.I)
                                                               (cts.univ
                                                                  cts.diamond
                                                                  cts.sinf
                                                                  cts.I)
                                                               cts.I
                                                               nat.nat)) =>
                                                     logic.eq
                                                       nat.nat
                                                       (nat.minus
                                                          x_1
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n)))
                                                       (nat.minus
                                                          (nat.times b n)
                                                          (nat.times
                                                             a
                                                             (div_mod.mod m n))))
                                                    (logic.rewrite_r
                                                       nat.nat
                                                       (nat.times
                                                          n
                                                          (div_mod.div m n))
                                                       (__:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat.nat)) =>
                                                        logic.eq
                                                          nat.nat
                                                          (nat.minus
                                                             (nat.plus
                                                                (nat.minus
                                                                   (nat.times
                                                                    a
                                                                    __)
                                                                   (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))
                                                                (nat.times b n))
                                                             (nat.times
                                                                a
                                                                (div_mod.mod m n)))
                                                          (nat.minus
                                                             (nat.times b n)
                                                             (nat.times
                                                                a
                                                                (div_mod.mod m n))))
                                                       (logic.rewrite_r
                                                          nat.nat
                                                          (nat.times
                                                             n
                                                             (nat.times
                                                                a
                                                                (div_mod.div m n)))
                                                          (__:(cts.Term
                                                                 cts.diamond
                                                                 (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (
                                                                    cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (
                                                                    cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                           logic.eq
                                                             nat.nat
                                                             (nat.minus
                                                                (nat.plus
                                                                   (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m
                                                                    n)
                                                                    n)))
                                                                   (nat.times
                                                                    b
                                                                    n))
                                                                (nat.times
                                                                   a
                                                                   (div_mod.mod
                                                                    m
                                                                    n)))
                                                             (nat.minus
                                                                (nat.times b n)
                                                                (nat.times
                                                                   a
                                                                   (div_mod.mod
                                                                    m
                                                                    n))))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.times
                                                                n
                                                                (div_mod.div m n))
                                                             (__:(cts.Term
                                                                    cts.diamond
                                                                    (
                                                                    cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                (nat.minus
                                                                   (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    a
                                                                    __))
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                (nat.minus
                                                                   (nat.times
                                                                    b
                                                                    n)
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                             (logic.rewrite_r
                                                                nat.nat
                                                                (nat.times
                                                                   n
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                (__:(
                                                                 cts.Term
                                                                   cts.diamond
                                                                   (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    __)
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                   (nat.minus
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   nat.O
                                                                   (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    __
                                                                    (nat.times
                                                                    b
                                                                    n))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                   (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    nat.O
                                                                    __)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n))
                                                                    __)
                                                                    (logic.refl
                                                                    nat.nat
                                                                    (gcd_aux
                                                                    q
                                                                    n
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (let_clause_15441
                                                                    p
                                                                    q
                                                                    Hind
                                                                    m
                                                                    n
                                                                    posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm
                                                                    a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.commutative_times
                                                                    b
                                                                    n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    b)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m
                                                                    n)))
                                                                    (let_clause_15441
                                                                    p
                                                                    q
                                                                    Hind
                                                                    m
                                                                    n
                                                                    posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm
                                                                    a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.plus
                                                                    nat.O
                                                                    (nat.times
                                                                    n
                                                                    b))
                                                                    (nat.plus_O_n
                                                                    (nat.times
                                                                    n
                                                                    b)))
                                                                    (nat.times
                                                                    b
                                                                    n)
                                                                    (nat.commutative_times
                                                                    b
                                                                    n))
                                                                   (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n))))
                                                                   (nat.minus_n_n
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m
                                                                    n)))))
                                                                (nat.times
                                                                   a
                                                                   (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m
                                                                    n)))
                                                                (nat.times_times
                                                                   a
                                                                   n
                                                                   (div_mod.div
                                                                    m
                                                                    n)))
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)
                                                             (nat.commutative_times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                n
                                                                (div_mod.div m n)))
                                                          (nat.times_times
                                                             a
                                                             n
                                                             (div_mod.div m n)))
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)
                                                       (nat.commutative_times
                                                          (div_mod.div m n)
                                                          n))
                                                    (nat.minus
                                                       (nat.plus
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n))
                                                          (nat.times b n))
                                                       (nat.times
                                                          a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n)))
                                                    (nat.plus_minus
                                                       (nat.times
                                                          a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times
                                                          a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times b n)
                                                       (nat.le_n
                                                          (nat.times
                                                             a
                                                             (nat.times
                                                                (div_mod.div m n)
                                                                n)))))
                                                 (nat.plus
                                                    (nat.times b n)
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)))
                                                 (nat.commutative_plus
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n))
                                                    (nat.times b n)))
                                              (nat.minus
                                                 (nat.plus
                                                    (nat.times b n)
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)))
                                                 (nat.plus
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n))
                                                    (nat.times a (div_mod.mod m n))))
                                              (nat.minus_plus
                                                 (nat.plus
                                                    (nat.times b n)
                                                    (nat.times
                                                       a
                                                       (nat.times
                                                          (div_mod.div m n)
                                                          n)))
                                                 (nat.times
                                                    a
                                                    (nat.times (div_mod.div m n) n))
                                                 (nat.times a (div_mod.mod m n))))
                                           (nat.times (nat.times a (div_mod.div m n)) n)
                                           (nat.associative_times a (div_mod.div m n) n))
                                        (nat.times
                                           a
                                           (nat.plus
                                              (nat.times (div_mod.div m n) n)
                                              (div_mod.mod m n)))
                                        (nat.distributive_times_plus
                                           a
                                           (nat.times (div_mod.div m n) n)
                                           (div_mod.mod m n)))
                                     m
                                     (div_mod.div_mod m n))
                                  (nat.times (nat.plus b (nat.times a (div_mod.div m n))) n)
                                  (nat.distributive_times_plus_r
                                     n
                                     b
                                     (nat.times a (div_mod.div m n)))))))
                      (gcd_aux q n (div_mod.mod m n))
                      H)
                   _clearme0)
                _clearme)
             (Hind
                n
                (div_mod.mod m n)
                (connectives.match_Or_prop
                   (nat.lt nat.O (div_mod.mod m n))
                   (logic.eq nat.nat nat.O (div_mod.mod m n))
                   (nat.lt nat.O (div_mod.mod m n))
                   (auto:(cts.Term cts.star (nat.lt nat.O (div_mod.mod m n))) => auto)
                   (modO:(cts.Term cts.star (logic.eq nat.nat nat.O (div_mod.mod m n))) =>
                    connectives.falsity
                      (nat.lt nat.O (div_mod.mod m n))
                      (logic.absurd
                         (primes.divides n m)
                         (primes.mod_O_to_divides
                            n
                            m
                            posn
                            (logic.rewrite_l
                               nat.nat
                               nat.O
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq nat.nat __ nat.O)
                               (logic.refl nat.nat nat.O)
                               (div_mod.mod m n)
                               modO))
                         ndivnm))
                   (nat.le_to_or_lt_eq nat.O (div_mod.mod m n) (nat.le_O_n (div_mod.mod m n))))
                (nat.lt_to_le (div_mod.mod m n) n (div_mod.lt_mod_m_m m n posn))
                (nat.le_S_S_to_le
                   (div_mod.mod m n)
                   q
                   (nat.transitive_le
                      (nat.S (div_mod.mod m n))
                      n
                      (nat.S q)
                      (div_mod.lt_mod_m_m m n posn)
                      lenS))))
          (gcd_aux (nat.S q) m n)
          (not_divides_to_gcd_aux q m n posn ndivnm))
       (primes.decidable_divides n m))
    p.

def let_clause_1549 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O x0)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat nat.O x)
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3 => logic.eq nat.nat x3 (nat.minus x3 x)))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  eqm0:(cts.Term cts.star (logic.eq nat.nat nat.O m)) =>
  x1106:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
  logic.rewrite_l
    nat.nat
    nat.O
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat x1106 (nat.minus x1106 __))
    (nat.minus_n_O x1106)
    m
    eqm0.

def let_clause_15491 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat.nat nat.O x0)
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2 => logic.eq nat.nat x2 (nat.minus x2 x0))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  eqn0:(cts.Term cts.star (logic.eq nat.nat nat.O n)) =>
  x1106:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
  logic.rewrite_l
    nat.nat
    nat.O
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat x1106 (nat.minus x1106 __))
    (nat.minus_n_O x1106)
    n
    eqn0.

def let_clause_1551 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat.nat nat.O x0)
             (x1 =>
              cts.prod
                cts.box
                cts.star
                cts.star
                cts.I
                nat.nat
                (x2 => logic.eq nat.nat x0 (nat.times x2 x0))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  eqn0:(cts.Term cts.star (logic.eq nat.nat nat.O n)) =>
  x347:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
  logic.rewrite_l
    nat.nat
    nat.O
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat n (nat.times x347 __))
    (logic.rewrite_l
       nat.nat
       nat.O
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        logic.eq nat.nat __ (nat.times x347 nat.O))
       (nat.times_n_O x347)
       n
       eqn0)
    n
    eqn0.

def eq_minus_gcd :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           connectives.ex
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times a x0) (nat.times b x)) (gcd x0 x))
                   (logic.eq nat.nat (nat.minus (nat.times b x) (nat.times a x0)) (gcd x0 x)))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  connectives.match_Or_prop
    (nat.lt nat.O n)
    (logic.eq nat.nat nat.O n)
    (connectives.ex
       nat.nat
       (a:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.ex
          nat.nat
          (b:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.Or
             (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) (gcd n m))
             (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))
    (posn:(cts.Term cts.star (nat.lt nat.O n)) =>
     connectives.match_Or_prop
       (nat.lt nat.O m)
       (logic.eq nat.nat nat.O m)
       (connectives.ex
          nat.nat
          (a:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (b:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) (gcd n m))
                (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))
       (posm:(cts.Term cts.star (nat.lt nat.O m)) =>
        nat.leb_elim
          n
          m
          (__:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    bool.bool)) =>
           connectives.ex
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times a n) (nat.times b m))
                      (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) __))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times b m) (nat.times a n))
                      (bool.match_bool_type nat.nat (gcd_aux n m n) (gcd_aux m n m) __)))))
          (bool.sym_eq_match_bool_type_true
             nat.nat
             (gcd_aux n m n)
             (gcd_aux m n m)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (nat.le n m)
                (x =>
                 connectives.ex
                   nat.nat
                   (a:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    connectives.ex
                      nat.nat
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.Or
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a n) (nat.times b m))
                            (bool.match_bool_type
                               nat.nat
                               (gcd_aux n m n)
                               (gcd_aux m n m)
                               bool.true))
                         (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) y)))))
             (bool.sym_eq_match_bool_type_true
                nat.nat
                (gcd_aux n m n)
                (gcd_aux m n m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (nat.le n m)
                   (x =>
                    connectives.ex
                      nat.nat
                      (a:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (b:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) y)
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd_aux n m n))))))
                (lenm:(cts.Term cts.star (nat.le n m)) =>
                 eq_minus_gcd_aux n m n posn lenm (nat.le_n n))))
          (bool.sym_eq_match_bool_type_false
             nat.nat
             (gcd_aux n m n)
             (gcd_aux m n m)
             (y:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (connectives.Not (nat.le n m))
                (x =>
                 connectives.ex
                   nat.nat
                   (a:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    connectives.ex
                      nat.nat
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.Or
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a n) (nat.times b m))
                            (bool.match_bool_type
                               nat.nat
                               (gcd_aux n m n)
                               (gcd_aux m n m)
                               bool.false))
                         (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) y)))))
             (bool.sym_eq_match_bool_type_false
                nat.nat
                (gcd_aux n m n)
                (gcd_aux m n m)
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (connectives.Not (nat.le n m))
                   (x =>
                    connectives.ex
                      nat.nat
                      (a:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (b:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) y)
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd_aux m n m))))))
                (nlenm:(cts.Term cts.star (connectives.Not (nat.le n m))) =>
                 connectives.match_ex_prop
                   nat.nat
                   (a:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    connectives.ex
                      nat.nat
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.Or
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a m) (nat.times b n))
                            (gcd_aux m n m))
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times b n) (nat.times a m))
                            (gcd_aux m n m))))
                   (connectives.ex
                      nat.nat
                      (a:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (b:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.Or
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times a n) (nat.times b m))
                               (gcd_aux m n m))
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd_aux m n m)))))
                   (a:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    _clearme:(cts.Term
                                cts.star
                                (connectives.ex
                                   nat.nat
                                   (b:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat.nat)) =>
                                    connectives.Or
                                      (logic.eq
                                         nat.nat
                                         (nat.minus (nat.times a m) (nat.times b n))
                                         (gcd_aux m n m))
                                      (logic.eq
                                         nat.nat
                                         (nat.minus (nat.times b n) (nat.times a m))
                                         (gcd_aux m n m))))) =>
                    connectives.match_ex_prop
                      nat.nat
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.Or
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a m) (nat.times b n))
                            (gcd_aux m n m))
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times b n) (nat.times a m))
                            (gcd_aux m n m)))
                      (connectives.ex
                         nat.nat
                         (a0:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          connectives.ex
                            nat.nat
                            (b:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.Or
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times a0 n) (nat.times b m))
                                  (gcd_aux m n m))
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b m) (nat.times a0 n))
                                  (gcd_aux m n m)))))
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       _clearme0:(cts.Term
                                    cts.star
                                    (connectives.Or
                                       (logic.eq
                                          nat.nat
                                          (nat.minus (nat.times a m) (nat.times b n))
                                          (gcd_aux m n m))
                                       (logic.eq
                                          nat.nat
                                          (nat.minus (nat.times b n) (nat.times a m))
                                          (gcd_aux m n m)))) =>
                       connectives.match_Or_prop
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a m) (nat.times b n))
                            (gcd_aux m n m))
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times b n) (nat.times a m))
                            (gcd_aux m n m))
                         (connectives.ex
                            nat.nat
                            (a0:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             connectives.ex
                               nat.nat
                               (b0:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times a0 n) (nat.times b0 m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b0 m) (nat.times a0 n))
                                     (gcd_aux m n m)))))
                         (H:(cts.Term
                               cts.star
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times a m) (nat.times b n))
                                  (gcd_aux m n m))) =>
                          connectives.ex_intro
                            nat.nat
                            (x:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.ex
                               nat.nat
                               (b0:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times x n) (nat.times b0 m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b0 m) (nat.times x n))
                                     (gcd_aux m n m))))
                            b
                            (connectives.ex_intro
                               nat.nat
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b n) (nat.times x m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times x m) (nat.times b n))
                                     (gcd_aux m n m)))
                               a
                               (connectives.or_intror
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b n) (nat.times a m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times a m) (nat.times b n))
                                     (gcd_aux m n m))
                                  (logic.rewrite_r
                                     nat.nat
                                     (nat.times m a)
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat.nat)) =>
                                      logic.eq
                                        nat.nat
                                        (nat.minus __ (nat.times b n))
                                        (gcd_aux m n m))
                                     (logic.rewrite_r
                                        nat.nat
                                        (nat.times n b)
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           (nat.minus (nat.times m a) __)
                                           (gcd_aux m n m))
                                        (logic.rewrite_r
                                           nat.nat
                                           (gcd_aux m n m)
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat.nat)) =>
                                            logic.eq nat.nat __ (gcd_aux m n m))
                                           (logic.refl nat.nat (gcd_aux m n m))
                                           (nat.minus (nat.times m a) (nat.times n b))
                                           (logic.rewrite_l
                                              nat.nat
                                              (nat.times b n)
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq
                                                 nat.nat
                                                 (nat.minus (nat.times m a) __)
                                                 (gcd_aux m n m))
                                              (logic.rewrite_l
                                                 nat.nat
                                                 (nat.times a m)
                                                 (__:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    (nat.minus __ (nat.times b n))
                                                    (gcd_aux m n m))
                                                 H
                                                 (nat.times m a)
                                                 (nat.commutative_times a m))
                                              (nat.times n b)
                                              (nat.commutative_times b n)))
                                        (nat.times b n)
                                        (nat.commutative_times b n))
                                     (nat.times a m)
                                     (nat.commutative_times a m)))))
                         (H:(cts.Term
                               cts.star
                               (logic.eq
                                  nat.nat
                                  (nat.minus (nat.times b n) (nat.times a m))
                                  (gcd_aux m n m))) =>
                          connectives.ex_intro
                            nat.nat
                            (y:(cts.Term
                                  cts.diamond
                                  (cts.cast
                                     cts.triangle
                                     cts.sinf
                                     (cts.univ cts.box cts.triangle cts.I)
                                     (cts.univ cts.diamond cts.sinf cts.I)
                                     cts.I
                                     nat.nat)) =>
                             connectives.ex
                               nat.nat
                               (b0:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times y n) (nat.times b0 m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b0 m) (nat.times y n))
                                     (gcd_aux m n m))))
                            b
                            (connectives.ex_intro
                               nat.nat
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                connectives.Or
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b n) (nat.times x m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times x m) (nat.times b n))
                                     (gcd_aux m n m)))
                               a
                               (connectives.or_introl
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times b n) (nat.times a m))
                                     (gcd_aux m n m))
                                  (logic.eq
                                     nat.nat
                                     (nat.minus (nat.times a m) (nat.times b n))
                                     (gcd_aux m n m))
                                  (logic.rewrite_r
                                     nat.nat
                                     (nat.times n b)
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat.nat)) =>
                                      logic.eq
                                        nat.nat
                                        (nat.minus __ (nat.times a m))
                                        (gcd_aux m n m))
                                     (logic.rewrite_r
                                        nat.nat
                                        (nat.times m a)
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           (nat.minus (nat.times n b) __)
                                           (gcd_aux m n m))
                                        (logic.rewrite_r
                                           nat.nat
                                           (gcd_aux m n m)
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat.nat)) =>
                                            logic.eq nat.nat __ (gcd_aux m n m))
                                           (logic.refl nat.nat (gcd_aux m n m))
                                           (nat.minus (nat.times n b) (nat.times m a))
                                           (logic.rewrite_l
                                              nat.nat
                                              (nat.times a m)
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq
                                                 nat.nat
                                                 (nat.minus (nat.times n b) __)
                                                 (gcd_aux m n m))
                                              (logic.rewrite_l
                                                 nat.nat
                                                 (nat.times b n)
                                                 (__:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    (nat.minus __ (nat.times a m))
                                                    (gcd_aux m n m))
                                                 H
                                                 (nat.times n b)
                                                 (nat.commutative_times b n))
                                              (nat.times m a)
                                              (nat.commutative_times a m)))
                                        (nat.times a m)
                                        (nat.commutative_times a m))
                                     (nat.times b n)
                                     (nat.commutative_times b n)))))
                         _clearme0)
                      _clearme)
                   (eq_minus_gcd_aux
                      m
                      n
                      m
                      posm
                      (nat.transitive_le
                         m
                         (nat.S m)
                         n
                         (nat.le_n_Sn m)
                         (nat.not_le_to_lt n m nlenm))
                      (nat.le_n m))))))
       (eqm0:(cts.Term cts.star (logic.eq nat.nat nat.O m)) =>
        logic.eq_ind_r
          nat.nat
          m
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) (gcd n m))
                   (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))
          (connectives.ex_intro
             nat.nat
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times x n) (nat.times b m)) (gcd n m))
                   (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times x n)) (gcd n m))))
             (nat.S nat.O)
             (connectives.ex_intro
                nat.nat
                (y:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times (nat.S nat.O) n) (nat.times y m))
                      (gcd n m))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times y m) (nat.times (nat.S nat.O) n))
                      (gcd n m)))
                nat.O
                (connectives.or_introl
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m))
                      (gcd n m))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times nat.O m) (nat.times (nat.S nat.O) n))
                      (gcd n m))
                   (logic.eq_coerc
                      (logic.eq nat.nat n (nat.minus n nat.O))
                      (logic.eq
                         nat.nat
                         (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m))
                         (gcd n m))
                      (nat.minus_n_O n)
                      (logic.rewrite_r
                         nat.nat
                         m
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq
                            (cts.univ cts.star cts.box cts.I)
                            (logic.eq nat.nat n (nat.minus n __))
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times (nat.S nat.O) n) (nat.times nat.O m))
                               (gcd n m)))
                         (logic.rewrite_l
                            nat.nat
                            n
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             logic.eq
                               (cts.univ cts.star cts.box cts.I)
                               (logic.eq nat.nat n __)
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times (nat.S nat.O) n)
                                     (nat.times nat.O m))
                                  (gcd n m)))
                            (logic.rewrite_r
                               nat.nat
                               m
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq
                                  (cts.univ cts.star cts.box cts.I)
                                  (logic.eq nat.nat n n)
                                  (logic.eq
                                     nat.nat
                                     (nat.minus
                                        (nat.times (nat.S __) n)
                                        (nat.times nat.O m))
                                     (gcd n m)))
                               (logic.rewrite_r
                                  nat.nat
                                  (nat.times n (nat.S m))
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat.nat)) =>
                                   logic.eq
                                     (cts.univ cts.star cts.box cts.I)
                                     (logic.eq nat.nat n n)
                                     (logic.eq
                                        nat.nat
                                        (nat.minus __ (nat.times nat.O m))
                                        (gcd n m)))
                                  (logic.rewrite_l
                                     nat.nat
                                     (nat.plus n (nat.times n m))
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat.nat)) =>
                                      logic.eq
                                        (cts.univ cts.star cts.box cts.I)
                                        (logic.eq nat.nat n n)
                                        (logic.eq
                                           nat.nat
                                           (nat.minus __ (nat.times nat.O m))
                                           (gcd n m)))
                                     (logic.rewrite_r
                                        nat.nat
                                        (nat.times m n)
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq
                                           (cts.univ cts.star cts.box cts.I)
                                           (logic.eq nat.nat n n)
                                           (logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.plus n __)
                                                 (nat.times nat.O m))
                                              (gcd n m)))
                                        (logic.rewrite_l
                                           nat.nat
                                           m
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat.nat)) =>
                                            logic.eq
                                              (cts.univ cts.star cts.box cts.I)
                                              (logic.eq nat.nat n n)
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus
                                                    (nat.plus n __)
                                                    (nat.times nat.O m))
                                                 (gcd n m)))
                                           (logic.rewrite_r
                                              nat.nat
                                              (nat.plus m n)
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq
                                                 (cts.univ cts.star cts.box cts.I)
                                                 (logic.eq nat.nat n n)
                                                 (logic.eq
                                                    nat.nat
                                                    (nat.minus __ (nat.times nat.O m))
                                                    (gcd n m)))
                                              (logic.rewrite_l
                                                 nat.nat
                                                 n
                                                 (__:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat.nat)) =>
                                                  logic.eq
                                                    (cts.univ cts.star cts.box cts.I)
                                                    (logic.eq nat.nat n n)
                                                    (logic.eq
                                                       nat.nat
                                                       (nat.minus
                                                          __
                                                          (nat.times nat.O m))
                                                       (gcd n m)))
                                                 (logic.rewrite_r
                                                    nat.nat
                                                    m
                                                    (__:(cts.Term
                                                           cts.diamond
                                                           (cts.cast
                                                              cts.triangle
                                                              cts.sinf
                                                              (cts.univ
                                                                 cts.box
                                                                 cts.triangle
                                                                 cts.I)
                                                              (cts.univ
                                                                 cts.diamond
                                                                 cts.sinf
                                                                 cts.I)
                                                              cts.I
                                                              nat.nat)) =>
                                                     logic.eq
                                                       (cts.univ
                                                          cts.star
                                                          cts.box
                                                          cts.I)
                                                       (logic.eq nat.nat n n)
                                                       (logic.eq
                                                          nat.nat
                                                          (nat.minus
                                                             n
                                                             (nat.times __ m))
                                                          (gcd n m)))
                                                    (logic.rewrite_l
                                                       nat.nat
                                                       m
                                                       (__:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat.nat)) =>
                                                        logic.eq
                                                          (cts.univ
                                                             cts.star
                                                             cts.box
                                                             cts.I)
                                                          (logic.eq nat.nat n n)
                                                          (logic.eq
                                                             nat.nat
                                                             (nat.minus n __)
                                                             (gcd n m)))
                                                       (logic.rewrite_l
                                                          nat.nat
                                                          n
                                                          (__:(cts.Term
                                                                 cts.diamond
                                                                 (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (
                                                                    cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (
                                                                    cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                           logic.eq
                                                             (cts.univ
                                                                cts.star
                                                                cts.box
                                                                cts.I)
                                                             (logic.eq nat.nat n n)
                                                             (logic.eq
                                                                nat.nat
                                                                __
                                                                (gcd n m)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (gcd m n)
                                                             (__:(cts.Term
                                                                    cts.diamond
                                                                    (
                                                                    cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                (cts.univ
                                                                   cts.star
                                                                   cts.box
                                                                   cts.I)
                                                                (logic.eq
                                                                   nat.nat
                                                                   n
                                                                   n)
                                                                (logic.eq
                                                                   nat.nat
                                                                   n
                                                                   __))
                                                             (logic.rewrite_r
                                                                nat.nat
                                                                n
                                                                (__:(
                                                                 cts.Term
                                                                   cts.diamond
                                                                   (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   (cts.univ
                                                                    cts.star
                                                                    cts.box
                                                                    cts.I)
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    n)
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    __))
                                                                (logic.refl
                                                                   (cts.univ
                                                                    cts.star
                                                                    cts.box
                                                                    cts.I)
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    n))
                                                                (gcd m n)
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   nat.O
                                                                   (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd __ n)
                                                                    n)
                                                                   (gcd_O_l n)
                                                                   m
                                                                   eqm0))
                                                             (gcd n m)
                                                             (commutative_gcd n m))
                                                          (nat.minus n m)
                                                          (let_clause_1549
                                                             m
                                                             n
                                                             posn
                                                             eqm0
                                                             n))
                                                       (nat.times m m)
                                                       (logic.rewrite_l
                                                          nat.nat
                                                          nat.O
                                                          (__:(cts.Term
                                                                 cts.diamond
                                                                 (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (
                                                                    cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (
                                                                    cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                           logic.eq
                                                             nat.nat
                                                             m
                                                             (nat.times m __))
                                                          (logic.rewrite_l
                                                             nat.nat
                                                             nat.O
                                                             (__:(cts.Term
                                                                    cts.diamond
                                                                    (
                                                                    cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                __
                                                                (nat.times
                                                                   m
                                                                   nat.O))
                                                             (nat.times_n_O m)
                                                             m
                                                             eqm0)
                                                          m
                                                          eqm0))
                                                    nat.O
                                                    eqm0)
                                                 (nat.plus m n)
                                                 (logic.rewrite_l
                                                    nat.nat
                                                    nat.O
                                                    (__:(cts.Term
                                                           cts.diamond
                                                           (cts.cast
                                                              cts.triangle
                                                              cts.sinf
                                                              (cts.univ
                                                                 cts.box
                                                                 cts.triangle
                                                                 cts.I)
                                                              (cts.univ
                                                                 cts.diamond
                                                                 cts.sinf
                                                                 cts.I)
                                                              cts.I
                                                              nat.nat)) =>
                                                     logic.eq
                                                       nat.nat
                                                       n
                                                       (nat.plus __ n))
                                                    (nat.plus_O_n n)
                                                    m
                                                    eqm0))
                                              (nat.plus n m)
                                              (nat.commutative_plus n m))
                                           (nat.times m n)
                                           (logic.rewrite_l
                                              nat.nat
                                              nat.O
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq nat.nat m (nat.times __ n))
                                              (logic.rewrite_l
                                                 nat.nat
                                                 nat.O
                                                 (__:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    __
                                                    (nat.times nat.O n))
                                                 (nat.times_O_n n)
                                                 m
                                                 eqm0)
                                              m
                                              eqm0))
                                        (nat.times n m)
                                        (nat.commutative_times n m))
                                     (nat.times n (nat.S m))
                                     (nat.times_n_Sm n m))
                                  (nat.times (nat.S m) n)
                                  (nat.commutative_times (nat.S m) n))
                               nat.O
                               eqm0)
                            (nat.minus n m)
                            (let_clause_1549 m n posn eqm0 n))
                         nat.O
                         eqm0)))))
          nat.O
          eqm0)
       (nat.le_to_or_lt_eq nat.O m (nat.le_O_n m)))
    (eqn0:(cts.Term cts.star (logic.eq nat.nat nat.O n)) =>
     logic.eq_ind_r
       nat.nat
       n
       (x:(cts.Term
             cts.diamond
             (cts.cast
                cts.triangle
                cts.sinf
                (cts.univ cts.box cts.triangle cts.I)
                (cts.univ cts.diamond cts.sinf cts.I)
                cts.I
                nat.nat)) =>
        connectives.ex
          nat.nat
          (a:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (b:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) (gcd n m))
                (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) (gcd n m)))))
       (connectives.ex_intro
          nat.nat
          (x:(cts.Term
                cts.diamond
                (cts.cast
                   cts.triangle
                   cts.sinf
                   (cts.univ cts.box cts.triangle cts.I)
                   (cts.univ cts.diamond cts.sinf cts.I)
                   cts.I
                   nat.nat)) =>
           connectives.ex
             nat.nat
             (b:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat (nat.minus (nat.times x n) (nat.times b m)) (gcd n m))
                (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times x n)) (gcd n m))))
          nat.O
          (connectives.ex_intro
             nat.nat
             (x:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat (nat.minus (nat.times nat.O n) (nat.times x m)) (gcd n m))
                (logic.eq nat.nat (nat.minus (nat.times x m) (nat.times nat.O n)) (gcd n m)))
             (nat.S nat.O)
             (connectives.or_intror
                (logic.eq
                   nat.nat
                   (nat.minus (nat.times nat.O n) (nat.times (nat.S nat.O) m))
                   (gcd n m))
                (logic.eq
                   nat.nat
                   (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n))
                   (gcd n m))
                (logic.eq_coerc
                   (logic.eq nat.nat m (nat.minus m nat.O))
                   (logic.eq
                      nat.nat
                      (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n))
                      (gcd n m))
                   (nat.minus_n_O m)
                   (logic.rewrite_r
                      nat.nat
                      m
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq
                         (cts.univ cts.star cts.box cts.I)
                         (logic.eq nat.nat m (nat.minus m nat.O))
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n))
                            __))
                      (logic.rewrite_r
                         nat.nat
                         n
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq
                            (cts.univ cts.star cts.box cts.I)
                            (logic.eq nat.nat m (nat.minus m __))
                            (logic.eq
                               nat.nat
                               (nat.minus (nat.times (nat.S nat.O) m) (nat.times nat.O n))
                               m))
                         (logic.rewrite_l
                            nat.nat
                            m
                            (__:(cts.Term
                                   cts.diamond
                                   (cts.cast
                                      cts.triangle
                                      cts.sinf
                                      (cts.univ cts.box cts.triangle cts.I)
                                      (cts.univ cts.diamond cts.sinf cts.I)
                                      cts.I
                                      nat.nat)) =>
                             logic.eq
                               (cts.univ cts.star cts.box cts.I)
                               (logic.eq nat.nat m __)
                               (logic.eq
                                  nat.nat
                                  (nat.minus
                                     (nat.times (nat.S nat.O) m)
                                     (nat.times nat.O n))
                                  m))
                            (logic.rewrite_r
                               nat.nat
                               n
                               (__:(cts.Term
                                      cts.diamond
                                      (cts.cast
                                         cts.triangle
                                         cts.sinf
                                         (cts.univ cts.box cts.triangle cts.I)
                                         (cts.univ cts.diamond cts.sinf cts.I)
                                         cts.I
                                         nat.nat)) =>
                                logic.eq
                                  (cts.univ cts.star cts.box cts.I)
                                  (logic.eq nat.nat m m)
                                  (logic.eq
                                     nat.nat
                                     (nat.minus
                                        (nat.times (nat.S __) m)
                                        (nat.times nat.O n))
                                     m))
                               (logic.rewrite_r
                                  nat.nat
                                  (nat.times m (nat.S n))
                                  (__:(cts.Term
                                         cts.diamond
                                         (cts.cast
                                            cts.triangle
                                            cts.sinf
                                            (cts.univ cts.box cts.triangle cts.I)
                                            (cts.univ cts.diamond cts.sinf cts.I)
                                            cts.I
                                            nat.nat)) =>
                                   logic.eq
                                     (cts.univ cts.star cts.box cts.I)
                                     (logic.eq nat.nat m m)
                                     (logic.eq
                                        nat.nat
                                        (nat.minus __ (nat.times nat.O n))
                                        m))
                                  (logic.rewrite_l
                                     nat.nat
                                     (nat.plus m (nat.times m n))
                                     (__:(cts.Term
                                            cts.diamond
                                            (cts.cast
                                               cts.triangle
                                               cts.sinf
                                               (cts.univ cts.box cts.triangle cts.I)
                                               (cts.univ cts.diamond cts.sinf cts.I)
                                               cts.I
                                               nat.nat)) =>
                                      logic.eq
                                        (cts.univ cts.star cts.box cts.I)
                                        (logic.eq nat.nat m m)
                                        (logic.eq
                                           nat.nat
                                           (nat.minus __ (nat.times nat.O n))
                                           m))
                                     (logic.rewrite_l
                                        nat.nat
                                        n
                                        (__:(cts.Term
                                               cts.diamond
                                               (cts.cast
                                                  cts.triangle
                                                  cts.sinf
                                                  (cts.univ
                                                     cts.box
                                                     cts.triangle
                                                     cts.I)
                                                  (cts.univ
                                                     cts.diamond
                                                     cts.sinf
                                                     cts.I)
                                                  cts.I
                                                  nat.nat)) =>
                                         logic.eq
                                           (cts.univ cts.star cts.box cts.I)
                                           (logic.eq nat.nat m m)
                                           (logic.eq
                                              nat.nat
                                              (nat.minus
                                                 (nat.plus m __)
                                                 (nat.times nat.O n))
                                              m))
                                        (logic.rewrite_l
                                           nat.nat
                                           m
                                           (__:(cts.Term
                                                  cts.diamond
                                                  (cts.cast
                                                     cts.triangle
                                                     cts.sinf
                                                     (cts.univ
                                                        cts.box
                                                        cts.triangle
                                                        cts.I)
                                                     (cts.univ
                                                        cts.diamond
                                                        cts.sinf
                                                        cts.I)
                                                     cts.I
                                                     nat.nat)) =>
                                            logic.eq
                                              (cts.univ cts.star cts.box cts.I)
                                              (logic.eq nat.nat m m)
                                              (logic.eq
                                                 nat.nat
                                                 (nat.minus __ (nat.times nat.O n))
                                                 m))
                                           (logic.rewrite_r
                                              nat.nat
                                              n
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq
                                                 (cts.univ cts.star cts.box cts.I)
                                                 (logic.eq nat.nat m m)
                                                 (logic.eq
                                                    nat.nat
                                                    (nat.minus m (nat.times __ n))
                                                    m))
                                              (logic.rewrite_l
                                                 nat.nat
                                                 n
                                                 (__:(cts.Term
                                                        cts.diamond
                                                        (cts.cast
                                                           cts.triangle
                                                           cts.sinf
                                                           (cts.univ
                                                              cts.box
                                                              cts.triangle
                                                              cts.I)
                                                           (cts.univ
                                                              cts.diamond
                                                              cts.sinf
                                                              cts.I)
                                                           cts.I
                                                           nat.nat)) =>
                                                  logic.eq
                                                    (cts.univ cts.star cts.box cts.I)
                                                    (logic.eq nat.nat m m)
                                                    (logic.eq
                                                       nat.nat
                                                       (nat.minus m __)
                                                       m))
                                                 (logic.rewrite_l
                                                    nat.nat
                                                    m
                                                    (__:(cts.Term
                                                           cts.diamond
                                                           (cts.cast
                                                              cts.triangle
                                                              cts.sinf
                                                              (cts.univ
                                                                 cts.box
                                                                 cts.triangle
                                                                 cts.I)
                                                              (cts.univ
                                                                 cts.diamond
                                                                 cts.sinf
                                                                 cts.I)
                                                              cts.I
                                                              nat.nat)) =>
                                                     logic.eq
                                                       (cts.univ
                                                          cts.star
                                                          cts.box
                                                          cts.I)
                                                       (logic.eq nat.nat m m)
                                                       (logic.eq nat.nat __ m))
                                                    (logic.refl
                                                       (cts.univ
                                                          cts.star
                                                          cts.box
                                                          cts.I)
                                                       (logic.eq nat.nat m m))
                                                    (nat.minus m n)
                                                    (let_clause_15491 m n eqn0 m))
                                                 (nat.times n n)
                                                 (let_clause_1551 m n eqn0 n))
                                              nat.O
                                              eqn0)
                                           (nat.plus m n)
                                           (logic.rewrite_l
                                              nat.nat
                                              nat.O
                                              (__:(cts.Term
                                                     cts.diamond
                                                     (cts.cast
                                                        cts.triangle
                                                        cts.sinf
                                                        (cts.univ
                                                           cts.box
                                                           cts.triangle
                                                           cts.I)
                                                        (cts.univ
                                                           cts.diamond
                                                           cts.sinf
                                                           cts.I)
                                                        cts.I
                                                        nat.nat)) =>
                                               logic.eq nat.nat m (nat.plus m __))
                                              (nat.plus_n_O m)
                                              n
                                              eqn0))
                                        (nat.times m n)
                                        (let_clause_1551 m n eqn0 m))
                                     (nat.times m (nat.S n))
                                     (nat.times_n_Sm m n))
                                  (nat.times (nat.S n) m)
                                  (nat.commutative_times (nat.S n) m))
                               nat.O
                               eqn0)
                            (nat.minus m n)
                            (let_clause_15491 m n eqn0 m))
                         nat.O
                         eqn0)
                      (gcd n m)
                      (logic.rewrite_l
                         nat.nat
                         nat.O
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq nat.nat (gcd __ m) m)
                         (gcd_O_l m)
                         n
                         eqn0))))))
       nat.O
       eqn0)
    (nat.le_to_or_lt_eq nat.O n (nat.le_O_n n)).

def let_clause_1545 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat.nat (gcd x x0) nat.O)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (primes.divides nat.O x0)
                (x2 =>
                 cts.prod
                   cts.box
                   cts.star
                   cts.star
                   cts.I
                   nat.nat
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat x0 (nat.times nat.O x3))
                      (x4 =>
                       cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (primes.divides nat.O x)
                         (x5 =>
                          cts.prod
                            cts.box
                            cts.star
                            cts.star
                            cts.I
                            nat.nat
                            (x6 =>
                             cts.prod
                               cts.star
                               cts.star
                               cts.star
                               cts.I
                               (logic.eq nat.nat x (nat.times nat.O x6))
                               (x7 => logic.eq nat.nat x nat.O))))))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  H:(cts.Term cts.star (logic.eq nat.nat (gcd m n) nat.O)) =>
  _clearme:(cts.Term cts.star (primes.divides nat.O n)) =>
  q1:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat.nat)) =>
  H1:(cts.Term cts.star (logic.eq nat.nat n (nat.times nat.O q1))) =>
  _clearme0:(cts.Term cts.star (primes.divides nat.O m)) =>
  q2:(cts.Term
        cts.diamond
        (cts.cast
           cts.triangle
           cts.sinf
           (cts.univ cts.box cts.triangle cts.I)
           (cts.univ cts.diamond cts.sinf cts.I)
           cts.I
           nat.nat)) =>
  H2:(cts.Term cts.star (logic.eq nat.nat m (nat.times nat.O q2))) =>
  logic.rewrite_r
    nat.nat
    (nat.times q2 nat.O)
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat m __)
    (logic.rewrite_l
       nat.nat
       (nat.times nat.O q2)
       (__:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        logic.eq nat.nat m __)
       H2
       (nat.times q2 nat.O)
       (nat.commutative_times nat.O q2))
    nat.O
    (nat.times_n_O q2).

def gcd_O_to_eq_O :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (logic.eq nat.nat (gcd x x0) nat.O)
             (x1 => connectives.And (logic.eq nat.nat x nat.O) (logic.eq nat.nat x0 nat.O)))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  H:(cts.Term cts.star (logic.eq nat.nat (gcd m n) nat.O)) =>
  connectives.match_And_prop
    (primes.divides nat.O n)
    (primes.divides nat.O m)
    (connectives.And (logic.eq nat.nat m nat.O) (logic.eq nat.nat n nat.O))
    (_clearme:(cts.Term cts.star (primes.divides nat.O n)) =>
     primes.match_divides_prop
       nat.O
       n
       (cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (primes.divides nat.O m)
          (x => connectives.And (logic.eq nat.nat m nat.O) (logic.eq nat.nat n nat.O)))
       (q1:(cts.Term
              cts.diamond
              (cts.cast
                 cts.triangle
                 cts.sinf
                 (cts.univ cts.box cts.triangle cts.I)
                 (cts.univ cts.diamond cts.sinf cts.I)
                 cts.I
                 nat.nat)) =>
        H1:(cts.Term cts.star (logic.eq nat.nat n (nat.times nat.O q1))) =>
        _clearme0:(cts.Term cts.star (primes.divides nat.O m)) =>
        primes.match_divides_prop
          nat.O
          m
          (connectives.And (logic.eq nat.nat m nat.O) (logic.eq nat.nat n nat.O))
          (q2:(cts.Term
                 cts.diamond
                 (cts.cast
                    cts.triangle
                    cts.sinf
                    (cts.univ cts.box cts.triangle cts.I)
                    (cts.univ cts.diamond cts.sinf cts.I)
                    cts.I
                    nat.nat)) =>
           H2:(cts.Term cts.star (logic.eq nat.nat m (nat.times nat.O q2))) =>
           connectives.conj
             (logic.eq nat.nat m nat.O)
             (logic.eq nat.nat n nat.O)
             (logic.rewrite_l
                nat.nat
                m
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                 logic.eq nat.nat m __)
                (logic.refl nat.nat m)
                nat.O
                (logic.rewrite_r
                   nat.nat
                   (nat.times q2 nat.O)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq nat.nat m __)
                   (logic.rewrite_l
                      nat.nat
                      (nat.times nat.O q2)
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq nat.nat m __)
                      H2
                      (nat.times q2 nat.O)
                      (nat.commutative_times nat.O q2))
                   nat.O
                   (nat.times_n_O q2)))
             (logic.rewrite_r
                nat.nat
                m
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                 logic.eq nat.nat __ nat.O)
                (logic.rewrite_l
                   nat.nat
                   m
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq nat.nat m __)
                   (logic.refl nat.nat m)
                   nat.O
                   (let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 H2))
                n
                (logic.rewrite_r
                   nat.nat
                   (nat.times m q1)
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq nat.nat n __)
                   (logic.rewrite_r
                      nat.nat
                      nat.O
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq nat.nat n (nat.times __ q1))
                      H1
                      m
                      (let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 H2))
                   m
                   (logic.rewrite_r
                      nat.nat
                      nat.O
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq nat.nat m (nat.times __ q1))
                      (logic.rewrite_r
                         nat.nat
                         nat.O
                         (__:(cts.Term
                                cts.diamond
                                (cts.cast
                                   cts.triangle
                                   cts.sinf
                                   (cts.univ cts.box cts.triangle cts.I)
                                   (cts.univ cts.diamond cts.sinf cts.I)
                                   cts.I
                                   nat.nat)) =>
                          logic.eq nat.nat __ (nat.times nat.O q1))
                         (nat.times_O_n q1)
                         m
                         (let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 H2))
                      m
                      (let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 H2)))))
          _clearme0)
       _clearme)
    (logic.eq_ind
       nat.nat
       (gcd m n)
       (x_1:(cts.Term
               cts.diamond
               (cts.cast
                  cts.triangle
                  cts.sinf
                  (cts.univ cts.box cts.triangle cts.I)
                  (cts.univ cts.diamond cts.sinf cts.I)
                  cts.I
                  nat.nat)) =>
        connectives.And (primes.divides x_1 n) (primes.divides x_1 m))
       (divides_gcd_nm m n)
       nat.O
       H).

def let_clause_1571 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O x0)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (gcd x x0) nat.O)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat.nat x nat.O)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat x0 nat.O)
                      (x4 => logic.eq nat.nat x x0)))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  H:(cts.Term cts.star (logic.eq nat.nat (gcd m n) nat.O)) =>
  auto:(cts.Term cts.star (logic.eq nat.nat m nat.O)) =>
  auto':(cts.Term cts.star (logic.eq nat.nat n nat.O)) =>
  logic.rewrite_r
    nat.nat
    nat.O
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat m __)
    auto
    n
    auto'.

def let_clause_1572 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O x0)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (logic.eq nat.nat (gcd x x0) nat.O)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (logic.eq nat.nat x nat.O)
                   (x3 =>
                    cts.prod
                      cts.star
                      cts.star
                      cts.star
                      cts.I
                      (logic.eq nat.nat x0 nat.O)
                      (x4 => logic.eq nat.nat x nat.O)))))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  H:(cts.Term cts.star (logic.eq nat.nat (gcd m n) nat.O)) =>
  auto:(cts.Term cts.star (logic.eq nat.nat m nat.O)) =>
  auto':(cts.Term cts.star (logic.eq nat.nat n nat.O)) =>
  logic.rewrite_r
    nat.nat
    n
    (__:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     logic.eq nat.nat __ nat.O)
    auto'
    m
    (let_clause_1571 m n posn H auto auto').

def lt_O_gcd :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt nat.O x0)
             (x1 => nat.lt nat.O (gcd x x0)))))
  :=
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  posn:(cts.Term cts.star (nat.lt nat.O n)) =>
  nat.nat_case
    (gcd m n)
    (nat.lt nat.O)
    (H:(cts.Term cts.star (logic.eq nat.nat (gcd m n) nat.O)) =>
     connectives.match_And_prop
       (logic.eq nat.nat m nat.O)
       (logic.eq nat.nat n nat.O)
       (nat.lt nat.O nat.O)
       (auto:(cts.Term cts.star (logic.eq nat.nat m nat.O)) =>
        auto':(cts.Term cts.star (logic.eq nat.nat n nat.O)) =>
        logic.eq_coerc
          (nat.lt nat.O n)
          (nat.lt nat.O nat.O)
          posn
          (logic.rewrite_l
             nat.nat
             m
             (__:(cts.Term
                    cts.diamond
                    (cts.cast
                       cts.triangle
                       cts.sinf
                       (cts.univ cts.box cts.triangle cts.I)
                       (cts.univ cts.diamond cts.sinf cts.I)
                       cts.I
                       nat.nat)) =>
              logic.eq (cts.univ cts.star cts.box cts.I) (nat.lt __ n) (nat.lt nat.O nat.O))
             (logic.rewrite_l
                nat.nat
                m
                (__:(cts.Term
                       cts.diamond
                       (cts.cast
                          cts.triangle
                          cts.sinf
                          (cts.univ cts.box cts.triangle cts.I)
                          (cts.univ cts.diamond cts.sinf cts.I)
                          cts.I
                          nat.nat)) =>
                 logic.eq (cts.univ cts.star cts.box cts.I) (nat.lt m __) (nat.lt nat.O nat.O))
                (logic.rewrite_l
                   nat.nat
                   m
                   (__:(cts.Term
                          cts.diamond
                          (cts.cast
                             cts.triangle
                             cts.sinf
                             (cts.univ cts.box cts.triangle cts.I)
                             (cts.univ cts.diamond cts.sinf cts.I)
                             cts.I
                             nat.nat)) =>
                    logic.eq (cts.univ cts.star cts.box cts.I) (nat.lt m m) (nat.lt __ nat.O))
                   (logic.rewrite_l
                      nat.nat
                      m
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq (cts.univ cts.star cts.box cts.I) (nat.lt m m) (nat.lt m __))
                      (logic.refl (cts.univ cts.star cts.box cts.I) (nat.lt m m))
                      nat.O
                      (let_clause_1572 m n posn H auto auto'))
                   nat.O
                   (let_clause_1572 m n posn H auto auto'))
                n
                (let_clause_1571 m n posn H auto auto'))
             nat.O
             (let_clause_1572 m n posn H auto auto')))
       (gcd_O_to_eq_O m n H))
    (m0:(cts.Term
           cts.diamond
           (cts.cast
              cts.triangle
              cts.sinf
              (cts.univ cts.box cts.triangle cts.I)
              (cts.univ cts.diamond cts.sinf cts.I)
              cts.I
              nat.nat)) =>
     auto:(cts.Term cts.star (logic.eq nat.nat (gcd m n) (nat.S m0))) => nat.lt_O_S m0).

def prime_to_gcd_1 :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (primes.prime x)
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (connectives.Not (primes.divides x x0))
                (x2 => logic.eq nat.nat (gcd x x0) (nat.S nat.O))))))
  :=
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  _clearme:(cts.Term cts.star (primes.prime n)) =>
  connectives.match_And_prop
    (nat.lt (nat.S nat.O) n)
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (primes.divides x n)
          (x0 =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (nat.lt (nat.S nat.O) x)
             (x1 => logic.eq nat.nat x n))))
    (cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (connectives.Not (primes.divides n m))
       (x => logic.eq nat.nat (gcd n m) (nat.S nat.O)))
    (lt1n:(cts.Term cts.star (nat.lt (nat.S nat.O) n)) =>
     primen:(cts.Term
               cts.star
               (cts.prod
                  cts.box
                  cts.star
                  cts.star
                  cts.I
                  nat.nat
                  (x =>
                   cts.prod
                     cts.star
                     cts.star
                     cts.star
                     cts.I
                     (primes.divides x n)
                     (x0 =>
                      cts.prod
                        cts.star
                        cts.star
                        cts.star
                        cts.I
                        (nat.lt (nat.S nat.O) x)
                        (x1 => logic.eq nat.nat x n))))) =>
     ndivnm:(cts.Term cts.star (connectives.Not (primes.divides n m))) =>
     nat.le_to_le_to_eq
       (gcd n m)
       (nat.S nat.O)
       (nat.not_lt_to_le
          (nat.S nat.O)
          (gcd n m)
          (logic.not_to_not
             (nat.lt (nat.S nat.O) (gcd n m))
             (logic.eq nat.nat (gcd n m) n)
             (primen (gcd n m) (divides_gcd_l n m))
             (logic.not_to_not
                (logic.eq nat.nat (gcd n m) n)
                (primes.divides n m)
                (auto:(cts.Term cts.star (logic.eq nat.nat (gcd n m) n)) =>
                 logic.eq_coerc
                   (primes.divides (gcd n m) m)
                   (primes.divides n m)
                   (divides_gcd_r n m)
                   (logic.rewrite_r
                      nat.nat
                      n
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq
                         (cts.univ cts.star cts.box cts.I)
                         (primes.divides __ m)
                         (primes.divides n m))
                      (logic.refl (cts.univ cts.star cts.box cts.I) (primes.divides n m))
                      (gcd n m)
                      auto))
                ndivnm)))
       (lt_O_gcd
          n
          m
          (nat.not_eq_to_le_to_lt
             nat.O
             m
             (logic.not_to_not
                (logic.eq nat.nat nat.O m)
                (primes.divides n m)
                (auto:(cts.Term cts.star (logic.eq nat.nat nat.O m)) =>
                 logic.eq_coerc
                   (primes.divides n nat.O)
                   (primes.divides n m)
                   (primes.divides_n_O n)
                   (logic.rewrite_r
                      nat.nat
                      m
                      (__:(cts.Term
                             cts.diamond
                             (cts.cast
                                cts.triangle
                                cts.sinf
                                (cts.univ cts.box cts.triangle cts.I)
                                (cts.univ cts.diamond cts.sinf cts.I)
                                cts.I
                                nat.nat)) =>
                       logic.eq
                         (cts.univ cts.star cts.box cts.I)
                         (primes.divides n __)
                         (primes.divides n m))
                      (logic.refl (cts.univ cts.star cts.box cts.I) (primes.divides n m))
                      nat.O
                      auto))
                ndivnm)
             (nat.le_O_n m))))
    _clearme.

def divides_times_to_divides :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.box
          cts.star
          cts.star
          cts.I
          nat.nat
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (primes.prime x)
                (x2 =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (primes.divides x (nat.times x0 x1))
                   (x3 => connectives.Or (primes.divides x x0) (primes.divides x x1)))))))
  :=
  p:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  n:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  m:(cts.Term
       cts.diamond
       (cts.cast
          cts.triangle
          cts.sinf
          (cts.univ cts.box cts.triangle cts.I)
          (cts.univ cts.diamond cts.sinf cts.I)
          cts.I
          nat.nat)) =>
  primp:(cts.Term cts.star (primes.prime p)) =>
  _clearme:(cts.Term cts.star (primes.divides p (nat.times n m))) =>
  primes.match_divides_prop
    p
    (nat.times n m)
    (connectives.Or (primes.divides p n) (primes.divides p m))
    (c:(cts.Term
          cts.diamond
          (cts.cast
             cts.triangle
             cts.sinf
             (cts.univ cts.box cts.triangle cts.I)
             (cts.univ cts.diamond cts.sinf cts.I)
             cts.I
             nat.nat)) =>
     nm:(cts.Term cts.star (logic.eq nat.nat (nat.times n m) (nat.times p c))) =>
     connectives.match_Or_prop
       (primes.divides p n)
       (connectives.Not (primes.divides p n))
       (connectives.Or (primes.divides p n) (primes.divides p m))
       (auto:(cts.Term cts.star (primes.divides p n)) =>
        connectives.or_introl (primes.divides p n) (primes.divides p m) auto)
       (ndivpn:(cts.Term cts.star (connectives.Not (primes.divides p n))) =>
        connectives.or_intror
          (primes.divides p n)
          (primes.divides p m)
          (connectives.match_ex_prop
             nat.nat
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              connectives.ex
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O))
                   (logic.eq nat.nat (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O))))
             (primes.divides p m)
             (a:(cts.Term
                   cts.diamond
                   (cts.cast
                      cts.triangle
                      cts.sinf
                      (cts.univ cts.box cts.triangle cts.I)
                      (cts.univ cts.diamond cts.sinf cts.I)
                      cts.I
                      nat.nat)) =>
              _clearme0:(cts.Term
                           cts.star
                           (connectives.ex
                              nat.nat
                              (b:(cts.Term
                                    cts.diamond
                                    (cts.cast
                                       cts.triangle
                                       cts.sinf
                                       (cts.univ cts.box cts.triangle cts.I)
                                       (cts.univ cts.diamond cts.sinf cts.I)
                                       cts.I
                                       nat.nat)) =>
                               connectives.Or
                                 (logic.eq
                                    nat.nat
                                    (nat.minus (nat.times a n) (nat.times b p))
                                    (nat.S nat.O))
                                 (logic.eq
                                    nat.nat
                                    (nat.minus (nat.times b p) (nat.times a n))
                                    (nat.S nat.O))))) =>
              connectives.match_ex_prop
                nat.nat
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O))
                   (logic.eq nat.nat (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O)))
                (primes.divides p m)
                (b:(cts.Term
                      cts.diamond
                      (cts.cast
                         cts.triangle
                         cts.sinf
                         (cts.univ cts.box cts.triangle cts.I)
                         (cts.univ cts.diamond cts.sinf cts.I)
                         cts.I
                         nat.nat)) =>
                 _clearme1:(cts.Term
                              cts.star
                              (connectives.Or
                                 (logic.eq
                                    nat.nat
                                    (nat.minus (nat.times a n) (nat.times b p))
                                    (nat.S nat.O))
                                 (logic.eq
                                    nat.nat
                                    (nat.minus (nat.times b p) (nat.times a n))
                                    (nat.S nat.O)))) =>
                 connectives.match_Or_prop
                   (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b p)) (nat.S nat.O))
                   (logic.eq nat.nat (nat.minus (nat.times b p) (nat.times a n)) (nat.S nat.O))
                   (primes.divides p m)
                   (H:(cts.Term
                         cts.star
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times a n) (nat.times b p))
                            (nat.S nat.O))) =>
                    primes.quotient
                      p
                      m
                      (nat.minus (nat.times a c) (nat.times b m))
                      (logic.eq_ind_r
                         nat.nat
                         (nat.minus
                            (nat.times p (nat.times a c))
                            (nat.times p (nat.times b m)))
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat m x)
                         (logic.eq_ind
                            nat.nat
                            (nat.times (nat.times p a) c)
                            (x_1:(cts.Term
                                    cts.diamond
                                    (cts.cast
                                       cts.triangle
                                       cts.sinf
                                       (cts.univ cts.box cts.triangle cts.I)
                                       (cts.univ cts.diamond cts.sinf cts.I)
                                       cts.I
                                       nat.nat)) =>
                             logic.eq nat.nat m (nat.minus x_1 (nat.times p (nat.times b m))))
                            (logic.eq_ind_r
                               nat.nat
                               (nat.times a p)
                               (x:(cts.Term
                                     cts.diamond
                                     (cts.cast
                                        cts.triangle
                                        cts.sinf
                                        (cts.univ cts.box cts.triangle cts.I)
                                        (cts.univ cts.diamond cts.sinf cts.I)
                                        cts.I
                                        nat.nat)) =>
                                logic.eq
                                  nat.nat
                                  m
                                  (nat.minus (nat.times x c) (nat.times p (nat.times b m))))
                               (logic.eq_ind_r
                                  nat.nat
                                  (nat.times a (nat.times p c))
                                  (x:(cts.Term
                                        cts.diamond
                                        (cts.cast
                                           cts.triangle
                                           cts.sinf
                                           (cts.univ cts.box cts.triangle cts.I)
                                           (cts.univ cts.diamond cts.sinf cts.I)
                                           cts.I
                                           nat.nat)) =>
                                   logic.eq
                                     nat.nat
                                     m
                                     (nat.minus x (nat.times p (nat.times b m))))
                                  (logic.eq_ind
                                     nat.nat
                                     (nat.times n m)
                                     (x_1:(cts.Term
                                             cts.diamond
                                             (cts.cast
                                                cts.triangle
                                                cts.sinf
                                                (cts.univ cts.box cts.triangle cts.I)
                                                (cts.univ cts.diamond cts.sinf cts.I)
                                                cts.I
                                                nat.nat)) =>
                                      logic.eq
                                        nat.nat
                                        m
                                        (nat.minus
                                           (nat.times a x_1)
                                           (nat.times p (nat.times b m))))
                                     (logic.eq_ind
                                        nat.nat
                                        (nat.times (nat.times a n) m)
                                        (x_1:(cts.Term
                                                cts.diamond
                                                (cts.cast
                                                   cts.triangle
                                                   cts.sinf
                                                   (cts.univ
                                                      cts.box
                                                      cts.triangle
                                                      cts.I)
                                                   (cts.univ
                                                      cts.diamond
                                                      cts.sinf
                                                      cts.I)
                                                   cts.I
                                                   nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           m
                                           (nat.minus x_1 (nat.times p (nat.times b m))))
                                        (logic.eq_ind
                                           nat.nat
                                           (nat.times (nat.times p b) m)
                                           (x_1:(cts.Term
                                                   cts.diamond
                                                   (cts.cast
                                                      cts.triangle
                                                      cts.sinf
                                                      (cts.univ
                                                         cts.box
                                                         cts.triangle
                                                         cts.I)
                                                      (cts.univ
                                                         cts.diamond
                                                         cts.sinf
                                                         cts.I)
                                                      cts.I
                                                      nat.nat)) =>
                                            logic.eq
                                              nat.nat
                                              m
                                              (nat.minus
                                                 (nat.times (nat.times a n) m)
                                                 x_1))
                                           (logic.eq_ind
                                              nat.nat
                                              (nat.times m (nat.times a n))
                                              (x_1:(cts.Term
                                                      cts.diamond
                                                      (cts.cast
                                                         cts.triangle
                                                         cts.sinf
                                                         (cts.univ
                                                            cts.box
                                                            cts.triangle
                                                            cts.I)
                                                         (cts.univ
                                                            cts.diamond
                                                            cts.sinf
                                                            cts.I)
                                                         cts.I
                                                         nat.nat)) =>
                                               logic.eq
                                                 nat.nat
                                                 m
                                                 (nat.minus
                                                    x_1
                                                    (nat.times (nat.times p b) m)))
                                              (logic.eq_ind_r
                                                 nat.nat
                                                 (nat.times m (nat.times p b))
                                                 (x:(cts.Term
                                                       cts.diamond
                                                       (cts.cast
                                                          cts.triangle
                                                          cts.sinf
                                                          (cts.univ
                                                             cts.box
                                                             cts.triangle
                                                             cts.I)
                                                          (cts.univ
                                                             cts.diamond
                                                             cts.sinf
                                                             cts.I)
                                                          cts.I
                                                          nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    m
                                                    (nat.minus
                                                       (nat.times m (nat.times a n))
                                                       x))
                                                 (logic.eq_ind
                                                    nat.nat
                                                    (nat.times
                                                       m
                                                       (nat.minus
                                                          (nat.times a n)
                                                          (nat.times p b)))
                                                    (x_1:(cts.Term
                                                            cts.diamond
                                                            (cts.cast
                                                               cts.triangle
                                                               cts.sinf
                                                               (cts.univ
                                                                  cts.box
                                                                  cts.triangle
                                                                  cts.I)
                                                               (cts.univ
                                                                  cts.diamond
                                                                  cts.sinf
                                                                  cts.I)
                                                               cts.I
                                                               nat.nat)) =>
                                                     logic.eq nat.nat m x_1)
                                                    (logic.rewrite_r
                                                       nat.nat
                                                       (nat.times n a)
                                                       (__:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat.nat)) =>
                                                        logic.eq
                                                          nat.nat
                                                          m
                                                          (nat.times
                                                             m
                                                             (nat.minus
                                                                __
                                                                (nat.times p b))))
                                                       (logic.rewrite_l
                                                          nat.nat
                                                          m
                                                          (__:(cts.Term
                                                                 cts.diamond
                                                                 (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (
                                                                    cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (
                                                                    cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                           logic.eq nat.nat m __)
                                                          (logic.refl nat.nat m)
                                                          (nat.times
                                                             m
                                                             (nat.minus
                                                                (nat.times n a)
                                                                (nat.times p b)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.S nat.O)
                                                             (__:(cts.Term
                                                                    cts.diamond
                                                                    (
                                                                    cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                m
                                                                (nat.times m __))
                                                             (nat.times_n_1 m)
                                                             (nat.minus
                                                                (nat.times n a)
                                                                (nat.times p b))
                                                             (logic.rewrite_l
                                                                nat.nat
                                                                (nat.times b p)
                                                                (__:(
                                                                 cts.Term
                                                                   cts.diamond
                                                                   (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    a)
                                                                    __)
                                                                   (nat.S nat.O))
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   (nat.times
                                                                    a
                                                                    n)
                                                                   (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    b
                                                                    p))
                                                                    (nat.S
                                                                    nat.O))
                                                                   H
                                                                   (nat.times
                                                                    n
                                                                    a)
                                                                   (nat.commutative_times
                                                                    a
                                                                    n))
                                                                (nat.times p b)
                                                                (nat.commutative_times
                                                                   b
                                                                   p))))
                                                       (nat.times a n)
                                                       (nat.commutative_times a n))
                                                    (nat.minus
                                                       (nat.times m (nat.times a n))
                                                       (nat.times m (nat.times p b)))
                                                    (nat.distributive_times_minus
                                                       m
                                                       (nat.times a n)
                                                       (nat.times p b)))
                                                 (nat.times (nat.times p b) m)
                                                 (nat.commutative_times
                                                    (nat.times p b)
                                                    m))
                                              (nat.times (nat.times a n) m)
                                              (nat.commutative_times m (nat.times a n)))
                                           (nat.times p (nat.times b m))
                                           (nat.associative_times p b m))
                                        (nat.times a (nat.times n m))
                                        (nat.associative_times a n m))
                                     (nat.times p c)
                                     nm)
                                  (nat.times (nat.times a p) c)
                                  (nat.associative_times a p c))
                               (nat.times p a)
                               (nat.commutative_times p a))
                            (nat.times p (nat.times a c))
                            (nat.associative_times p a c))
                         (nat.times p (nat.minus (nat.times a c) (nat.times b m)))
                         (nat.distributive_times_minus p (nat.times a c) (nat.times b m))))
                   (H:(cts.Term
                         cts.star
                         (logic.eq
                            nat.nat
                            (nat.minus (nat.times b p) (nat.times a n))
                            (nat.S nat.O))) =>
                    primes.quotient
                      p
                      m
                      (nat.minus (nat.times b m) (nat.times a c))
                      (logic.eq_ind_r
                         nat.nat
                         (nat.minus
                            (nat.times p (nat.times b m))
                            (nat.times p (nat.times a c)))
                         (x:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          logic.eq nat.nat m x)
                         (logic.eq_ind
                            nat.nat
                            (nat.times (nat.times p b) m)
                            (x_1:(cts.Term
                                    cts.diamond
                                    (cts.cast
                                       cts.triangle
                                       cts.sinf
                                       (cts.univ cts.box cts.triangle cts.I)
                                       (cts.univ cts.diamond cts.sinf cts.I)
                                       cts.I
                                       nat.nat)) =>
                             logic.eq nat.nat m (nat.minus x_1 (nat.times p (nat.times a c))))
                            (logic.eq_ind
                               nat.nat
                               (nat.times (nat.times p a) c)
                               (x_1:(cts.Term
                                       cts.diamond
                                       (cts.cast
                                          cts.triangle
                                          cts.sinf
                                          (cts.univ cts.box cts.triangle cts.I)
                                          (cts.univ cts.diamond cts.sinf cts.I)
                                          cts.I
                                          nat.nat)) =>
                                logic.eq
                                  nat.nat
                                  m
                                  (nat.minus (nat.times (nat.times p b) m) x_1))
                               (logic.eq_ind
                                  nat.nat
                                  (nat.times a p)
                                  (x_1:(cts.Term
                                          cts.diamond
                                          (cts.cast
                                             cts.triangle
                                             cts.sinf
                                             (cts.univ cts.box cts.triangle cts.I)
                                             (cts.univ cts.diamond cts.sinf cts.I)
                                             cts.I
                                             nat.nat)) =>
                                   logic.eq
                                     nat.nat
                                     m
                                     (nat.minus
                                        (nat.times (nat.times p b) m)
                                        (nat.times x_1 c)))
                                  (logic.eq_ind_r
                                     nat.nat
                                     (nat.times a (nat.times p c))
                                     (x:(cts.Term
                                           cts.diamond
                                           (cts.cast
                                              cts.triangle
                                              cts.sinf
                                              (cts.univ cts.box cts.triangle cts.I)
                                              (cts.univ cts.diamond cts.sinf cts.I)
                                              cts.I
                                              nat.nat)) =>
                                      logic.eq
                                        nat.nat
                                        m
                                        (nat.minus (nat.times (nat.times p b) m) x))
                                     (logic.eq_ind
                                        nat.nat
                                        (nat.times n m)
                                        (x_1:(cts.Term
                                                cts.diamond
                                                (cts.cast
                                                   cts.triangle
                                                   cts.sinf
                                                   (cts.univ
                                                      cts.box
                                                      cts.triangle
                                                      cts.I)
                                                   (cts.univ
                                                      cts.diamond
                                                      cts.sinf
                                                      cts.I)
                                                   cts.I
                                                   nat.nat)) =>
                                         logic.eq
                                           nat.nat
                                           m
                                           (nat.minus
                                              (nat.times (nat.times p b) m)
                                              (nat.times a x_1)))
                                        (logic.eq_ind
                                           nat.nat
                                           (nat.times (nat.times a n) m)
                                           (x_1:(cts.Term
                                                   cts.diamond
                                                   (cts.cast
                                                      cts.triangle
                                                      cts.sinf
                                                      (cts.univ
                                                         cts.box
                                                         cts.triangle
                                                         cts.I)
                                                      (cts.univ
                                                         cts.diamond
                                                         cts.sinf
                                                         cts.I)
                                                      cts.I
                                                      nat.nat)) =>
                                            logic.eq
                                              nat.nat
                                              m
                                              (nat.minus
                                                 (nat.times (nat.times p b) m)
                                                 x_1))
                                           (logic.eq_ind
                                              nat.nat
                                              (nat.times m (nat.times p b))
                                              (x_1:(cts.Term
                                                      cts.diamond
                                                      (cts.cast
                                                         cts.triangle
                                                         cts.sinf
                                                         (cts.univ
                                                            cts.box
                                                            cts.triangle
                                                            cts.I)
                                                         (cts.univ
                                                            cts.diamond
                                                            cts.sinf
                                                            cts.I)
                                                         cts.I
                                                         nat.nat)) =>
                                               logic.eq
                                                 nat.nat
                                                 m
                                                 (nat.minus
                                                    x_1
                                                    (nat.times (nat.times a n) m)))
                                              (logic.eq_ind_r
                                                 nat.nat
                                                 (nat.times m (nat.times a n))
                                                 (x:(cts.Term
                                                       cts.diamond
                                                       (cts.cast
                                                          cts.triangle
                                                          cts.sinf
                                                          (cts.univ
                                                             cts.box
                                                             cts.triangle
                                                             cts.I)
                                                          (cts.univ
                                                             cts.diamond
                                                             cts.sinf
                                                             cts.I)
                                                          cts.I
                                                          nat.nat)) =>
                                                  logic.eq
                                                    nat.nat
                                                    m
                                                    (nat.minus
                                                       (nat.times m (nat.times p b))
                                                       x))
                                                 (logic.eq_ind
                                                    nat.nat
                                                    (nat.times
                                                       m
                                                       (nat.minus
                                                          (nat.times p b)
                                                          (nat.times a n)))
                                                    (x_1:(cts.Term
                                                            cts.diamond
                                                            (cts.cast
                                                               cts.triangle
                                                               cts.sinf
                                                               (cts.univ
                                                                  cts.box
                                                                  cts.triangle
                                                                  cts.I)
                                                               (cts.univ
                                                                  cts.diamond
                                                                  cts.sinf
                                                                  cts.I)
                                                               cts.I
                                                               nat.nat)) =>
                                                     logic.eq nat.nat m x_1)
                                                    (logic.rewrite_r
                                                       nat.nat
                                                       (nat.times n a)
                                                       (__:(cts.Term
                                                              cts.diamond
                                                              (cts.cast
                                                                 cts.triangle
                                                                 cts.sinf
                                                                 (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                 (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                 cts.I
                                                                 nat.nat)) =>
                                                        logic.eq
                                                          nat.nat
                                                          m
                                                          (nat.times
                                                             m
                                                             (nat.minus
                                                                (nat.times p b)
                                                                __)))
                                                       (logic.rewrite_l
                                                          nat.nat
                                                          m
                                                          (__:(cts.Term
                                                                 cts.diamond
                                                                 (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (
                                                                    cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (
                                                                    cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                           logic.eq nat.nat m __)
                                                          (logic.refl nat.nat m)
                                                          (nat.times
                                                             m
                                                             (nat.minus
                                                                (nat.times p b)
                                                                (nat.times n a)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.S nat.O)
                                                             (__:(cts.Term
                                                                    cts.diamond
                                                                    (
                                                                    cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                m
                                                                (nat.times m __))
                                                             (nat.times_n_1 m)
                                                             (nat.minus
                                                                (nat.times p b)
                                                                (nat.times n a))
                                                             (logic.rewrite_l
                                                                nat.nat
                                                                (nat.times a n)
                                                                (__:(
                                                                 cts.Term
                                                                   cts.diamond
                                                                   (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.times
                                                                    p
                                                                    b)
                                                                    __)
                                                                   (nat.S nat.O))
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   (nat.times
                                                                    b
                                                                    p)
                                                                   (__:(
                                                                    cts.Term
                                                                    cts.diamond
                                                                    (cts.cast
                                                                    cts.triangle
                                                                    cts.sinf
                                                                    (cts.univ
                                                                    cts.box
                                                                    cts.triangle
                                                                    cts.I)
                                                                    (cts.univ
                                                                    cts.diamond
                                                                    cts.sinf
                                                                    cts.I)
                                                                    cts.I
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    n))
                                                                    (nat.S
                                                                    nat.O))
                                                                   H
                                                                   (nat.times
                                                                    p
                                                                    b)
                                                                   (nat.commutative_times
                                                                    b
                                                                    p))
                                                                (nat.times n a)
                                                                (nat.commutative_times
                                                                   a
                                                                   n))))
                                                       (nat.times a n)
                                                       (nat.commutative_times a n))
                                                    (nat.minus
                                                       (nat.times m (nat.times p b))
                                                       (nat.times m (nat.times a n)))
                                                    (nat.distributive_times_minus
                                                       m
                                                       (nat.times p b)
                                                       (nat.times a n)))
                                                 (nat.times (nat.times a n) m)
                                                 (nat.commutative_times
                                                    (nat.times a n)
                                                    m))
                                              (nat.times (nat.times p b) m)
                                              (nat.commutative_times m (nat.times p b)))
                                           (nat.times a (nat.times n m))
                                           (nat.associative_times a n m))
                                        (nat.times p c)
                                        nm)
                                     (nat.times (nat.times a p) c)
                                     (nat.associative_times a p c))
                                  (nat.times p a)
                                  (nat.commutative_times a p))
                               (nat.times p (nat.times a c))
                               (nat.associative_times p a c))
                            (nat.times p (nat.times b m))
                            (nat.associative_times p b m))
                         (nat.times p (nat.minus (nat.times b m) (nat.times a c)))
                         (nat.distributive_times_minus p (nat.times b m) (nat.times a c))))
                   _clearme1)
                _clearme0)
             (logic.eq_ind
                nat.nat
                (gcd p n)
                (x_1:(cts.Term
                        cts.diamond
                        (cts.cast
                           cts.triangle
                           cts.sinf
                           (cts.univ cts.box cts.triangle cts.I)
                           (cts.univ cts.diamond cts.sinf cts.I)
                           cts.I
                           nat.nat)) =>
                 connectives.ex
                   nat.nat
                   (a:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    connectives.ex
                      nat.nat
                      (b:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b p)) x_1)
                         (logic.eq nat.nat (nat.minus (nat.times b p) (nat.times a n)) x_1))))
                (logic.eq_ind_r
                   nat.nat
                   (gcd n p)
                   (x:(cts.Term
                         cts.diamond
                         (cts.cast
                            cts.triangle
                            cts.sinf
                            (cts.univ cts.box cts.triangle cts.I)
                            (cts.univ cts.diamond cts.sinf cts.I)
                            cts.I
                            nat.nat)) =>
                    connectives.ex
                      nat.nat
                      (a:(cts.Term
                            cts.diamond
                            (cts.cast
                               cts.triangle
                               cts.sinf
                               (cts.univ cts.box cts.triangle cts.I)
                               (cts.univ cts.diamond cts.sinf cts.I)
                               cts.I
                               nat.nat)) =>
                       connectives.ex
                         nat.nat
                         (b:(cts.Term
                               cts.diamond
                               (cts.cast
                                  cts.triangle
                                  cts.sinf
                                  (cts.univ cts.box cts.triangle cts.I)
                                  (cts.univ cts.diamond cts.sinf cts.I)
                                  cts.I
                                  nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b p)) x)
                            (logic.eq nat.nat (nat.minus (nat.times b p) (nat.times a n)) x))))
                   (eq_minus_gcd p n)
                   (gcd p n)
                   (commutative_gcd p n))
                (nat.S nat.O)
                (prime_to_gcd_1 p n primp ndivpn))))
       (primes.decidable_divides p n))
    _clearme.

