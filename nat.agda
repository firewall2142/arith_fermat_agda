module nat where
open import Agda.Primitive
open import bool
open import connectives
open import leibniz
open import logic
open import relations
data nat : Set where
  O : nat
  S : nat -> nat
postulate match::nat::prop : {i : Level} → forall (return : (nat -> Set i)) -> (return O) -> (forall (n : nat) -> return (S n)) -> forall (z : nat) -> return z
postulate match::nat::type : {i : Level} → (return : Set i) -> return -> (nat -> return) -> nat -> return
postulate axiom::match::nat::type::O : {i : Level} → (return::type : Set i) -> forall (case::O : return::type) -> forall (case::S : (nat -> return::type)) -> connectives.equal (return::type) (match::nat::type (return::type) case::O case::S O) case::O

eq::match::nat::type::O : {i j : Level} (return::type : Set i) (case::O : return::type) (case::S : nat → return::type) (P : return::type → Set j) → P (match::nat::type return::type case::O case::S O) → P case::O
eq::match::nat::type::O {i} {j} = \(return::type : Set i) -> \(case::O : return::type) -> \(case::S : nat -> return::type) -> ((((connectives.equal::leibniz) {_} {j} (return::type)) (match::nat::type (return::type) case::O case::S O)) (case::O)) ((((axiom::match::nat::type::O) (return::type)) (case::O)) (case::S))

sym::eq::match::nat::type::O : {i j : Level} → _
sym::eq::match::nat::type::O {i} {j} = \(return::type : Set i) -> \(case::O : return::type) -> \(case::S : nat -> return::type) -> ((((leibniz.sym::leibniz) {_} {j} (return::type)) (match::nat::type (return::type) case::O case::S O)) (case::O)) ((((eq::match::nat::type::O) (return::type)) (case::O)) (case::S))

postulate axiom::match::nat::type::S : {i : Level} → (return::type : Set i) -> forall (case::O : return::type) -> forall (case::S : (nat -> return::type)) -> forall (n : nat) -> connectives.equal (return::type) (match::nat::type (return::type) case::O case::S (S n)) (case::S n)
eq::match::nat::type::S : {i j : Level} →  _
eq::match::nat::type::S {i} {j} = \(return::type : Set i) -> \(case::O : return::type) -> \(case::S : nat -> return::type) -> \(n : nat) -> ((((connectives.equal::leibniz) {_} {j} (return::type)) (match::nat::type (return::type) case::O case::S (S n))) (case::S n)) (((((axiom::match::nat::type::S) (return::type)) (case::O)) (case::S)) (n))

sym::eq::match::nat::type::S : {i j : Level} → _
sym::eq::match::nat::type::S {i} {j} = \(return::type : Set i) -> \(case::O : return::type) -> \(case::S : nat -> return::type) -> \(n : nat) -> ((((leibniz.sym::leibniz) {_} {j} (return::type)) (match::nat::type (return::type) case::O case::S (S n))) (case::S n)) (((((eq::match::nat::type::S) (return::type)) (case::O)) (case::S)) (n))

postulate filter::nat::type : (return : Set) -> (nat -> return) -> nat -> return
postulate axiom::filter::nat::type::O : (return::type : Set) -> forall (return : (nat -> return::type)) -> connectives.equal (return::type) (filter::nat::type (return::type) return O) (return O)
eq::filter::nat::type::O : {j : Level} →  _
eq::filter::nat::type::O {j} = \(return::type : Set) -> \(return : nat -> return::type) -> ((((connectives.equal::leibniz) {lzero} {j} (return::type)) (filter::nat::type (return::type) return O)) (return O)) (((axiom::filter::nat::type::O) (return::type)) (return))

sym::eq::filter::nat::type::O : {j : Level} →  _
sym::eq::filter::nat::type::O {j} = \(return::type : Set) -> \(return : nat -> return::type) -> ((((leibniz.sym::leibniz) {_} {j} (return::type)) (filter::nat::type (return::type) return O)) (return O)) (((eq::filter::nat::type::O) (return::type)) (return))

postulate axiom::filter::nat::type::S : (return::type : Set) -> forall (return : (nat -> return::type)) -> forall (n : nat) -> connectives.equal (return::type) (filter::nat::type (return::type) return (S n)) (return (S n))
eq::filter::nat::type::S : {j : Level} →  _
eq::filter::nat::type::S {j} = \(return::type : Set) -> \(return : nat -> return::type) -> \(n : nat) -> ((((connectives.equal::leibniz) {_} {j} (return::type)) (filter::nat::type (return::type) return (S n))) (return (S n))) ((((axiom::filter::nat::type::S) (return::type)) (return)) (n))

sym::eq::filter::nat::type::S : {j : Level} →  _
sym::eq::filter::nat::type::S {j} = \(return::type : Set) -> \(return : nat -> return::type) -> \(n : nat) -> ((((leibniz.sym::leibniz) {_} {j} (return::type)) (filter::nat::type (return::type) return (S n))) (return (S n))) ((((eq::filter::nat::type::S) (return::type)) (return)) (n))

postulate nat::ind : {i : Level} → forall (Q : (nat -> Set i)) -> (Q O) -> (forall (x : nat) -> (Q x) -> Q (S x)) -> forall (x : nat) -> Q x
pred : _
pred = \(n : nat) -> match::nat::type (nat) O (\(p : nat) -> p) n

not::zero : _
not::zero = \(n : nat) -> match::nat::type _ connectives.False (\(p : nat) -> connectives.True) n

postulate le : nat -> nat -> Set
postulate le::n : forall (n : nat) -> le n n
postulate le::S : forall (n : nat) -> forall (m : nat) -> (le n m) -> le n (S m)
postulate match::le::prop : forall (n : nat) -> forall (return : (nat -> Set)) -> (return n) -> (forall (m : nat) -> return (S m)) -> forall (m : nat) -> (le n m) -> return m
postulate le::ind : forall (n : nat) -> forall (Q : (nat -> Set)) -> (Q n) -> (forall (m : nat) -> (le n m) -> (Q m) -> Q (S m)) -> forall (m : nat) -> (le n m) -> Q m
lt : _
lt = \(n : nat) -> \(m : nat) -> le (S n) m

postulate plus : nat -> nat -> nat
postulate plus::body : nat -> nat -> nat
postulate axiom::plus : forall (n : nat) -> connectives.equal (nat -> nat) (plus n) (filter::nat::type (nat -> nat) plus::body n)
eq::plus : {j : Level} →  _
eq::plus {j} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {j} (nat -> nat)) (plus n)) (filter::nat::type (nat -> nat) plus::body n)) ((axiom::plus) (n))

sym::eq::plus : {i : Level} →  _
sym::eq::plus {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (plus n)) (filter::nat::type (nat -> nat) plus::body n)) ((eq::plus) (n))

postulate axiom::plus::body::O : connectives.equal (nat -> nat) (plus::body O) (\(m : nat) -> m)
eq::plus::body::O : {i : Level} →  _
eq::plus::body::O {i} = ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (plus::body O)) (\(m : nat) -> m)) (axiom::plus::body::O)

sym::eq::plus::body::O : {i : Level} →  _
sym::eq::plus::body::O {i} = ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (plus::body O)) (\(m : nat) -> m)) (eq::plus::body::O)

postulate axiom::plus::body::S : forall (n : nat) -> connectives.equal (nat -> nat) (plus::body (S n)) (\(m : nat) -> S (plus n m))
eq::plus::body::S : {i : Level} →  _
eq::plus::body::S {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (plus::body (S n))) (\(m : nat) -> S (plus n m))) ((axiom::plus::body::S) (n))

sym::eq::plus::body::S : {i : Level} →  _
sym::eq::plus::body::S {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (plus::body (S n))) (\(m : nat) -> S (plus n m))) ((eq::plus::body::S) (n))

postulate times : nat -> nat -> nat
postulate times::body : nat -> nat -> nat
postulate axiom::times : forall (n : nat) -> connectives.equal (nat -> nat) (times n) (filter::nat::type (nat -> nat) times::body n)
eq::times : {i : Level} →  _
eq::times {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (times n)) (filter::nat::type (nat -> nat) times::body n)) ((axiom::times) (n))

sym::eq::times : {i : Level} →  _
sym::eq::times {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (times n)) (filter::nat::type (nat -> nat) times::body n)) ((eq::times) (n))

postulate axiom::times::body::O : connectives.equal (nat -> nat) (times::body O) (\(m : nat) -> O)
eq::times::body::O : {i : Level} →  _
eq::times::body::O {i} = ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (times::body O)) (\(m : nat) -> O)) (axiom::times::body::O)

sym::eq::times::body::O : {i : Level} →  _
sym::eq::times::body::O {i} = ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (times::body O)) (\(m : nat) -> O)) (eq::times::body::O)

postulate axiom::times::body::S : forall (n : nat) -> connectives.equal (nat -> nat) (times::body (S n)) (\(m : nat) -> plus m (times n m))
eq::times::body::S : {i : Level} →  _
eq::times::body::S {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (times::body (S n))) (\(m : nat) -> plus m (times n m))) ((axiom::times::body::S) (n))

sym::eq::times::body::S : {i : Level} →  _
sym::eq::times::body::S {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (times::body (S n))) (\(m : nat) -> plus m (times n m))) ((eq::times::body::S) (n))

postulate minus : nat -> nat -> nat
postulate minus::body : nat -> nat -> nat
postulate axiom::minus : forall (n : nat) -> connectives.equal (nat -> nat) (minus n) (filter::nat::type (nat -> nat) minus::body n)
eq::minus : {i : Level} →  _
eq::minus {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (minus n)) (filter::nat::type (nat -> nat) minus::body n)) ((axiom::minus) (n))

sym::eq::minus : {i : Level} →  _
sym::eq::minus {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (minus n)) (filter::nat::type (nat -> nat) minus::body n)) ((eq::minus) (n))

postulate axiom::minus::body::O : connectives.equal (nat -> nat) (minus::body O) (\(m : nat) -> O)
eq::minus::body::O : {i : Level} →  _
eq::minus::body::O {i} = ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (minus::body O)) (\(m : nat) -> O)) (axiom::minus::body::O)

sym::eq::minus::body::O : {i : Level} →  _
sym::eq::minus::body::O {i} = ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (minus::body O)) (\(m : nat) -> O)) (eq::minus::body::O)

postulate axiom::minus::body::S : forall (n : nat) -> connectives.equal (nat -> nat) (minus::body (S n)) (\(m : nat) -> match::nat::type (nat) (S n) (\(q : nat) -> minus n q) m)
eq::minus::body::S : {i : Level} →  _
eq::minus::body::S {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> nat)) (minus::body (S n))) (\(m : nat) -> match::nat::type (nat) (S n) (\(q : nat) -> minus n q) m)) ((axiom::minus::body::S) (n))

sym::eq::minus::body::S : {i : Level} →  _
sym::eq::minus::body::S {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> nat)) (minus::body (S n))) (\(m : nat) -> match::nat::type (nat) (S n) (\(q : nat) -> minus n q) m)) ((eq::minus::body::S) (n))

nat::case : _
nat::case = \(n : nat) -> \(P : nat -> Set) -> ((((nat::ind) (\(::x::365 : nat) -> ((logic.eq (nat) ::x::365 O) -> P O) -> (forall (m : nat) -> (logic.eq (nat) ::x::365 (S m)) -> P (S m)) -> P ::x::365)) (\(auto : (logic.eq (nat) O O) -> P O) -> (\(auto' : forall (m : nat) -> (logic.eq (nat) O (S m)) -> P (S m)) -> ((auto) (((logic.refl) (nat)) (O)))))) (\(x::366 : nat) -> \(::x::368 : ((logic.eq (nat) x::366 O) -> P O) -> (forall (m : nat) -> (logic.eq (nat) x::366 (S m)) -> P (S m)) -> P x::366) -> (\(auto : (logic.eq (nat) (S x::366) O) -> P O) -> (\(auto' : forall (m : nat) -> (logic.eq (nat) (S x::366) (S m)) -> P (S m)) -> (((auto') (x::366)) (((logic.refl) (nat)) (S x::366))))))) (n)

nat::elim2 : {i : Level} → _
nat::elim2 {i} = \(R : nat -> nat -> Set i) -> \(ROn : forall (n : nat) -> R O n) -> (\(RSO : forall (n : nat) -> R (S n) O) -> (\(RSS : forall (n : nat) -> forall (m : nat) -> (R n m) -> R (S n) (S m)) -> (\(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (m : nat) -> R ::x::365 m)) (\(m : nat) -> (ROn) (m))) (\(n0 : nat) -> \(Rn0m : forall (m : nat) -> R n0 m) -> (\(m : nat) -> ((((match::nat::prop) (\(:::: : nat) -> R (S n0) ::::)) ((RSO) (n0))) (\(auto : nat) -> (((RSS) (n0)) (auto)) ((Rn0m) (auto)))) (m)))) (n))))

le::gen : _
le::gen = \(P : nat -> Set) -> \(n : nat) -> \(auto : forall (i : nat) -> (le i n) -> P i) -> (((auto) (n)) ((le::n) (n)))

pred::Sn : _
pred::Sn = \(n : nat) -> ((((((sym::eq::match::nat::type::S) (nat)) (O)) (\(p : nat) -> p)) (n)) (\(y : nat) -> logic.eq (nat) n y)) (((logic.refl) (nat)) (n))

injective::S : _
injective::S = \(x : nat) -> \(y : nat) -> \(auto : logic.eq (nat) (S x) (S y)) -> (((((((logic.rewrite::l) (nat)) (y)) (\(:::: : nat) -> logic.eq (nat) :::: y)) (((logic.refl) (nat)) (y))) (x)) (((((((logic.rewrite::r) (nat)) (pred (S x))) (\(:::: : nat) -> logic.eq (nat) y ::::)) (((((((logic.rewrite::r) (nat)) (S y)) (\(:::: : nat) -> logic.eq (nat) y (pred ::::))) ((pred::Sn) (y))) (S x)) (auto))) (x)) ((pred::Sn) (x))))

S::pred : _
S::pred = \(n : nat) -> \(posn : lt O n) -> (((((((match::le::prop) (S O)) (\(:::: : nat) -> logic.eq (nat) (S (pred ::::)) ::::)) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) (S ::::) (S O))) (((logic.refl) (nat)) (S O))) (pred (S O))) ((pred::Sn) (O)))) (\(m : nat) -> ((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (nat) (S ::::) (S m))) (((logic.refl) (nat)) (S m))) (pred (S m))) ((pred::Sn) (m)))) (n)) (posn))

plus::O::n : _
plus::O::n = \(n : nat) -> (((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) n (y n))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) n (y n))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) n (y n))) (((logic.refl) (nat)) (n))))

plus::n::O : _
plus::n::O = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> logic.eq (nat) ::x::365 (plus ::x::365 O))) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) O (y O))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) O (y O))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) O (y O))) (((logic.refl) (nat)) (O)))))) (\(x::366 : nat) -> \(::x::368 : logic.eq (nat) x::366 (plus x::366 O)) -> ((((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S x::366) (y O))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S x::366) (y O))) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S x::366) (y O))) (((((((logic.rewrite::l) (nat)) (x::366)) (\(:::: : nat) -> logic.eq (nat) (S x::366) (S ::::))) (((logic.refl) (nat)) (S x::366))) (plus x::366 O)) (::x::368))))))) (n)

plus::n::Sm : _
plus::n::Sm = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (m : nat) -> logic.eq (nat) (S (plus ::x::365 m)) (plus ::x::365 (S m)))) (\(m : nat) -> (((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (y m)) (plus O (S m)))) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (filter::nat::type (nat -> nat) plus::body O m)) (y (S m)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (filter::nat::type (nat -> nat) plus::body O m)) (y (S m)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (y m)) (plus::body O (S m)))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) (S (y m)) (plus::body O (S m)))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) (S m) (y (S m)))) (((logic.refl) (nat)) (S m))))))))) (\(x::366 : nat) -> \(::x::368 : forall (m : nat) -> logic.eq (nat) (S (plus x::366 m)) (plus x::366 (S m))) -> (\(m : nat) -> (((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (y m)) (plus (S x::366) (S m)))) ((((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (filter::nat::type (nat -> nat) plus::body (S x::366) m)) (y (S m)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (filter::nat::type (nat -> nat) plus::body (S x::366) m)) (y (S m)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (y m)) (plus::body (S x::366) (S m)))) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (y m)) (plus::body (S x::366) (S m)))) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (S (plus x::366 m))) (y (S m)))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S m))) (\(:::: : nat) -> logic.eq (nat) (S ::::) (S (plus x::366 (S m))))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S (S m)))) (\(:::: : nat) -> logic.eq (nat) :::: (S (plus x::366 (S m))))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S (S m)))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (S (S m))) ::::)) (((logic.refl) (nat)) (plus x::366 (S (S m))))) (S (plus x::366 (S m)))) ((::x::368) (S m)))) (S (plus x::366 (S m)))) ((::x::368) (S m)))) (S (plus x::366 m))) ((::x::368) (m))))))))))) (n)

commutative::plus : _
commutative::plus = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (y : nat) -> logic.eq (nat) (plus ::x::365 y) (plus y ::x::365))) (\(y : nat) -> (((sym::eq::plus) (O)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (plus y O))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (plus y O))) (((sym::eq::plus::body::O) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (plus y O))) (((((((logic.rewrite::l) (nat)) (y)) (\(:::: : nat) -> logic.eq (nat) y ::::)) (((logic.refl) (nat)) (y))) (plus y O)) ((plus::n::O) (y))))))) (\(x::366 : nat) -> \(::x::368 : forall (y : nat) -> logic.eq (nat) (plus x::366 y) (plus y x::366)) -> (\(y : nat) -> (((sym::eq::plus) (S x::366)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (plus y (S x::366)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (plus y (S x::366)))) ((((sym::eq::plus::body::S) (x::366)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (plus y (S x::366)))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S y))) (\(:::: : nat) -> logic.eq (nat) :::: (plus y (S x::366)))) (((((((logic.rewrite::r) (nat)) (plus y (S x::366))) (\(:::: : nat) -> logic.eq (nat) :::: (plus y (S x::366)))) (((logic.refl) (nat)) (plus y (S x::366)))) (plus x::366 (S y))) (((((((logic.rewrite::l) (nat)) (S (plus x::366 y))) (\(:::: : nat) -> logic.eq (nat) :::: (plus y (S x::366)))) (((((((logic.rewrite::r) (nat)) (plus y x::366)) (\(:::: : nat) -> logic.eq (nat) (S ::::) (plus y (S x::366)))) (((plus::n::Sm) (y)) (x::366))) (plus x::366 y)) ((::x::368) (y)))) (plus x::366 (S y))) (((plus::n::Sm) (x::366)) (y))))) (S (plus x::366 y))) (((plus::n::Sm) (x::366)) (y)))))))) (n)

associative::plus : _
associative::plus = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (plus (plus ::x::365 y) z) (plus ::x::365 (plus y z)))) (\(y : nat) -> \(z : nat) -> (((sym::eq::plus) (O)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (plus O y) z) (x (plus y z)))) ((((sym::eq::plus) (O)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (x y) z) (filter::nat::type (nat -> nat) plus::body O (plus y z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (x y) z) (filter::nat::type (nat -> nat) plus::body O (plus y z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (plus::body O y) z) (x (plus y z)))) (((sym::eq::plus::body::O) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (plus::body O y) z) (x (plus y z)))) (((sym::eq::plus::body::O) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (x y) z) (plus y z))) (((logic.refl) (nat)) (plus y z))))))))) (\(x::366 : nat) -> \(::x::368 : forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (plus (plus x::366 y) z) (plus x::366 (plus y z))) -> (\(y : nat) -> \(z : nat) -> (((sym::eq::plus) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (plus (S x::366) y) z) (x (plus y z)))) ((((sym::eq::plus) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (x y) z) (filter::nat::type (nat -> nat) plus::body (S x::366) (plus y z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (x y) z) (filter::nat::type (nat -> nat) plus::body (S x::366) (plus y z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (plus::body (S x::366) y) z) (x (plus y z)))) ((((sym::eq::plus::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (plus::body (S x::366) y) z) (x (plus y z)))) ((((sym::eq::plus::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (plus (x y) z) (S (plus x::366 (plus y z))))) ((((sym::eq::plus) (S (plus x::366 y))) (\(x : (nat -> nat)) -> logic.eq (nat) (x z) (S (plus x::366 (plus y z))))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (plus x::366 y)) (\(x : (nat -> nat)) -> logic.eq (nat) (x z) (S (plus x::366 (plus y z))))) ((((sym::eq::plus::body::S) (plus x::366 y)) (\(x : (nat -> nat)) -> logic.eq (nat) (x z) (S (plus x::366 (plus y z))))) (((((((logic.rewrite::r) (nat)) (plus x::366 (plus y z))) (\(:::: : nat) -> logic.eq (nat) (S ::::) (S (plus x::366 (plus y z))))) (((logic.refl) (nat)) (S (plus x::366 (plus y z))))) (plus (plus x::366 y) z)) (((::x::368) (y)) (z)))))))))))))) (n)

assoc::plus1 : _
assoc::plus1 = \(a : nat) -> \(b : nat) -> \(c : nat) -> ((((((logic.rewrite::r) (nat)) (plus a b)) (\(:::: : nat) -> logic.eq (nat) (plus c ::::) (plus (plus b c) a))) (((((((logic.rewrite::r) (nat)) (plus a (plus b c))) (\(:::: : nat) -> logic.eq (nat) (plus c (plus a b)) ::::)) (((((((logic.rewrite::r) (nat)) (plus a (plus b c))) (\(:::: : nat) -> logic.eq (nat) :::: (plus a (plus b c)))) (((logic.refl) (nat)) (plus a (plus b c)))) (plus c (plus a b))) (((((((logic.rewrite::l) (nat)) (plus (plus a b) c)) (\(:::: : nat) -> logic.eq (nat) (plus c (plus a b)) ::::)) (((commutative::plus) (c)) (plus a b))) (plus a (plus b c))) ((((associative::plus) (a)) (b)) (c))))) (plus (plus b c) a)) (((commutative::plus) (plus b c)) (a)))) (plus b a)) (((commutative::plus) (b)) (a))

injective::plus::r : _
injective::plus::r = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> relations.injective:: (nat) (nat) (\(m : nat) -> plus ::x::365 m))) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> relations.injective:: (nat) (nat) (\(m : nat) -> y m))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> relations.injective:: (nat) (nat) (\(m : nat) -> y m))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> relations.injective:: (nat) (nat) (\(m : nat) -> y m))) (\(x : nat) -> \(y : nat) -> \(auto : logic.eq (nat) x y) -> (((((((logic.rewrite::l) (nat)) (x)) (\(:::: : nat) -> logic.eq (nat) x ::::)) (((logic.refl) (nat)) (x))) (y)) (auto))))))) (\(x::366 : nat) -> \(::x::368 : forall (x : nat) -> forall (y : nat) -> (logic.eq (nat) (plus x::366 x) (plus x::366 y)) -> logic.eq (nat) x y) -> ((((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> relations.injective:: (nat) (nat) (\(m : nat) -> y m))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> relations.injective:: (nat) (nat) (\(m : nat) -> y m))) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> relations.injective:: (nat) (nat) (\(m : nat) -> y m))) (\(x : nat) -> \(y : nat) -> \(auto : logic.eq (nat) (S (plus x::366 x)) (S (plus x::366 y))) -> ((((::x::368) (x)) (y)) ((((injective::S) (plus x::366 x)) (plus x::366 y)) (((((((logic.rewrite::r) (nat)) (plus x::366 (S x))) (\(:::: : nat) -> logic.eq (nat) :::: (S (plus x::366 y)))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S y))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (S x)) ::::)) (((((((logic.rewrite::l) (nat)) (plus x::366 (S x))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (S x)) ::::)) (((logic.refl) (nat)) (plus x::366 (S x)))) (plus x::366 (S y))) (((((((logic.rewrite::l) (nat)) (S (plus x::366 y))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (S x)) ::::)) (((((((logic.rewrite::l) (nat)) (S (plus x::366 x))) (\(:::: : nat) -> logic.eq (nat) :::: (S (plus x::366 y)))) (auto)) (plus x::366 (S x))) (((plus::n::Sm) (x::366)) (x)))) (plus x::366 (S y))) (((plus::n::Sm) (x::366)) (y))))) (S (plus x::366 y))) (((plus::n::Sm) (x::366)) (y)))) (S (plus x::366 x))) (((plus::n::Sm) (x::366)) (x))))))))))) (n)

times::Sn::m : _
times::Sn::m = \(n : nat) -> \(m : nat) -> (((sym::eq::times) (S n)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus m (times n m)) (y m))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus m (times n m)) (y m))) ((((sym::eq::times::body::S) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus m (times n m)) (y m))) (((logic.refl) (nat)) (plus m (times n m)))))

times::O::n : _
times::O::n = \(n : nat) -> (((sym::eq::times) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) O (y n))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(y : (nat -> nat)) -> logic.eq (nat) O (y n))) (((sym::eq::times::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) O (y n))) (((logic.refl) (nat)) (O))))

times::n::O : _
times::n::O = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> logic.eq (nat) O (times ::x::365 O))) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((logic.refl) (nat)) (O))) (times O O)) ((times::O::n) (O)))) (\(x::366 : nat) -> \(::x::368 : logic.eq (nat) O (times x::366 O)) -> (((((((logic.rewrite::l) (nat)) (plus O (times x::366 O))) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O (plus O ::::))) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((logic.refl) (nat)) (O))) (plus O O)) ((plus::O::n) (O)))) (times x::366 O)) (::x::368))) (times (S x::366) O)) (((times::Sn::m) (x::366)) (O))))) (n)

times::n::Sm : _
times::n::Sm = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (m : nat) -> logic.eq (nat) (plus ::x::365 (times ::x::365 m)) (times ::x::365 (S m)))) ((((sym::eq::times) (O)) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (plus O (times O m)) (y (S m)))) ((((sym::eq::times) (O)) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (plus O (y m)) (filter::nat::type (nat -> nat) times::body O (S m)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (plus O (y m)) (filter::nat::type (nat -> nat) times::body O (S m)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (plus O (times::body O m)) (y (S m)))) (((sym::eq::times::body::O) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (plus O (times::body O m)) (y (S m)))) (((sym::eq::times::body::O) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (plus O (y m)) O)) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (y O) O)) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (y O) O)) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> forall (m : nat) -> logic.eq (nat) (y O) O)) (\(::m : nat) -> ((logic.refl) (nat)) (O)))))))))))) (\(x::366 : nat) -> \(::x::368 : forall (m : nat) -> logic.eq (nat) (plus x::366 (times x::366 m)) (times x::366 (S m))) -> (\(m : nat) -> (((sym::eq::times) (S x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus (S x::366) (times (S x::366) m)) (y (S m)))) ((((sym::eq::times) (S x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus (S x::366) (y m)) (filter::nat::type (nat -> nat) times::body (S x::366) (S m)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus (S x::366) (y m)) (filter::nat::type (nat -> nat) times::body (S x::366) (S m)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus (S x::366) (times::body (S x::366) m)) (y (S m)))) ((((sym::eq::times::body::S) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus (S x::366) (times::body (S x::366) m)) (y (S m)))) ((((sym::eq::times::body::S) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (plus (S x::366) (y m)) (plus (S m) (times x::366 (S m))))) ((((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (plus m (times x::366 m))) (plus (S m) (times x::366 (S m))))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (plus m (times x::366 m))) (plus (S m) (times x::366 (S m))))) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (plus m (times x::366 m))) (plus (S m) (times x::366 (S m))))) ((((sym::eq::plus) (S m)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (plus x::366 (plus m (times x::366 m)))) (y (times x::366 (S m))))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (m)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (plus x::366 (plus m (times x::366 m)))) (y (times x::366 (S m))))) ((((sym::eq::plus::body::S) (m)) (\(y : (nat -> nat)) -> logic.eq (nat) (S (plus x::366 (plus m (times x::366 m)))) (y (times x::366 (S m))))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S (plus m (times x::366 m))))) (\(:::: : nat) -> logic.eq (nat) :::: (S (plus m (times x::366 (S m)))))) (((((((logic.rewrite::r) (nat)) (plus m (S (times x::366 m)))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 ::::) (S (plus m (times x::366 (S m)))))) (((((((logic.rewrite::l) (nat)) (plus x::366 (times x::366 m))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (plus m (S (times x::366 m)))) (S (plus m ::::)))) (((((((logic.rewrite::r) (nat)) (plus x::366 (plus m (times x::366 m)))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (plus m (S (times x::366 m)))) (S ::::))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S (plus m (times x::366 m))))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (plus m (S (times x::366 m)))) ::::)) (((((((logic.rewrite::r) (nat)) (plus m (S (times x::366 m)))) (\(:::: : nat) -> logic.eq (nat) (plus x::366 (plus m (S (times x::366 m)))) (plus x::366 ::::))) (((logic.refl) (nat)) (plus x::366 (plus m (S (times x::366 m)))))) (S (plus m (times x::366 m)))) (((plus::n::Sm) (m)) (times x::366 m)))) (S (plus x::366 (plus m (times x::366 m))))) (((plus::n::Sm) (x::366)) (plus m (times x::366 m))))) (plus m (plus x::366 (times x::366 m)))) (((((((logic.rewrite::l) (nat)) (plus (plus x::366 m) (times x::366 m))) (\(:::: : nat) -> logic.eq (nat) (plus m (plus x::366 (times x::366 m))) ::::)) ((((assoc::plus1) (times x::366 m)) (x::366)) (m))) (plus x::366 (plus m (times x::366 m)))) ((((associative::plus) (x::366)) (m)) (times x::366 m))))) (times x::366 (S m))) ((::x::368) (m)))) (S (plus m (times x::366 m)))) (((plus::n::Sm) (m)) (times x::366 m)))) (S (plus x::366 (plus m (times x::366 m))))) (((plus::n::Sm) (x::366)) (plus m (times x::366 m)))))))))))))))))) (n)

commutative::times : _
commutative::times = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (y : nat) -> logic.eq (nat) (times ::x::365 y) (times y ::x::365))) ((((sym::eq::times) (O)) (\(y : (nat -> nat)) -> forall (z : nat) -> logic.eq (nat) (y z) (times z O))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(y : (nat -> nat)) -> forall (z : nat) -> logic.eq (nat) (y z) (times z O))) (((sym::eq::times::body::O) (\(y : (nat -> nat)) -> forall (z : nat) -> logic.eq (nat) (y z) (times z O))) (\(y : nat) -> ((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((logic.refl) (nat)) (O))) (times y O)) ((times::n::O) (y))))))) (\(x::366 : nat) -> \(::x::368 : forall (y : nat) -> logic.eq (nat) (times x::366 y) (times y x::366)) -> (\(y : nat) -> (((sym::eq::times) (S x::366)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (times y (S x::366)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (times y (S x::366)))) ((((sym::eq::times::body::S) (x::366)) (\(z : (nat -> nat)) -> logic.eq (nat) (z y) (times y (S x::366)))) (((((((logic.rewrite::l) (nat)) (plus y (times y x::366))) (\(:::: : nat) -> logic.eq (nat) (plus y (times x::366 y)) ::::)) (((((((logic.rewrite::l) (nat)) (times x::366 y)) (\(:::: : nat) -> logic.eq (nat) (plus y (times x::366 y)) (plus y ::::))) (((logic.refl) (nat)) (plus y (times x::366 y)))) (times y x::366)) ((::x::368) (y)))) (times y (S x::366))) (((times::n::Sm) (y)) (x::366)))))))) (n)

distributive::times::plus : _
distributive::times::plus = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times ::x::365 (plus y z)) (plus (times ::x::365 y) (times ::x::365 z)))) ((((sym::eq::times) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times O (plus y z)) (plus (times O y) (x z)))) ((((sym::eq::times) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times O (plus y z)) (plus (x y) (filter::nat::type (nat -> nat) times::body O z)))) ((((sym::eq::times) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (x (plus y z)) (plus (filter::nat::type (nat -> nat) times::body O y) (filter::nat::type (nat -> nat) times::body O z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (x (plus y z)) (plus (filter::nat::type (nat -> nat) times::body O y) (filter::nat::type (nat -> nat) times::body O z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times::body O (plus y z)) (plus (x y) (filter::nat::type (nat -> nat) times::body O z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times::body O (plus y z)) (plus (times::body O y) (x z)))) (((sym::eq::times::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times::body O (plus y z)) (plus (times::body O y) (x z)))) (((sym::eq::times::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times::body O (plus y z)) (plus (x y) O))) (((sym::eq::times::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (x (plus y z)) (plus O O))) ((((sym::eq::plus) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) O (x O))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) O (x O))) (((sym::eq::plus::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) O (x O))) (\(::y : nat) -> \(::z : nat) -> ((logic.refl) (nat)) (O))))))))))))))) (\(x::366 : nat) -> \(::x::368 : forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times x::366 (plus y z)) (plus (times x::366 y) (times x::366 z))) -> (\(y : nat) -> \(z : nat) -> (((sym::eq::times) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (S x::366) (plus y z)) (plus (times (S x::366) y) (x z)))) ((((sym::eq::times) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (S x::366) (plus y z)) (plus (x y) (filter::nat::type (nat -> nat) times::body (S x::366) z)))) ((((sym::eq::times) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (x (plus y z)) (plus (filter::nat::type (nat -> nat) times::body (S x::366) y) (filter::nat::type (nat -> nat) times::body (S x::366) z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (x (plus y z)) (plus (filter::nat::type (nat -> nat) times::body (S x::366) y) (filter::nat::type (nat -> nat) times::body (S x::366) z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times::body (S x::366) (plus y z)) (plus (x y) (filter::nat::type (nat -> nat) times::body (S x::366) z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times::body (S x::366) (plus y z)) (plus (times::body (S x::366) y) (x z)))) ((((sym::eq::times::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times::body (S x::366) (plus y z)) (plus (times::body (S x::366) y) (x z)))) ((((sym::eq::times::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times::body (S x::366) (plus y z)) (plus (x y) (plus z (times x::366 z))))) ((((sym::eq::times::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (x (plus y z)) (plus (plus y (times x::366 y)) (plus z (times x::366 z))))) (((((((logic.rewrite::r) (nat)) (plus y (plus z (times x::366 (plus y z))))) (\(:::: : nat) -> logic.eq (nat) :::: (plus (plus y (times x::366 y)) (plus z (times x::366 z))))) (((((((logic.rewrite::r) (nat)) (plus y (plus (times x::366 y) (plus z (times x::366 z))))) (\(:::: : nat) -> logic.eq (nat) (plus y (plus z (times x::366 (plus y z)))) ::::)) (((((((logic.rewrite::r) (nat)) (plus z (plus (times x::366 y) (times x::366 z)))) (\(:::: : nat) -> logic.eq (nat) (plus y (plus z (times x::366 (plus y z)))) (plus y ::::))) (((((((logic.rewrite::l) (nat)) (times x::366 (plus y z))) (\(:::: : nat) -> logic.eq (nat) (plus y (plus z (times x::366 (plus y z)))) (plus y (plus z ::::)))) (((logic.refl) (nat)) (plus y (plus z (times x::366 (plus y z)))))) (plus (times x::366 y) (times x::366 z))) (((::x::368) (y)) (z)))) (plus (times x::366 y) (plus z (times x::366 z)))) (((((((logic.rewrite::l) (nat)) (plus (plus z (times x::366 y)) (times x::366 z))) (\(:::: : nat) -> logic.eq (nat) (plus (times x::366 y) (plus z (times x::366 z))) ::::)) ((((assoc::plus1) (times x::366 z)) (z)) (times x::366 y))) (plus z (plus (times x::366 y) (times x::366 z)))) ((((associative::plus) (z)) (times x::366 y)) (times x::366 z))))) (plus (plus y (times x::366 y)) (plus z (times x::366 z)))) ((((associative::plus) (y)) (times x::366 y)) (plus z (times x::366 z))))) (plus (plus y z) (times x::366 (plus y z)))) ((((associative::plus) (y)) (z)) (times x::366 (plus y z))))))))))))))) (n)

distributive::times::plus::r : _
distributive::times::plus::r = \(a : nat) -> \(b : nat) -> \(c : nat) -> ((((((logic.rewrite::r) (nat)) (times a (plus b c))) (\(:::: : nat) -> logic.eq (nat) :::: (plus (times b a) (times c a)))) (((((((logic.rewrite::r) (nat)) (times a b)) (\(:::: : nat) -> logic.eq (nat) (times a (plus b c)) (plus :::: (times c a)))) (((((((logic.rewrite::r) (nat)) (times a c)) (\(:::: : nat) -> logic.eq (nat) (times a (plus b c)) (plus (times a b) ::::))) (((((((logic.rewrite::l) (nat)) (times a (plus b c))) (\(:::: : nat) -> logic.eq (nat) (times a (plus b c)) ::::)) (((logic.refl) (nat)) (times a (plus b c)))) (plus (times a b) (times a c))) ((((distributive::times::plus) (a)) (b)) (c)))) (times c a)) (((commutative::times) (c)) (a)))) (times b a)) (((commutative::times) (b)) (a)))) (times (plus b c) a)) (((commutative::times) (plus b c)) (a))

associative::times : _
associative::times = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (times ::x::365 y) z) (times ::x::365 (times y z)))) ((((sym::eq::times) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (times O y) z) (x (times y z)))) ((((sym::eq::times) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (x y) z) (filter::nat::type (nat -> nat) times::body O (times y z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (x y) z) (filter::nat::type (nat -> nat) times::body O (times y z)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (times::body O y) z) (x (times y z)))) (((sym::eq::times::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (times::body O y) z) (x (times y z)))) (((sym::eq::times::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (x y) z) O)) ((((sym::eq::times) (O)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (x z) O)) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (x z) O)) (((sym::eq::times::body::O) (\(x : (nat -> nat)) -> forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (x z) O)) (\(::y : nat) -> \(::z : nat) -> ((logic.refl) (nat)) (O)))))))))))) (\(x::366 : nat) -> \(::x::368 : forall (y : nat) -> forall (z : nat) -> logic.eq (nat) (times (times x::366 y) z) (times x::366 (times y z))) -> (\(y : nat) -> \(z : nat) -> (((sym::eq::times) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (times (S x::366) y) z) (x (times y z)))) ((((sym::eq::times) (S x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (x y) z) (filter::nat::type (nat -> nat) times::body (S x::366) (times y z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (x y) z) (filter::nat::type (nat -> nat) times::body (S x::366) (times y z)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (times::body (S x::366) y) z) (x (times y z)))) ((((sym::eq::times::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (times::body (S x::366) y) z) (x (times y z)))) ((((sym::eq::times::body::S) (x::366)) (\(x : (nat -> nat)) -> logic.eq (nat) (times (x y) z) (plus (times y z) (times x::366 (times y z))))) (((((((logic.rewrite::r) (nat)) (plus (times y z) (times x::366 (times y z)))) (\(:::: : nat) -> logic.eq (nat) :::: (plus (times y z) (times x::366 (times y z))))) (((logic.refl) (nat)) (plus (times y z) (times x::366 (times y z))))) (times (plus y (times x::366 y)) z)) (((((((logic.rewrite::l) (nat)) (times (times x::366 y) z)) (\(:::: : nat) -> logic.eq (nat) (times (plus y (times x::366 y)) z) (plus (times y z) ::::))) ((((distributive::times::plus::r) (z)) (y)) (times x::366 y))) (times x::366 (times y z))) (((::x::368) (y)) (z)))))))))))) (n)

times::times : _
times::times = \(x : nat) -> \(y : nat) -> \(z : nat) -> ((((((logic.rewrite::r) (nat)) (times y (times x z))) (\(:::: : nat) -> logic.eq (nat) :::: (times y (times x z)))) (((logic.refl) (nat)) (times y (times x z)))) (times x (times y z))) (((((((logic.rewrite::l) (nat)) (times (times x y) z)) (\(:::: : nat) -> logic.eq (nat) :::: (times y (times x z)))) (((((((logic.rewrite::l) (nat)) (times y x)) (\(:::: : nat) -> logic.eq (nat) (times :::: z) (times y (times x z)))) ((((associative::times) (y)) (x)) (z))) (times x y)) (((commutative::times) (y)) (x)))) (times x (times y z))) ((((associative::times) (x)) (y)) (z)))

times::n::1 : _
times::n::1 = \(n : nat) -> ((((((logic.rewrite::l) (nat)) (plus n (times n O))) (\(:::: : nat) -> logic.eq (nat) n ::::)) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) n (plus n ::::))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) n ::::)) (((logic.refl) (nat)) (n))) (plus n O)) ((plus::n::O) (n)))) (times n O)) ((times::n::O) (n)))) (times n (S O))) (((times::n::Sm) (n)) (O))

minus::S::S : _
minus::S::S = \(n : nat) -> \(m : nat) -> ((((((eq::match::nat::type::S) (nat)) (S n)) (\(q : nat) -> minus n q)) (m)) (\(y : nat) -> logic.eq (nat) (minus (S n) (S m)) y)) ((((eq::minus::body::S) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus (S n) (S m)) (y (S m)))) ((((((eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus (S n) (S m)) (y (S m)))) ((((eq::minus) (S n)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus (S n) (S m)) (y (S m)))) (((logic.refl) (nat)) (minus (S n) (S m))))))

minus::O::n : _
minus::O::n = \(n : nat) -> ((((match::nat::prop) (\(:::: : nat) -> logic.eq (nat) O (minus O ::::))) ((((sym::eq::minus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) O (y O))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) O (y O))) (((sym::eq::minus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) O (y O))) (((logic.refl) (nat)) (O)))))) ((((sym::eq::minus) (O)) (\(y : (nat -> nat)) -> forall (n0 : nat) -> logic.eq (nat) O (y (S n0)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> forall (n0 : nat) -> logic.eq (nat) O (y (S n0)))) (((sym::eq::minus::body::O) (\(y : (nat -> nat)) -> forall (n0 : nat) -> logic.eq (nat) O (y (S n0)))) (\(auto : nat) -> ((logic.refl) (nat)) (O)))))) (n)

minus::n::O : _
minus::n::O = \(n : nat) -> ((((match::nat::prop) (\(:::: : nat) -> logic.eq (nat) :::: (minus :::: O))) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((logic.refl) (nat)) (O))) (minus O O)) ((minus::O::n) (O)))) (\(auto : nat) -> (((sym::eq::minus) (S auto)) (\(y : (nat -> nat)) -> logic.eq (nat) (S auto) (y O))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (auto)) (\(y : (nat -> nat)) -> logic.eq (nat) (S auto) (y O))) ((((sym::eq::minus::body::S) (auto)) (\(y : (nat -> nat)) -> logic.eq (nat) (S auto) (y O))) ((((((sym::eq::match::nat::type::O) (nat)) (S auto)) (\(q : nat) -> minus auto q)) (\(y : nat) -> logic.eq (nat) (S auto) y)) (((logic.refl) (nat)) (S auto))))))) (n)

minus::n::n : _
minus::n::n = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> logic.eq (nat) O (minus ::x::365 ::x::365))) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((logic.refl) (nat)) (O))) (minus O O)) ((minus::O::n) (O)))) (\(x::366 : nat) -> \(::x::368 : logic.eq (nat) O (minus x::366 x::366)) -> (((((((logic.rewrite::r) (nat)) (minus x::366 x::366)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) O ::::)) (((logic.refl) (nat)) (O))) (minus x::366 x::366)) (::x::368))) (minus (S x::366) (S x::366))) (((minus::S::S) (x::366)) (x::366))))) (n)

eq::minus::S::pred : _
eq::minus::S::pred = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> logic.eq (nat) (minus :::: (S ::0)) (pred (minus :::: ::0)))) (\(::n : nat) -> (((sym::eq::minus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus O (S ::n)) (pred (y ::n)))) ((((sym::eq::minus) (O)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (S ::n)) (pred (filter::nat::type (nat -> nat) minus::body O ::n)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (S ::n)) (pred (filter::nat::type (nat -> nat) minus::body O ::n)))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus::body O (S ::n)) (pred (y ::n)))) (((sym::eq::minus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) (minus::body O (S ::n)) (pred (y ::n)))) (((sym::eq::minus::body::O) (\(y : (nat -> nat)) -> logic.eq (nat) (y (S ::n)) (match::nat::type (nat) O (\(p : nat) -> p) O))) ((((((sym::eq::match::nat::type::O) (nat)) (O)) (\(p : nat) -> p)) (\(y : nat) -> logic.eq (nat) O y)) (((logic.refl) (nat)) (O)))))))))) (\(n : nat) -> (((sym::eq::minus) (S n)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus (S n) (S O)) (pred (y O)))) ((((sym::eq::minus) (S n)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (S O)) (pred (filter::nat::type (nat -> nat) minus::body (S n) O)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (S O)) (pred (filter::nat::type (nat -> nat) minus::body (S n) O)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus::body (S n) (S O)) (pred (y O)))) ((((sym::eq::minus::body::S) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (minus::body (S n) (S O)) (pred (y O)))) ((((sym::eq::minus::body::S) (n)) (\(y : (nat -> nat)) -> logic.eq (nat) (y (S O)) (pred (match::nat::type (nat) (S n) (\(q : nat) -> minus n q) O)))) (((((((sym::eq::match::nat::type::S) (nat)) (S n)) (\(q : nat) -> minus n q)) (O)) (\(y : nat) -> logic.eq (nat) y (match::nat::type (nat) O (\(p : nat) -> p) (match::nat::type (nat) (S n) (\(q : nat) -> minus n q) O)))) ((((((sym::eq::match::nat::type::O) (nat)) (S n)) (\(q : nat) -> minus n q)) (\(y : nat) -> logic.eq (nat) (minus n O) (match::nat::type (nat) O (\(p : nat) -> p) y))) (((((((sym::eq::match::nat::type::S) (nat)) (O)) (\(q : nat) -> q)) (n)) (\(y : nat) -> logic.eq (nat) (minus n O) y)) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) :::: n)) (((logic.refl) (nat)) (n))) (minus n O)) ((minus::n::O) (n))))))))))))) (\(n : nat) -> \(m : nat) -> (((sym::eq::minus) (S n)) (\(y : (nat -> nat)) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (minus (S n) (S (S m))) (pred (y (S m))))) ((((sym::eq::minus) (S n)) (\(y : (nat -> nat)) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (y (S (S m))) (pred (filter::nat::type (nat -> nat) minus::body (S n) (S m))))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (n)) (\(y : (nat -> nat)) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (y (S (S m))) (pred (filter::nat::type (nat -> nat) minus::body (S n) (S m))))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (n)) (\(y : (nat -> nat)) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (minus::body (S n) (S (S m))) (pred (y (S m))))) ((((sym::eq::minus::body::S) (n)) (\(y : (nat -> nat)) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (minus::body (S n) (S (S m))) (pred (y (S m))))) ((((sym::eq::minus::body::S) (n)) (\(y : (nat -> nat)) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (y (S (S m))) (pred (match::nat::type (nat) (S n) (\(q : nat) -> minus n q) (S m))))) (((((((sym::eq::match::nat::type::S) (nat)) (S n)) (\(q : nat) -> minus n q)) (S m)) (\(y : nat) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) y (match::nat::type (nat) O (\(p : nat) -> p) (match::nat::type (nat) (S n) (\(q : nat) -> minus n q) (S m))))) (((((((sym::eq::match::nat::type::S) (nat)) (S n)) (\(q : nat) -> minus n q)) (m)) (\(y : nat) -> (logic.eq (nat) (minus n (S m)) (pred (minus n m))) -> logic.eq (nat) (minus n (S m)) (match::nat::type (nat) O (\(p : nat) -> p) y))) (\(auto : logic.eq (nat) (minus n (S m)) (match::nat::type (nat) O (\(p : nat) -> p) (minus n m))) -> (((((((logic.rewrite::r) (nat)) (match::nat::type (nat) O (\(p : nat) -> p) (minus n m))) (\(:::: : nat) -> logic.eq (nat) :::: (match::nat::type (nat) O (\(p : nat) -> p) (minus n m)))) (((logic.refl) (nat)) (match::nat::type (nat) O (\(p : nat) -> p) (minus n m)))) (minus n (S m))) (auto)))))))))))

not::eq::S : _
not::eq::S = \(n : nat) -> \(m : nat) -> \(auto : connectives.Not (logic.eq (nat) n m)) -> (((((logic.not::to::not) (logic.eq (nat) (S n) (S m))) (logic.eq (nat) n m)) (\(auto' : logic.eq (nat) (S n) (S m)) -> (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (nat) :::: m)) (((logic.refl) (nat)) (m))) (n)) (((((((logic.rewrite::r) (nat)) (pred (S n))) (\(:::: : nat) -> logic.eq (nat) m ::::)) (((((((logic.rewrite::r) (nat)) (S m)) (\(:::: : nat) -> logic.eq (nat) m (pred ::::))) ((pred::Sn) (m))) (S n)) (auto'))) (n)) ((pred::Sn) (n)))))) (auto))

not::eq::O::S : _
not::eq::O::S = \(n : nat) -> ((connectives.nmk) (logic.eq (nat) O (S n))) (\(eqOS : logic.eq (nat) O (S n)) -> ((((((eq::match::nat::type::O) _) (connectives.False)) (\(p : nat) -> connectives.True)) (\(y : Set) -> y)) (((((((logic.eq::ind::r) (nat)) (S n)) (\(x : nat) -> not::zero x)) (((((((sym::eq::match::nat::type::S) _) (connectives.False)) (\(p : nat) -> connectives.True)) (n)) (\(y : Set) -> y)) (connectives.I))) (O)) (eqOS))))

lt::to::not::zero : _
lt::to::not::zero = \(n : nat) -> \(m : nat) -> \(Hlt : lt n m) -> (((((((le::ind) (S n)) (\(x::417 : nat) -> not::zero x::417)) (((((((sym::eq::match::nat::type::S) (Set)) (connectives.False)) (\(p : nat) -> connectives.True)) (n)) (\(y : Set) -> y)) (connectives.I))) (\(m0 : nat) -> \(::x::419 : le (S n) m0) -> (\(::x::421 : not::zero m0) -> (((((((sym::eq::match::nat::type::S) (Set)) (connectives.False)) (\(p : nat) -> connectives.True)) (m0)) (\(y : Set) -> y)) (connectives.I))))) (m)) (Hlt))

le::S::S : _
le::S::S = \(n : nat) -> \(m : nat) -> \(lenm : le n m) -> (((((((le::ind) (n)) (\(x::417 : nat) -> le (S n) (S x::417))) ((le::n) (S n))) (\(m0 : nat) -> \(::x::419 : le n m0) -> (\(::x::421 : le (S n) (S m0)) -> ((((le::S) (S n)) (S m0)) (::x::421))))) (m)) (lenm))

le::O::n : _
le::O::n = \(n : nat) -> ((((nat::ind) (le O)) ((le::n) (O))) (\(x::366 : nat) -> \(::x::368 : le O x::366) -> ((((le::S) (O)) (x::366)) (::x::368)))) (n)

le::n::Sn : _
le::n::Sn = \(n : nat) -> (((le::S) (n)) (n)) ((le::n) (n))

transitive::le : _
transitive::le = \(a : nat) -> \(b : nat) -> \(c : nat) -> \(leab : le a b) -> (\(lebc : le b c) -> (((((((le::ind) (b)) (\(x::417 : nat) -> le a x::417)) (leab)) (\(m : nat) -> \(::x::419 : le b m) -> (\(::x::421 : le a m) -> ((((le::S) (a)) (m)) (::x::421))))) (c)) (lebc)))

le::pred::n : _
le::pred::n = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> le (pred ::x::365) ::x::365)) ((((((eq::match::nat::type::O) (nat)) (O)) (\(p : nat) -> p)) (\(y : nat) -> le (match::nat::type (nat) O (\(p : nat) -> p) O) y)) ((le::n) (pred O)))) (\(x::366 : nat) -> \(::x::368 : le (pred x::366) x::366) -> (((((((eq::match::nat::type::S) (nat)) (O)) (\(p : nat) -> p)) (x::366)) (\(y : nat) -> le (pred (S x::366)) (S y))) ((le::n::Sn) (pred (S x::366)))))) (n)

monotonic::pred : _
monotonic::pred = \(n : nat) -> \(m : nat) -> \(lenm : le n m) -> (((((((le::ind) (n)) (\(x::417 : nat) -> le (pred n) (pred x::417))) ((le::n) (pred n))) (\(m0 : nat) -> \(::x::419 : le n m0) -> (\(::x::421 : le (pred n) (pred m0)) -> ((((((transitive::le) (pred n)) (n)) (pred (S m0))) ((le::pred::n) (n))) (((((((sym::eq::match::nat::type::S) (nat)) (O)) (\(p : nat) -> p)) (m0)) (\(y : nat) -> le n y)) (::x::419)))))) (m)) (lenm))

le::S::S::to::le : _
le::S::S::to::le = \(n : nat) -> \(m : nat) -> \(auto : le (S n) (S m)) -> (((((((eq::match::nat::type::S) (nat)) (O)) (\(p : nat) -> p)) (m)) (\(y : nat) -> le n y)) (((((((eq::match::nat::type::S) (nat)) (O)) (\(p : nat) -> p)) (n)) (\(y : nat) -> le y (match::nat::type (nat) O (\(p : nat) -> p) (S m)))) ((((monotonic::pred) (S n)) (S m)) (auto))))

monotonic::le::plus::r : _
monotonic::le::plus::r = \(n : nat) -> \(a : nat) -> \(b : nat) -> ((((nat::ind) (\(::x::365 : nat) -> (le a b) -> le (plus ::x::365 a) (plus ::x::365 b))) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> (le a b) -> le (plus O a) (y b))) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> (le a b) -> le (y a) (filter::nat::type (nat -> nat) plus::body O b))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> (le a b) -> le (y a) (filter::nat::type (nat -> nat) plus::body O b))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> (le a b) -> le (plus::body O a) (y b))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> (le a b) -> le (plus::body O a) (y b))) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> (le a b) -> le (y a) b)) (\(auto : le a b) -> (auto))))))))) (\(m : nat) -> \(H : (le a b) -> le (plus m a) (plus m b)) -> (\(leab : le a b) -> ((((sym::eq::plus) (S m)) (\(y : (nat -> nat)) -> le (plus (S m) a) (y b))) ((((sym::eq::plus) (S m)) (\(y : (nat -> nat)) -> le (y a) (filter::nat::type (nat -> nat) plus::body (S m) b))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (m)) (\(y : (nat -> nat)) -> le (y a) (filter::nat::type (nat -> nat) plus::body (S m) b))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (m)) (\(y : (nat -> nat)) -> le (plus::body (S m) a) (y b))) ((((sym::eq::plus::body::S) (m)) (\(y : (nat -> nat)) -> le (plus::body (S m) a) (y b))) ((((sym::eq::plus::body::S) (m)) (\(y : (nat -> nat)) -> le (y a) (S (plus m b)))) ((((le::S::S) (plus m a)) (plus m b)) ((H) (leab)))))))))))) (n)

monotonic::le::plus::l : _
monotonic::le::plus::l = \(m : nat) -> \(x : nat) -> \(y : nat) -> \(auto : le x y) -> (((((logic.eq::coerc) (le (plus m x) (plus m y))) (le (plus x m) (plus y m))) (((((monotonic::le::plus::r) (m)) (x)) (y)) (auto))) (((((((logic.rewrite::r) (nat)) (plus m x)) (\(:::: : nat) -> logic.eq _ (le (plus m x) (plus m y)) (le :::: (plus y m)))) (((((((logic.rewrite::r) (nat)) (plus m y)) (\(:::: : nat) -> logic.eq (Set) (le (plus m x) (plus m y)) (le (plus m x) ::::))) (((logic.refl) _) (le (plus m x) (plus m y)))) (plus y m)) (((commutative::plus) (y)) (m)))) (plus x m)) (((commutative::plus) (x)) (m))))

le::plus : _
le::plus = \(n1 : nat) -> \(n2 : nat) -> \(m1 : nat) -> \(m2 : nat) -> \(len : le n1 n2) -> (\(lem : le m1 m2) -> ((((((transitive::le) (plus n1 m1)) (plus n1 m2)) (plus n2 m2)) (((((monotonic::le::plus::r) (n1)) (m1)) (m2)) (lem))) (((((monotonic::le::plus::l) (m2)) (n1)) (n2)) (len))))

le::plus::n : _
le::plus::n = \(n : nat) -> \(m : nat) -> ((((logic.eq::coerc) (le (plus O m) (plus n m))) (le m (plus n m))) (((((monotonic::le::plus::l) (m)) (O)) (n)) ((le::O::n) (n)))) (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (Set) (le :::: (plus n m)) (le m (plus n m)))) (((logic.refl) (Set)) (le m (plus n m)))) (plus O m)) ((plus::O::n) (m)))

le::plus::b : _
le::plus::b = \(b : nat) -> \(n : nat) -> \(m : nat) -> \(auto : le (plus n b) m) -> ((((((transitive::le) (n)) (plus n b)) (m)) (((((logic.eq::coerc) (le n (plus b n))) (le n (plus n b))) (((le::plus::n) (b)) (n))) (((((((logic.rewrite::r) (nat)) (plus b n)) (\(:::: : nat) -> logic.eq (Set) (le n (plus b n)) (le n ::::))) (((logic.refl) (Set)) (le n (plus b n)))) (plus n b)) (((commutative::plus) (n)) (b))))) (auto))

le::plus::n::r : _
le::plus::n::r = \(n : nat) -> \(m : nat) -> ((((logic.eq::coerc) (le m (plus n m))) (le m (plus m n))) (((le::plus::n) (n)) (m))) (((((((logic.rewrite::r) (nat)) (plus n m)) (\(:::: : nat) -> logic.eq (Set) (le m (plus n m)) (le m ::::))) (((logic.refl) (Set)) (le m (plus n m)))) (plus m n)) (((commutative::plus) (m)) (n)))

le::plus::to::le : _
le::plus::to::le = \(a : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (n : nat) -> forall (m : nat) -> (le (plus ::x::365 n) (plus ::x::365 m)) -> le n m)) (\(n : nat) -> \(m : nat) -> (((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> (le (plus O n) (y m)) -> le n m)) ((((sym::eq::plus) (O)) (\(y : (nat -> nat)) -> (le (y n) (filter::nat::type (nat -> nat) plus::body O m)) -> le n m)) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> (le (y n) (filter::nat::type (nat -> nat) plus::body O m)) -> le n m)) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> (le (plus::body O n) (y m)) -> le n m)) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> (le (plus::body O n) (y m)) -> le n m)) (((sym::eq::plus::body::O) (\(y : (nat -> nat)) -> (le (y n) m) -> le n m)) (\(auto : le n m) -> (auto))))))))) (\(x::366 : nat) -> \(::x::368 : forall (n : nat) -> forall (m : nat) -> (le (plus x::366 n) (plus x::366 m)) -> le n m) -> (\(n : nat) -> \(m : nat) -> (((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> (le (plus (S x::366) n) (y m)) -> le n m)) ((((sym::eq::plus) (S x::366)) (\(y : (nat -> nat)) -> (le (y n) (filter::nat::type (nat -> nat) plus::body (S x::366) m)) -> le n m)) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> (le (y n) (filter::nat::type (nat -> nat) plus::body (S x::366) m)) -> le n m)) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (x::366)) (\(y : (nat -> nat)) -> (le (plus::body (S x::366) n) (y m)) -> le n m)) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> (le (plus::body (S x::366) n) (y m)) -> le n m)) ((((sym::eq::plus::body::S) (x::366)) (\(y : (nat -> nat)) -> (le (y n) (S (plus x::366 m))) -> le n m)) (\(auto : le (S (plus x::366 n)) (S (plus x::366 m))) -> (((((logic.eq::coerc) (le (pred (S n)) (pred (S m)))) (le n m)) ((((monotonic::pred) (S n)) (S m)) ((((::x::368) (S n)) (S m)) (((((logic.eq::coerc) (le (S (plus x::366 n)) (S (plus x::366 m)))) (le (plus x::366 (S n)) (plus x::366 (S m)))) (auto)) (((((((logic.rewrite::r) (nat)) (plus x::366 (S n))) (\(:::: : nat) -> logic.eq (Set) (le :::: (S (plus x::366 m))) (le (plus x::366 (S n)) (plus x::366 (S m))))) (((((((logic.rewrite::r) (nat)) (plus x::366 (S m))) (\(:::: : nat) -> logic.eq (Set) (le (plus x::366 (S n)) ::::) (le (plus x::366 (S n)) (plus x::366 (S m))))) (((logic.refl) (Set)) (le (plus x::366 (S n)) (plus x::366 (S m))))) (S (plus x::366 m))) (((plus::n::Sm) (x::366)) (m)))) (S (plus x::366 n))) (((plus::n::Sm) (x::366)) (n))))))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le :::: (pred (S m))) (le n m))) (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (Set) (le n ::::) (le n m))) (((logic.refl) (Set)) (le n m))) (pred (S m))) ((pred::Sn) (m)))) (pred (S n))) ((pred::Sn) (n))))))))))))) (a)

le::plus::to::le::r : _
le::plus::to::le::r = \(a : nat) -> \(n : nat) -> \(m : nat) -> \(auto : le (plus n a) (plus m a)) -> (((((le::plus::to::le) (a)) (n)) (m)) (((((logic.eq::coerc) (le (plus n a) (plus m a))) (le (plus a n) (plus a m))) (auto)) (((((((logic.rewrite::r) (nat)) (plus a n)) (\(:::: : nat) -> logic.eq (Set) (le :::: (plus m a)) (le (plus a n) (plus a m)))) (((((((logic.rewrite::r) (nat)) (plus a m)) (\(:::: : nat) -> logic.eq (Set) (le (plus a n) ::::) (le (plus a n) (plus a m)))) (((logic.refl) (Set)) (le (plus a n) (plus a m)))) (plus m a)) (((commutative::plus) (m)) (a)))) (plus n a)) (((commutative::plus) (n)) (a)))))

monotonic::le::times::r : _
monotonic::le::times::r = \(n : nat) -> \(x : nat) -> \(y : nat) -> \(lexy : le x y) -> (((((nat::ind) (\(::x::365 : nat) -> le (times ::x::365 x) (times ::x::365 y))) ((((sym::eq::times) (O)) (\(z : (nat -> nat)) -> le (times O x) (z y))) ((((sym::eq::times) (O)) (\(z : (nat -> nat)) -> le (z x) (filter::nat::type (nat -> nat) times::body O y))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(z : (nat -> nat)) -> le (z x) (filter::nat::type (nat -> nat) times::body O y))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (times::body)) (\(z : (nat -> nat)) -> le (times::body O x) (z y))) (((sym::eq::times::body::O) (\(z : (nat -> nat)) -> le (times::body O x) (z y))) (((sym::eq::times::body::O) (\(z : (nat -> nat)) -> le (z x) O)) ((le::O::n) (O))))))))) (\(a : nat) -> \(lea : le (times a x) (times a y)) -> ((((sym::eq::times) (S a)) (\(z : (nat -> nat)) -> le (times (S a) x) (z y))) ((((sym::eq::times) (S a)) (\(z : (nat -> nat)) -> le (z x) (filter::nat::type (nat -> nat) times::body (S a) y))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (a)) (\(z : (nat -> nat)) -> le (z x) (filter::nat::type (nat -> nat) times::body (S a) y))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (times::body)) (a)) (\(z : (nat -> nat)) -> le (times::body (S a) x) (z y))) ((((sym::eq::times::body::S) (a)) (\(z : (nat -> nat)) -> le (times::body (S a) x) (z y))) ((((sym::eq::times::body::S) (a)) (\(z : (nat -> nat)) -> le (z x) (plus y (times a y)))) (((((((le::plus) (x)) (y)) (times a x)) (times a y)) (lexy)) (lea)))))))))) (n))

le::times : _
le::times = \(n1 : nat) -> \(n2 : nat) -> \(m1 : nat) -> \(m2 : nat) -> \(len : le n1 n2) -> (\(lem : le m1 m2) -> ((((((transitive::le) (times n1 m1)) (times n1 m2)) (times n2 m2)) (((((monotonic::le::times::r) (n1)) (m1)) (m2)) (lem))) (((((logic.eq::coerc) (le (times m2 n1) (times m2 n2))) (le (times n1 m2) (times n2 m2))) (((((monotonic::le::times::r) (m2)) (n1)) (n2)) (len))) (((((((logic.rewrite::r) (nat)) (times n1 m2)) (\(:::: : nat) -> logic.eq (Set) (le :::: (times m2 n2)) (le (times n1 m2) (times n2 m2)))) (((((((logic.rewrite::r) (nat)) (times n2 m2)) (\(:::: : nat) -> logic.eq (Set) (le (times n1 m2) ::::) (le (times n1 m2) (times n2 m2)))) (((logic.refl) (Set)) (le (times n1 m2) (times n2 m2)))) (times m2 n2)) (((commutative::times) (m2)) (n2)))) (times m2 n1)) (((commutative::times) (m2)) (n1))))))

le::plus::minus::m::m : _
le::plus::minus::m::m = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> forall (m : nat) -> le ::x::365 (plus (minus ::x::365 m) m))) ((((sym::eq::minus) (O)) (\(y : (nat -> nat)) -> forall (m : nat) -> le O (plus (y m) m))) (((((sym::eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> forall (m : nat) -> le O (plus (y m) m))) (((sym::eq::minus::body::O) (\(y : (nat -> nat)) -> forall (m : nat) -> le O (plus (y m) m))) (\(m : nat) -> ((le::plus::n::r) (m)) (O)))))) (\(a : nat) -> \(Hind : forall (m : nat) -> le a (plus (minus a m) m)) -> (\(m : nat) -> ((((match::nat::prop) (\(:::: : nat) -> le (S a) (plus (minus (S a) ::::) ::::))) ((((sym::eq::minus) (S a)) (\(y : (nat -> nat)) -> le (S a) (plus (y O) O))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (a)) (\(y : (nat -> nat)) -> le (S a) (plus (y O) O))) ((((sym::eq::minus::body::S) (a)) (\(y : (nat -> nat)) -> le (S a) (plus (y O) O))) ((((((sym::eq::match::nat::type::O) (nat)) (S a)) (\(q : nat) -> minus a q)) (\(y : nat) -> le (S a) (plus y O))) (((le::plus::n::r) (O)) (S a))))))) (\(n0 : nat) -> (((sym::eq::minus) (S a)) (\(y : (nat -> nat)) -> le (S a) (plus (y (S n0)) (S n0)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (a)) (\(y : (nat -> nat)) -> le (S a) (plus (y (S n0)) (S n0)))) ((((sym::eq::minus::body::S) (a)) (\(y : (nat -> nat)) -> le (S a) (plus (y (S n0)) (S n0)))) (((((((sym::eq::match::nat::type::S) (nat)) (S a)) (\(q : nat) -> minus a q)) (n0)) (\(y : nat) -> le (S a) (plus y (S n0)))) (((((logic.eq::coerc) (le (S a) (S (plus (minus a n0) n0)))) (le (S a) (plus (minus a n0) (S n0)))) ((((le::S::S) (a)) (plus (minus a n0) n0)) ((Hind) (n0)))) (((((((logic.rewrite::r) (nat)) (plus (minus a n0) (S n0))) (\(:::: : nat) -> logic.eq (Set) (le (S a) ::::) (le (S a) (plus (minus a n0) (S n0))))) (((logic.refl) (Set)) (le (S a) (plus (minus a n0) (S n0))))) (S (plus (minus a n0) n0))) (((plus::n::Sm) (minus a n0)) (n0))))))))) (m)))) (n)

le::plus::to::minus::r : _
le::plus::to::minus::r = \(a : nat) -> \(b : nat) -> \(c : nat) -> \(H : le (plus a b) c) -> (((((le::plus::to::le::r) (b)) (a)) (minus c b)) ((((((transitive::le) (plus a b)) (c)) (plus (minus c b) b)) (H)) (((le::plus::minus::m::m) (c)) (b))))

lt::to::le : _
lt::to::le = \(x : nat) -> \(y : nat) -> \(auto : lt x y) -> (((((le::plus::b) (S O)) (x)) (y)) (((((logic.eq::coerc) (le (S x) y)) (le (plus x (S O)) y)) (auto)) (((((((logic.rewrite::r) (nat)) (plus x (S O))) (\(:::: : nat) -> logic.eq (Set) (le :::: y) (le (plus x (S O)) y))) (((logic.refl) (Set)) (le (plus x (S O)) y))) (S x)) (((((((logic.rewrite::r) (nat)) (plus x O)) (\(:::: : nat) -> logic.eq (nat) (S ::::) (plus x (S O)))) (((plus::n::Sm) (x)) (O))) (x)) ((plus::n::O) (x))))))

transitive::lt : _
transitive::lt = \(a : nat) -> \(b : nat) -> \(c : nat) -> \(ltab : lt a b) -> (\(ltbc : lt b c) -> (((((((le::ind) (S b)) (\(x::417 : nat) -> lt a x::417)) ((((le::S) (S a)) (b)) (ltab))) (\(m : nat) -> \(::x::419 : le (S b) m) -> (\(::x::421 : lt a m) -> ((((le::S) (S a)) (m)) (::x::421))))) (c)) (ltbc)))

lt::to::le::to::lt : _
lt::to::le::to::lt = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(H : lt n m) -> (\(H1 : le m p) -> (((((((le::ind) (m)) (\(x::417 : nat) -> lt n x::417)) (H)) (\(m0 : nat) -> \(::x::419 : le m m0) -> (\(::x::421 : lt n m0) -> ((((((transitive::lt) (n)) (m0)) (S m0)) (::x::421)) (((((logic.eq::coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le::plus::n) (O)) (S m0))) (((((((logic.rewrite::l) (nat)) (S m0)) (\(:::: : nat) -> logic.eq (Set) (le (S m0) ::::) (le (S m0) (S m0)))) (((logic.refl) (Set)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus::O::n) (S m0)))))))) (p)) (H1)))

le::to::lt::to::lt : _
le::to::lt::to::lt = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(H : le n m) -> (((((((le::ind) (n)) (\(x::417 : nat) -> (lt x::417 p) -> lt n p)) (\(auto : lt n p) -> (auto))) (\(m0 : nat) -> \(::x::419 : le n m0) -> (\(::x::421 : (lt m0 p) -> lt n p) -> (\(auto : lt (S m0) p) -> ((::x::421) ((((((transitive::lt) (m0)) (S m0)) (p)) (((((logic.eq::coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le::plus::n) (O)) (S m0))) (((((((logic.rewrite::l) (nat)) (S m0)) (\(:::: : nat) -> logic.eq (Set) (le (S m0) ::::) (le (S m0) (S m0)))) (((logic.refl) (Set)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus::O::n) (S m0))))) (auto))))))) (m)) (H))

lt::S::to::lt : _
lt::S::to::lt = \(n : nat) -> \(m : nat) -> \(auto : lt (S n) m) -> ((((((transitive::lt) (n)) (S n)) (m)) (((((logic.eq::coerc) (le (S n) (plus O (S n)))) (le (S n) (S n))) (((le::plus::n) (O)) (S n))) (((((((logic.rewrite::l) (nat)) (S n)) (\(:::: : nat) -> logic.eq (Set) (le (S n) ::::) (le (S n) (S n)))) (((logic.refl) (Set)) (le (S n) (S n)))) (plus O (S n))) ((plus::O::n) (S n))))) (auto))

ltn::to::ltO : _
ltn::to::ltO = \(n : nat) -> \(m : nat) -> \(auto : lt n m) -> ((((((lt::to::le::to::lt) (O)) (S n)) (m)) (((((logic.eq::coerc) (le (S O) (plus n (S O)))) (le (S O) (S n))) (((le::plus::n) (n)) (S O))) (((((((logic.rewrite::l) (nat)) (S n)) (\(:::: : nat) -> logic.eq (Set) (le (S O) ::::) (le (S O) (S n)))) (((logic.refl) (Set)) (le (S O) (S n)))) (plus n (S O))) (((((((logic.rewrite::r) (nat)) (plus n O)) (\(:::: : nat) -> logic.eq (nat) (S ::::) (plus n (S O)))) (((plus::n::Sm) (n)) (O))) (n)) ((plus::n::O) (n)))))) (auto))

lt::O::S : _
lt::O::S = \(n : nat) -> (((ltn::to::ltO) (n)) (S n)) (((((logic.eq::coerc) (le (S n) (plus O (S n)))) (le (S n) (S n))) (((le::plus::n) (O)) (S n))) (((((((logic.rewrite::l) (nat)) (S n)) (\(:::: : nat) -> logic.eq (Set) (le (S n) ::::) (le (S n) (S n)))) (((logic.refl) (Set)) (le (S n) (S n)))) (plus O (S n))) ((plus::O::n) (S n))))

monotonic::lt::plus::r : _
monotonic::lt::plus::r = \(n : nat) -> \(x : nat) -> \(y : nat) -> \(auto : lt x y) -> (((((logic.eq::coerc) (le (plus n (S x)) (plus n y))) (le (S (plus n x)) (plus n y))) (((((monotonic::le::plus::r) (n)) (S x)) (y)) (auto))) (((((((logic.rewrite::r) (nat)) (plus n (S x))) (\(:::: : nat) -> logic.eq (Set) (le (plus n (S x)) (plus n y)) (le :::: (plus n y)))) (((logic.refl) (Set)) (le (plus n (S x)) (plus n y)))) (S (plus n x))) (((plus::n::Sm) (n)) (x))))

monotonic::lt::plus::l : _
monotonic::lt::plus::l = \(n : nat) -> \(x : nat) -> \(y : nat) -> \(auto : lt x y) -> (((((logic.eq::coerc) (le (plus n (S x)) (plus n y))) (le (S (plus x n)) (plus y n))) (((((monotonic::le::plus::r) (n)) (S x)) (y)) (auto))) (((((((logic.rewrite::r) (nat)) (plus n x)) (\(:::: : nat) -> logic.eq (Set) (le (plus n (S x)) (plus n y)) (le (S ::::) (plus y n)))) (((((((logic.rewrite::r) (nat)) (plus n (S x))) (\(:::: : nat) -> logic.eq (Set) (le (plus n (S x)) (plus n y)) (le :::: (plus y n)))) (((((((logic.rewrite::r) (nat)) (plus n y)) (\(:::: : nat) -> logic.eq (Set) (le (plus n (S x)) (plus n y)) (le (plus n (S x)) ::::))) (((logic.refl) (Set)) (le (plus n (S x)) (plus n y)))) (plus y n)) (((commutative::plus) (y)) (n)))) (S (plus n x))) (((plus::n::Sm) (n)) (x)))) (plus x n)) (((commutative::plus) (x)) (n))))

monotonic::lt::times::r : _
monotonic::lt::times::r = \(c : nat) -> \(posc : lt O c) -> (\(n : nat) -> \(m : nat) -> \(ltnm : lt n m) -> (((((((le::ind) (S n)) (\(x::417 : nat) -> lt (times c n) (times c x::417))) (((((logic.eq::coerc) (le (S (plus O (times c n))) (plus c (times c n)))) (le (S (times c n)) (times c (S n)))) (((((monotonic::lt::plus::l) (times c n)) (O)) (c)) (posc))) (((((((logic.rewrite::r) (nat)) (plus O (S (times c n)))) (\(:::: : nat) -> logic.eq (Set) (le :::: (plus c (times c n))) (le (S (times c n)) (times c (S n))))) (((((((logic.rewrite::l) (nat)) (plus c (times c n))) (\(:::: : nat) -> logic.eq (Set) (le (plus O (S (times c n))) (plus c (times c n))) (le (S (times c n)) ::::))) (((((((logic.rewrite::l) (nat)) (S (times c n))) (\(:::: : nat) -> logic.eq (Set) (le :::: (plus c (times c n))) (le (S (times c n)) (plus c (times c n))))) (((logic.refl) (Set)) (le (S (times c n)) (plus c (times c n))))) (plus O (S (times c n)))) ((plus::O::n) (S (times c n))))) (times c (S n))) (((times::n::Sm) (c)) (n)))) (S (plus O (times c n)))) (((plus::n::Sm) (O)) (times c n))))) (\(a : nat) -> \(:::: : le (S n) a) -> (\(lt1 : le (S (times c n)) (times c a)) -> ((((((transitive::le) (S (times c n))) (times c a)) (times c (S a))) (lt1)) (((((logic.eq::coerc) (le (times c a) (plus (times c a) c))) (le (times c a) (times c (S a)))) (((le::plus::n::r) (c)) (times c a))) (((((((logic.rewrite::l) (nat)) (plus c (times c a))) (\(::::1 : nat) -> logic.eq (Set) (le (times c a) (plus (times c a) c)) (le (times c a) ::::1))) (((((((logic.rewrite::r) (nat)) (plus c (times c a))) (\(::::1 : nat) -> logic.eq (Set) (le (times c a) ::::1) (le (times c a) (plus c (times c a))))) (((logic.refl) (Set)) (le (times c a) (plus c (times c a))))) (plus (times c a) c)) (((commutative::plus) (times c a)) (c)))) (times c (S a))) (((times::n::Sm) (c)) (a)))))))) (m)) (ltnm)))

monotonic::lt::times::l : _
monotonic::lt::times::l = \(c : nat) -> \(auto : lt O c) -> (\(x : nat) -> \(y : nat) -> \(auto' : lt x y) -> (((((logic.eq::coerc) (le (S (times c x)) (times c y))) (le (S (times x c)) (times y c))) ((((((monotonic::lt::times::r) (c)) (auto)) (x)) (y)) (auto'))) (((((((logic.rewrite::r) (nat)) (times c x)) (\(:::: : nat) -> logic.eq (Set) (le (S (times c x)) (times c y)) (le (S ::::) (times y c)))) (((((((logic.rewrite::r) (nat)) (times c y)) (\(:::: : nat) -> logic.eq (Set) (le (S (times c x)) (times c y)) (le (S (times c x)) ::::))) (((logic.refl) (Set)) (le (S (times c x)) (times c y)))) (times y c)) (((commutative::times) (y)) (c)))) (times x c)) (((commutative::times) (x)) (c)))))

lt::to::le::to::lt::times : _
lt::to::le::to::lt::times = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(q : nat) -> \(ltnm : lt n m) -> (\(lepq : le p q) -> (\(posq : lt O q) -> ((((((le::to::lt::to::lt) (times n p)) (times n q)) (times m q)) (((((monotonic::le::times::r) (n)) (p)) (q)) (lepq))) ((((((monotonic::lt::times::l) (q)) (posq)) (n)) (m)) (ltnm)))))

lt::times : _
lt::times = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(q : nat) -> \(ltnm : lt n m) -> (\(ltpq : lt p q) -> ((((((((lt::to::le::to::lt::times) (n)) (m)) (p)) (q)) (ltnm)) ((((lt::to::le) (p)) (q)) (ltpq))) ((((ltn::to::ltO) (p)) (q)) (ltpq))))

lt::plus::to::minus::r : _
lt::plus::to::minus::r = \(a : nat) -> \(b : nat) -> \(c : nat) -> \(H : lt (plus a b) c) -> (((((le::plus::to::minus::r) (S a)) (b)) (c)) ((((sym::eq::plus) (S a)) (\(y : (nat -> nat)) -> le (y b) c)) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (a)) (\(y : (nat -> nat)) -> le (y b) c)) ((((sym::eq::plus::body::S) (a)) (\(y : (nat -> nat)) -> le (y b) c)) (H)))))

lt::plus::Sn::r : _
lt::plus::Sn::r = \(a : nat) -> \(x : nat) -> \(n : nat) -> ((((logic.eq::coerc) (le (S a) (S (plus (plus a x) n)))) (le (S a) (plus (plus a x) (S n)))) ((((le::S::S) (a)) (plus (plus a x) n)) (((((logic.eq::coerc) (le a (plus a (plus x n)))) (le a (plus (plus a x) n))) (((le::plus::n::r) (plus x n)) (a))) (((((((logic.rewrite::r) (nat)) (plus n (plus a x))) (\(:::: : nat) -> logic.eq (Set) (le a (plus a (plus x n))) (le a ::::))) (((((((logic.rewrite::r) (nat)) (plus a (plus n x))) (\(:::: : nat) -> logic.eq (Set) (le a (plus a (plus x n))) (le a ::::))) (((((((logic.rewrite::r) (nat)) (plus x n)) (\(:::: : nat) -> logic.eq (Set) (le a (plus a (plus x n))) (le a (plus a ::::)))) (((logic.refl) (Set)) (le a (plus a (plus x n))))) (plus n x)) (((commutative::plus) (n)) (x)))) (plus n (plus a x))) (((((((logic.rewrite::l) (nat)) (plus (plus a n) x)) (\(:::: : nat) -> logic.eq (nat) (plus n (plus a x)) ::::)) ((((assoc::plus1) (x)) (a)) (n))) (plus a (plus n x))) ((((associative::plus) (a)) (n)) (x))))) (plus (plus a x) n)) (((commutative::plus) (plus a x)) (n)))))) (((((((logic.rewrite::r) (nat)) (plus a (plus x (S n)))) (\(:::: : nat) -> logic.eq (Set) (le (S a) (S (plus (plus a x) n))) (le (S a) ::::))) (((((((logic.rewrite::r) (nat)) (plus (plus a x) (S n))) (\(:::: : nat) -> logic.eq (Set) (le (S a) ::::) (le (S a) (plus a (plus x (S n)))))) (((((((logic.rewrite::r) (nat)) (plus a (plus x (S n)))) (\(:::: : nat) -> logic.eq (Set) (le (S a) ::::) (le (S a) (plus a (plus x (S n)))))) (((logic.refl) (Set)) (le (S a) (plus a (plus x (S n)))))) (plus (plus a x) (S n))) ((((associative::plus) (a)) (x)) (S n)))) (S (plus (plus a x) n))) (((plus::n::Sm) (plus a x)) (n)))) (plus (plus a x) (S n))) ((((associative::plus) (a)) (x)) (S n)))

not::le::Sn::O : _
not::le::Sn::O = \(n : nat) -> ((connectives.nmk) (le (S n) O)) (\(Hlen0 : le (S n) O) -> ((((((eq::match::nat::type::O) (Set)) (connectives.False)) (\(p : nat) -> connectives.True)) (\(y : Set) -> y)) ((((lt::to::not::zero) (n)) (O)) (Hlen0))))

not::le::to::not::le::S::S : _
not::le::to::not::le::S::S = \(n : nat) -> \(m : nat) -> \(auto : connectives.Not (le n m)) -> (((((logic.not::to::not) (le (S n) (S m))) (le n m)) (\(auto' : le (S n) (S m)) -> (((((logic.eq::coerc) (le (pred (S n)) (pred (S m)))) (le n m)) ((((monotonic::pred) (S n)) (S m)) (auto'))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le :::: (pred (S m))) (le n m))) (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (Set) (le n ::::) (le n m))) (((logic.refl) (Set)) (le n m))) (pred (S m))) ((pred::Sn) (m)))) (pred (S n))) ((pred::Sn) (n)))))) (auto))

not::le::S::S::to::not::le : _
not::le::S::S::to::not::le = \(n : nat) -> \(m : nat) -> \(auto : connectives.Not (le (S n) (S m))) -> (((((logic.not::to::not) (le n m)) (le (S n) (S m))) (\(auto' : le n m) -> ((((le::S::S) (n)) (m)) (auto')))) (auto))

not::le::Sn::n : _
not::le::Sn::n = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> connectives.Not (le (S ::x::365) ::x::365))) ((not::le::Sn::O) (O))) (\(x::366 : nat) -> \(::x::368 : connectives.Not (le (S x::366) x::366)) -> ((((not::le::to::not::le::S::S) (S x::366)) (x::366)) (::x::368)))) (n)

lt::to::not::le : _
lt::to::not::le = \(n : nat) -> \(m : nat) -> \(Hltnm : lt n m) -> (((((((le::ind) (S n)) (\(x::417 : nat) -> connectives.Not (le x::417 n))) ((not::le::Sn::n) (n))) (\(m0 : nat) -> \(::x::419 : le (S n) m0) -> (\(::x::421 : connectives.Not (le m0 n)) -> (((((logic.not::to::not) (le (S m0) n)) (le m0 n)) (\(auto : le (S m0) n) -> ((((lt::to::le) (m0)) (n)) (auto)))) (::x::421))))) (m)) (Hltnm))

not::le::to::lt : _
not::le::to::lt = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> (connectives.Not (le :::: ::0)) -> lt ::0 ::::)) (\(n : nat) -> \(abs : connectives.Not (le O n)) -> (((connectives.falsity) (lt n O)) ((((logic.absurd) (le O n)) (((((logic.eq::coerc) (le O (plus n O))) (le O n)) (((le::plus::n) (n)) (O))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le O ::::) (le O n))) (((logic.refl) (Set)) (le O n))) (plus n O)) ((plus::n::O) (n))))) (abs))))) (\(n : nat) -> \(auto : connectives.Not (le (S n) O)) -> ((lt::O::S) (n)))) (\(n : nat) -> \(m : nat) -> \(Hind : (connectives.Not (le n m)) -> lt m n) -> (\(HnotleSS : connectives.Not (le (S n) (S m))) -> ((((le::S::S) (S m)) (n)) ((Hind) ((((not::le::S::S::to::not::le) (n)) (m)) (HnotleSS))))))

not::lt::to::le : _
not::lt::to::le = \(n : nat) -> \(m : nat) -> \(H : connectives.Not (lt n m)) -> ((((le::S::S::to::le) (m)) (n)) ((((not::le::to::lt) (S n)) (m)) (((((logic.not::to::not) (le (S n) m)) (lt n m)) (\(auto : le (S n) m) -> (auto))) (H))))

le::to::not::lt : _
le::to::not::lt = \(n : nat) -> \(m : nat) -> \(H : le n m) -> ((((lt::to::not::le) (n)) (S m)) ((((((le::to::lt::to::lt) (n)) (m)) (S m)) (H)) (((((logic.eq::coerc) (le (S m) (plus O (S m)))) (le (S m) (S m))) (((le::plus::n) (O)) (S m))) (((((((logic.rewrite::l) (nat)) (S m)) (\(:::: : nat) -> logic.eq (Set) (le (S m) ::::) (le (S m) (S m)))) (((logic.refl) (Set)) (le (S m) (S m)))) (plus O (S m))) ((plus::O::n) (S m))))))

decidable::le : _
decidable::le = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> logic.decidable (le :::: ::0))) (\(n : nat) -> (((connectives.or::introl) (le O n)) (connectives.Not (le O n))) ((le::O::n) (n)))) (\(n : nat) -> (((connectives.or::intror) (le (S n) O)) (connectives.Not (le (S n) O))) ((not::le::Sn::O) (n)))) (\(n : nat) -> \(m : nat) -> \(::clearme : logic.decidable (le n m)) -> (((((((connectives.match::Or::prop) (le n m)) (connectives.Not (le n m))) (logic.decidable (le (S n) (S m)))) (\(auto : le n m) -> ((((connectives.or::introl) (le (S n) (S m))) (connectives.Not (le (S n) (S m)))) ((((le::S::S) (n)) (m)) (auto))))) (\(auto : connectives.Not (le n m)) -> ((((connectives.or::intror) (le (S n) (S m))) (connectives.Not (le (S n) (S m)))) ((((not::le::to::not::le::S::S) (n)) (m)) (auto))))) (::clearme)))

decidable::lt : _
decidable::lt = \(n : nat) -> \(m : nat) -> ((decidable::le) (S n)) (m)

le::to::or::lt::eq : _
le::to::or::lt::eq = \(n : nat) -> \(m : nat) -> \(lenm : le n m) -> (((((((le::ind) (n)) (\(x::417 : nat) -> connectives.Or (lt n x::417) (logic.eq (nat) n x::417))) ((((relations.RC::reflexive) (nat)) (lt)) (n))) (\(m0 : nat) -> \(::x::419 : le n m0) -> (\(::x::421 : connectives.Or (lt n m0) (logic.eq (nat) n m0)) -> ((((connectives.or::introl) (lt n (S m0))) (logic.eq (nat) n (S m0))) ((((((le::to::lt::to::lt) (n)) (m0)) (S m0)) (::x::419)) (((((logic.eq::coerc) (le (S m0) (plus O (S m0)))) (le (S m0) (S m0))) (((le::plus::n) (O)) (S m0))) (((((((logic.rewrite::l) (nat)) (S m0)) (\(:::: : nat) -> logic.eq (Set) (le (S m0) ::::) (le (S m0) (S m0)))) (((logic.refl) (Set)) (le (S m0) (S m0)))) (plus O (S m0))) ((plus::O::n) (S m0))))))))) (m)) (lenm))

lt::O::n::elim : _
lt::O::n::elim = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> (lt O ::x::365) -> forall (P : (nat -> Set)) -> (forall (m : nat) -> P (S m)) -> P ::x::365)) (\(abs : lt O O) -> (((connectives.falsity) (forall (P : (nat -> Set)) -> (forall (m : nat) -> P (S m)) -> P O)) ((((logic.absurd) (le (S O) O)) (abs)) ((not::le::Sn::O) (O)))))) (\(x::366 : nat) -> \(::x::368 : (lt O x::366) -> forall (P : (nat -> Set)) -> (forall (m : nat) -> P (S m)) -> P x::366) -> (\(auto : lt O (S x::366)) -> (\(P : nat -> Set) -> \(auto' : forall (m : nat) -> P (S m)) -> ((auto') (x::366)))))) (n)

le::n::O::elim : _
le::n::O::elim = \(n : nat) -> ((((match::nat::prop) (\(:::: : nat) -> (le :::: O) -> forall (P : (nat -> Set)) -> (P O) -> P ::::)) (\(auto : le O O) -> (\(P : nat -> Set) -> \(auto' : P O) -> (auto')))) (\(a : nat) -> \(abs : le (S a) O) -> (((connectives.falsity) (forall (P : (nat -> Set)) -> (P O) -> P (S a))) ((((logic.absurd) (le (S a) O)) (abs)) ((not::le::Sn::O) (a)))))) (n)

lt::to::not::eq : _
lt::to::not::eq = \(n : nat) -> \(m : nat) -> \(H : lt n m) -> (((((logic.not::to::not) (logic.eq (nat) n m)) (connectives.False)) (\(auto : logic.eq (nat) n m) -> ((((logic.absurd) (le (S n) n)) (((((logic.eq::coerc) (le (S n) m)) (le (S n) n)) (H)) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le (S n) ::::) (le (S n) n))) (((logic.refl) (Set)) (le (S n) n))) (m)) (auto)))) ((not::le::Sn::n) (n))))) (((connectives.nmk) (connectives.False)) (\(auto : connectives.False) -> (auto))))

le::n::O::to::eq : _
le::n::O::to::eq = \(n : nat) -> ((((match::nat::prop) (\(:::: : nat) -> (le :::: O) -> logic.eq (nat) O ::::)) (\(auto : le O O) -> (((logic.refl) (nat)) (O)))) (\(a : nat) -> \(abs : le (S a) O) -> (((connectives.falsity) (logic.eq (nat) O (S a))) ((((logic.absurd) (le (S a) O)) (abs)) ((not::le::Sn::O) (a)))))) (n)

le::to::le::to::eq : _
le::to::le::to::eq = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> (le :::: ::0) -> (le ::0 ::::) -> logic.eq (nat) :::: ::0)) (\(n : nat) -> \(auto : le O n) -> (\(auto' : le n O) -> (((((logic.sym::eq) (nat)) (n)) (O)) (((((logic.sym::eq) (nat)) (O)) (n)) (((((logic.eq::coerc) (logic.eq (nat) O n)) (logic.eq (nat) O n)) (((le::n::O::to::eq) (n)) (auto'))) (((logic.refl) (Set)) (logic.eq (nat) O n)))))))) (\(n : nat) -> \(auto : le (S n) O) -> (\(auto' : le O (S n)) -> (((((logic.sym::eq) (nat)) (O)) (S n)) (((le::n::O::to::eq) (S n)) (auto)))))) (\(n : nat) -> \(m : nat) -> \(auto : (le n m) -> (le m n) -> logic.eq (nat) n m) -> (\(auto' : le (S n) (S m)) -> (\(auto'' : le (S m) (S n)) -> (((((((logic.eq::f) (nat)) (nat)) (S)) (n)) (m)) (((auto) (((((logic.eq::coerc) (le (pred (S n)) (pred (S m)))) (le n m)) ((((monotonic::pred) (S n)) (S m)) (auto'))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le :::: (pred (S m))) (le n m))) (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (Set) (le n ::::) (le n m))) (((logic.refl) (Set)) (le n m))) (pred (S m))) ((pred::Sn) (m)))) (pred (S n))) ((pred::Sn) (n))))) (((((logic.eq::coerc) (le (pred (S m)) (pred (S n)))) (le m n)) ((((monotonic::pred) (S m)) (S n)) (auto''))) (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (Set) (le :::: (pred (S n))) (le m n))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le m ::::) (le m n))) (((logic.refl) (Set)) (le m n))) (pred (S n))) ((pred::Sn) (n)))) (pred (S m))) ((pred::Sn) (m)))))))))

plus::minus : _
plus::minus = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> forall (p : nat) -> (le :::: ::0) -> logic.eq (nat) (plus (minus ::0 ::::) p) (minus (plus ::0 p) ::::))) (\(n : nat) -> \(p : nat) -> \(auto : le O n) -> (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) (plus :::: p) (minus (plus n p) O))) (((((((logic.rewrite::l) (nat)) (plus n p)) (\(:::: : nat) -> logic.eq (nat) (plus n p) ::::)) (((logic.refl) (nat)) (plus n p))) (minus (plus n p) O)) ((minus::n::O) (plus n p)))) (minus n O)) ((minus::n::O) (n))))) (\(n : nat) -> \(p : nat) -> \(abs : le (S n) O) -> (((connectives.falsity) (logic.eq (nat) (plus (minus O (S n)) p) (minus (plus O p) (S n)))) ((((logic.absurd) (le (S n) O)) (abs)) ((not::le::Sn::O) (n)))))) (\(n : nat) -> \(m : nat) -> (((sym::eq::minus) (S m)) (\(y : (nat -> nat)) -> (forall (p : nat) -> (le n m) -> logic.eq (nat) (plus (minus m n) p) (minus (plus m p) n)) -> forall (p : nat) -> (le (S n) (S m)) -> logic.eq (nat) (plus (y (S n)) p) (minus (plus (S m) p) (S n)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (m)) (\(y : (nat -> nat)) -> (forall (p : nat) -> (le n m) -> logic.eq (nat) (plus (minus m n) p) (minus (plus m p) n)) -> forall (p : nat) -> (le (S n) (S m)) -> logic.eq (nat) (plus (y (S n)) p) (minus (plus (S m) p) (S n)))) ((((sym::eq::minus::body::S) (m)) (\(y : (nat -> nat)) -> (forall (p : nat) -> (le n m) -> logic.eq (nat) (plus (minus m n) p) (minus (plus m p) n)) -> forall (p : nat) -> (le (S n) (S m)) -> logic.eq (nat) (plus (y (S n)) p) (minus (plus (S m) p) (S n)))) (\(auto : forall (p : nat) -> (le n m) -> logic.eq (nat) (plus (minus m n) p) (minus (plus m p) n)) -> (\(p : nat) -> ((((((sym::eq::match::nat::type::S) (nat)) (S m)) (\(q : nat) -> minus m q)) (n)) (\(y : nat) -> (le (S n) (S m)) -> logic.eq (nat) (plus y p) (minus (plus (S m) p) (S n)))) ((((sym::eq::minus) (plus (S m) p)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (y (S n)))) ((((sym::eq::plus) (S m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (filter::nat::type (nat -> nat) minus::body (y p) (S n)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (filter::nat::type (nat -> nat) minus::body (y p) (S n)))) ((((sym::eq::plus::body::S) (m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (filter::nat::type (nat -> nat) minus::body (y p) (S n)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (plus m p)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (y (S n)))) ((((eq::plus::body::S) (m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (minus::body (y p) (S n)))) ((((((eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (minus::body (y p) (S n)))) ((((eq::plus) (S m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (minus::body (y p) (S n)))) ((((sym::eq::plus) (S m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (minus::body (y p) (S n)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (plus::body)) (m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (minus::body (y p) (S n)))) ((((sym::eq::plus::body::S) (m)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (minus::body (y p) (S n)))) ((((sym::eq::minus::body::S) (plus m p)) (\(y : (nat -> nat)) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) (y (S n)))) (((((((sym::eq::match::nat::type::S) (nat)) (S (plus m p))) (\(q : nat) -> minus (plus m p) q)) (n)) (\(y : nat) -> (le (S n) (S m)) -> logic.eq (nat) (plus (minus m n) p) y)) (\(auto' : le (S n) (S m)) -> (((auto) (p)) (((((logic.eq::coerc) (le (pred (S n)) (pred (S m)))) (le n m)) ((((monotonic::pred) (S n)) (S m)) (auto'))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (le :::: (pred (S m))) (le n m))) (((((((logic.rewrite::l) (nat)) (m)) (\(:::: : nat) -> logic.eq (Set) (le n ::::) (le n m))) (((logic.refl) (Set)) (le n m))) (pred (S m))) ((pred::Sn) (m)))) (pred (S n))) ((pred::Sn) (n))))))))))))))))))))))))

minus::plus::m::m : _
minus::plus::m::m = \(n : nat) -> \(m : nat) -> ((((logic.eq::coerc) (logic.eq (nat) (plus (minus m m) n) (minus (plus m n) m))) (logic.eq (nat) n (minus (plus n m) m))) (((((plus::minus) (m)) (m)) (n)) ((le::n) (m)))) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) (plus :::: n) (minus (plus m n) m)) (logic.eq (nat) n (minus (plus n m) m)))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) :::: (minus (plus m n) m)) (logic.eq (nat) n (minus (plus n m) m)))) (((((((logic.rewrite::r) (nat)) (plus n m)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) n (minus :::: m)) (logic.eq (nat) n (minus (plus n m) m)))) (((logic.refl) (Set)) (logic.eq (nat) n (minus (plus n m) m)))) (plus m n)) (((commutative::plus) (m)) (n)))) (plus O n)) ((plus::O::n) (n)))) (minus m m)) ((minus::n::n) (m)))

plus::minus::m::m : _
plus::minus::m::m = \(n : nat) -> \(m : nat) -> \(lemn : le m n) -> (((((logic.sym::eq) (nat)) (plus (minus n m) m)) (n)) (((((logic.eq::coerc) (logic.eq (nat) (plus (minus n m) m) (minus (plus n m) m))) (logic.eq (nat) (plus (minus n m) m) n)) (((((plus::minus) (m)) (n)) (m)) (lemn))) (((((((logic.rewrite::r) (nat)) (plus m (minus n m))) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) (plus (minus n m) m) (minus (plus n m) m)) (logic.eq (nat) :::: n))) (((((((logic.rewrite::r) (nat)) (plus m (minus n m))) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) :::: (minus (plus n m) m)) (logic.eq (nat) (plus m (minus n m)) n))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) (plus m (minus n m)) ::::) (logic.eq (nat) (plus m (minus n m)) n))) (((logic.refl) (Set)) (logic.eq (nat) (plus m (minus n m)) n))) (minus (plus n m) m)) (((minus::plus::m::m) (n)) (m)))) (plus (minus n m) m)) (((commutative::plus) (minus n m)) (m)))) (plus (minus n m) m)) (((commutative::plus) (minus n m)) (m)))))

minus::to::plus : _
minus::to::plus = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(lemn : le m n) -> (\(eqp : logic.eq (nat) (minus n m) p) -> (((((logic.eq::coerc) (logic.eq (nat) n (plus (minus n m) m))) (logic.eq (nat) n (plus m p))) ((((plus::minus::m::m) (n)) (m)) (lemn))) (((((((logic.rewrite::r) (nat)) (plus m (minus n m))) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) n ::::) (logic.eq (nat) n (plus m p)))) (((((((logic.rewrite::r) (nat)) (p)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) n (plus m ::::)) (logic.eq (nat) n (plus m p)))) (((logic.refl) (Set)) (logic.eq (nat) n (plus m p)))) (minus n m)) (eqp))) (plus (minus n m) m)) (((commutative::plus) (minus n m)) (m)))))

plus::to::minus : _
plus::to::minus = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(eqp : logic.eq (nat) n (plus m p)) -> (((((logic.sym::eq) (nat)) (p)) (minus n m)) (((((logic.eq::coerc) (logic.eq (nat) p (minus (plus p m) m))) (logic.eq (nat) p (minus n m))) (((minus::plus::m::m) (p)) (m))) (((((((logic.rewrite::r) (nat)) (plus m p)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) p (minus :::: m)) (logic.eq (nat) p (minus n m)))) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) p (minus :::: m)) (logic.eq (nat) p (minus n m)))) (((logic.refl) (Set)) (logic.eq (nat) p (minus n m)))) (plus m p)) (eqp))) (plus p m)) (((commutative::plus) (p)) (m)))))

monotonic::le::minus::l : _
monotonic::le::minus::l = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> forall (n : nat) -> (le ::0 ::::) -> le (minus ::0 n) (minus :::: n))) (\(p : nat) -> \(q : nat) -> \(lePO : le p O) -> (((((le::n::O::elim) (p)) (lePO)) (\(:::: : nat) -> le (minus :::: q) (minus O q))) ((le::n) (minus O q))))) (\(p : nat) -> \(q : nat) -> (((sym::eq::minus) (S p)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (y q))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (p)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (y q))) ((((sym::eq::minus::body::S) (p)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (y q))) (((eq::plus::body::O) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (y (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) (((((eq::filter::nat::type::O) (nat -> nat)) (plus::body)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (y (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) ((((eq::plus) (O)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (y (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) (((eq::minus::body::O) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (plus (y (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) (((((eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (plus (y (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) ((((eq::minus) (O)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (plus (y (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) (((eq::minus::body::O) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (plus (minus (y q) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) (((((eq::filter::nat::type::O) (nat -> nat)) (minus::body)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (plus (minus (y q) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) ((((eq::minus) (O)) (\(y : (nat -> nat)) -> (le O (S p)) -> le (minus O q) (plus (minus (y q) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))) (\(auto : le O (S p)) -> (((le::plus::minus::m::m) (minus O q)) (match::nat::type (nat) (S p) (\(q0 : nat) -> minus p q0) q)))))))))))))))) (\(p : nat) -> \(q : nat) -> \(Hind : forall (n0 : nat) -> (le q p) -> le (minus q n0) (minus p n0)) -> (\(n : nat) -> ((((match::nat::prop) (\(:::: : nat) -> (le (S q) (S p)) -> le (minus (S q) ::::) (minus (S p) ::::))) ((((sym::eq::minus) (S q)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (y O) (minus (S p) O))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (q)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (y O) (minus (S p) O))) ((((sym::eq::minus::body::S) (q)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (y O) (minus (S p) O))) ((((((sym::eq::match::nat::type::O) (nat)) (S q)) (\(z : nat) -> minus q z)) (\(y : nat) -> (le (S q) (S p)) -> le y (minus (S p) O))) ((((sym::eq::minus) (S p)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (S q) (y O))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (p)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (S q) (y O))) ((((sym::eq::minus::body::S) (p)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (S q) (y O))) ((((((sym::eq::match::nat::type::O) (nat)) (S p)) (\(q0 : nat) -> minus p q0)) (\(y : nat) -> (le (S q) (S p)) -> le (S q) y)) (\(auto : le (S q) (S p)) -> (auto))))))))))) ((((sym::eq::minus) (S q)) (\(y : (nat -> nat)) -> forall (a : nat) -> (le (S q) (S p)) -> le (y (S a)) (minus (S p) (S a)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (q)) (\(y : (nat -> nat)) -> forall (a : nat) -> (le (S q) (S p)) -> le (y (S a)) (minus (S p) (S a)))) ((((sym::eq::minus::body::S) (q)) (\(y : (nat -> nat)) -> forall (a : nat) -> (le (S q) (S p)) -> le (y (S a)) (minus (S p) (S a)))) (\(a : nat) -> ((((((sym::eq::match::nat::type::S) (nat)) (S q)) (\(z : nat) -> minus q z)) (a)) (\(y : nat) -> (le (S q) (S p)) -> le y (minus (S p) (S a)))) ((((sym::eq::minus) (S p)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (minus q a) (y (S a)))) ((((((sym::eq::filter::nat::type::S) (nat -> nat)) (minus::body)) (p)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (minus q a) (y (S a)))) ((((sym::eq::minus::body::S) (p)) (\(y : (nat -> nat)) -> (le (S q) (S p)) -> le (minus q a) (y (S a)))) (((((((sym::eq::match::nat::type::S) (nat)) (S p)) (\(q0 : nat) -> minus p q0)) (a)) (\(y : nat) -> (le (S q) (S p)) -> le (minus q a) y)) (\(leSS : le (S q) (S p)) -> (((Hind) (a)) (((((logic.eq::coerc) (le (pred (S q)) (pred (S p)))) (le q p)) ((((monotonic::pred) (S q)) (S p)) (leSS))) (((((((logic.rewrite::l) (nat)) (q)) (\(:::: : nat) -> logic.eq (Set) (le :::: (pred (S p))) (le q p))) (((((((logic.rewrite::l) (nat)) (p)) (\(:::: : nat) -> logic.eq (Set) (le q ::::) (le q p))) (((logic.refl) (Set)) (le q p))) (pred (S p))) ((pred::Sn) (p)))) (pred (S q))) ((pred::Sn) (q))))))))))))))) (n)))

le::plus::to::minus : _
le::plus::to::minus = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(lep : le n (plus p m)) -> (((((logic.eq::coerc) (le (minus n m) (minus (plus p m) m))) (le (minus n m) p)) (((((monotonic::le::minus::l) (plus p m)) (n)) (m)) (lep))) (((((((logic.rewrite::l) (nat)) (p)) (\(:::: : nat) -> logic.eq (Set) (le (minus n m) ::::) (le (minus n m) p))) (((logic.refl) (Set)) (le (minus n m) p))) (minus (plus p m) m)) (((minus::plus::m::m) (p)) (m))))

monotonic::le::minus::r : _
monotonic::le::minus::r = \(p : nat) -> \(q : nat) -> \(n : nat) -> \(lepq : le q p) -> (((((le::plus::to::minus) (n)) (p)) (minus n q)) ((((((transitive::le) (n)) (plus (minus n q) q)) (plus (minus n q) p)) (((le::plus::minus::m::m) (n)) (q))) (((((monotonic::le::plus::r) (minus n q)) (q)) (p)) (lepq))))

minus::le : _
minus::le = \(x : nat) -> \(y : nat) -> ((((logic.eq::coerc) (le (minus x y) (minus (plus x y) y))) (le (minus x y) x)) (((((monotonic::le::minus::l) (plus x y)) (x)) (y)) (((le::plus::n::r) (y)) (x)))) (((((((logic.rewrite::l) (nat)) (x)) (\(:::: : nat) -> logic.eq (Set) (le (minus x y) ::::) (le (minus x y) x))) (((logic.refl) (Set)) (le (minus x y) x))) (minus (plus x y) y)) (((minus::plus::m::m) (x)) (y)))

not::eq::to::le::to::lt : _
not::eq::to::le::to::lt = \(n : nat) -> \(m : nat) -> \(Hneq : connectives.Not (logic.eq (nat) n m)) -> (\(Hle : le n m) -> (((((((connectives.match::Or::prop) (lt n m)) (logic.eq (nat) n m)) (lt n m)) (\(auto : lt n m) -> (auto))) (\(Heq : logic.eq (nat) n m) -> ((((not::le::to::lt) (m)) (n)) (((((logic.not::to::not) (le m n)) (logic.eq (nat) n m)) (\(auto : le m n) -> (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) n ::::)) (((logic.refl) (nat)) (n))) (m)) (Heq)))) (Hneq))))) ((((le::to::or::lt::eq) (n)) (m)) (Hle))))

eq::minus::O : _
eq::minus::O = \(n : nat) -> \(m : nat) -> \(lenm : le n m) -> (((((le::n::O::elim) (minus n m)) (((((logic.eq::coerc) (le (minus n m) (minus n n))) (le (minus n m) O)) (((((monotonic::le::minus::r) (m)) (n)) (n)) (lenm))) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (Set) (le (minus n m) ::::) (le (minus n m) O))) (((logic.refl) (Set)) (le (minus n m) O))) (minus n n)) ((minus::n::n) (n))))) (\(:::: : nat) -> logic.eq (nat) :::: O)) (((logic.refl) (nat)) (O)))

distributive::times::minus : _
distributive::times::minus = \(a : nat) -> \(b : nat) -> \(c : nat) -> ((((((connectives.match::Or::prop) (lt b c)) (connectives.Not (lt b c))) (logic.eq (nat) (times a (minus b c)) (minus (times a b) (times a c)))) (\(Hbc : lt b c) -> (((((((logic.eq::ind::r) (nat)) (O)) (\(x : nat) -> logic.eq (nat) (times a x) (minus (times a b) (times a c)))) (((((((logic.eq::ind::r) (nat)) (O)) (\(x : nat) -> logic.eq (nat) (times a O) x)) (((((((logic.rewrite::l) (nat)) (O)) (\(:::: : nat) -> logic.eq (nat) :::: O)) (((logic.refl) (nat)) (O))) (times a O)) ((times::n::O) (a)))) (minus (times a b) (times a c))) ((((eq::minus::O) (times a b)) (times a c)) (((((monotonic::le::times::r) (a)) (b)) (c)) ((((lt::to::le) (b)) (c)) (Hbc)))))) (minus b c)) ((((eq::minus::O) (b)) (c)) ((((lt::to::le) (b)) (c)) (Hbc)))))) (\(Hbc : connectives.Not (lt b c)) -> (((((logic.sym::eq) (nat)) (minus (times a b) (times a c))) (times a (minus b c))) (((((logic.eq::coerc) (logic.eq (nat) (minus (times a b) (times a c)) (times a (minus b c)))) (logic.eq (nat) (minus (times a b) (times a c)) (times a (minus b c)))) (((((plus::to::minus) (times a b)) (times a c)) (times a (minus b c))) (((((((logic.eq::ind) (nat)) (times a (plus c (minus b c)))) (\(x::1 : nat) -> logic.eq (nat) (times a b) x::1)) (((((((logic.eq::f) (nat)) (nat)) (times a)) (b)) (plus c (minus b c))) (((((logic.eq::coerc) (logic.eq (nat) b (plus (minus b c) c))) (logic.eq (nat) b (plus c (minus b c)))) ((((plus::minus::m::m) (b)) (c)) ((((not::lt::to::le) (b)) (c)) (Hbc)))) (((((((logic.rewrite::r) (nat)) (plus c (minus b c))) (\(:::: : nat) -> logic.eq (Set) (logic.eq (nat) b ::::) (logic.eq (nat) b (plus c (minus b c))))) (((logic.refl) (Set)) (logic.eq (nat) b (plus c (minus b c))))) (plus (minus b c) c)) (((commutative::plus) (minus b c)) (c)))))) (plus (times a c) (times a (minus b c)))) ((((distributive::times::plus) (a)) (c)) (minus b c))))) (((logic.refl) (Set)) (logic.eq (nat) (minus (times a b) (times a c)) (times a (minus b c)))))))) (((decidable::lt) (b)) (c))

minus::plus : _
minus::plus = \(n : nat) -> \(m : nat) -> \(p : nat) -> ((((((connectives.match::Or::prop) (le (plus m p) n)) (connectives.Not (le (plus m p) n))) (logic.eq (nat) (minus (minus n m) p) (minus n (plus m p)))) (\(Hlt : le (plus m p) n) -> (((((plus::to::minus) (minus n m)) (p)) (minus n (plus m p))) (((((plus::to::minus) (n)) (m)) (plus p (minus n (plus m p)))) (((((((logic.eq::ind) (nat)) (plus (plus m p) (minus n (plus m p)))) (\(x::1 : nat) -> logic.eq (nat) n x::1)) ((((((minus::to::plus) (n)) (plus m p)) (minus n (plus m p))) (Hlt)) (((logic.refl) (nat)) (minus n (plus m p))))) (plus m (plus p (minus n (plus m p))))) ((((associative::plus) (m)) (p)) (minus n (plus m p)))))))) (\(Hlt : connectives.Not (le (plus m p) n)) -> (((((((logic.eq::ind::r) (nat)) (O)) (\(x : nat) -> logic.eq (nat) x (minus n (plus m p)))) (((((logic.sym::eq) (nat)) (minus n (plus m p))) (O)) (((((logic.eq::coerc) (logic.eq (nat) (minus n (plus m p)) O)) (logic.eq (nat) (minus n (plus m p)) O)) ((((eq::minus::O) (n)) (plus m p)) ((((((transitive::le) (n)) (S n)) (plus m p)) ((le::n::Sn) (n))) ((((not::le::to::lt) (plus m p)) (n)) (Hlt))))) (((logic.refl) (Set)) (logic.eq (nat) (minus n (plus m p)) O))))) (minus (minus n m) p)) ((((eq::minus::O) (minus n m)) (p)) (((((logic.eq::coerc) (le (minus n m) (minus (plus p m) m))) (le (minus n m) p)) (((((monotonic::le::minus::l) (plus p m)) (n)) (m)) (((((logic.eq::coerc) (le n (plus m p))) (le n (plus p m))) ((((((transitive::le) (n)) (S n)) (plus m p)) ((le::n::Sn) (n))) ((((not::le::to::lt) (plus m p)) (n)) (Hlt)))) (((((((logic.rewrite::r) (nat)) (plus m p)) (\(:::: : nat) -> logic.eq (Set) (le n (plus m p)) (le n ::::))) (((logic.refl) (Set)) (le n (plus m p)))) (plus p m)) (((commutative::plus) (p)) (m)))))) (((((((logic.rewrite::l) (nat)) (p)) (\(:::: : nat) -> logic.eq (Set) (le (minus n m) ::::) (le (minus n m) p))) (((logic.refl) (Set)) (le (minus n m) p))) (minus (plus p m) m)) (((minus::plus::m::m) (p)) (m)))))))) (((decidable::le) (plus m p)) (n))

minus::minus : _
minus::minus = \(n : nat) -> \(m : nat) -> \(p : nat) -> \(lepm : le p m) -> (\(lemn : le m n) -> (((((logic.sym::eq) (nat)) (minus n (minus m p))) (plus p (minus n m))) (((((plus::to::minus) (n)) (minus m p)) (plus p (minus n m))) (((((((logic.eq::ind) (nat)) (plus (plus (minus m p) p) (minus n m))) (\(x::1 : nat) -> logic.eq (nat) n x::1)) (((((((logic.eq::ind) (nat)) (m)) (\(x::1 : nat) -> logic.eq (nat) n (plus x::1 (minus n m)))) (((((((logic.eq::ind) (nat)) (plus (minus n m) m)) (\(x::1 : nat) -> logic.eq (nat) n x::1)) (((((((logic.eq::ind) (nat)) (n)) (\(x::1 : nat) -> logic.eq (nat) n x::1)) (((logic.refl) (nat)) (n))) (plus (minus n m) m)) ((((plus::minus::m::m) (n)) (m)) (lemn)))) (plus m (minus n m))) (((commutative::plus) (minus n m)) (m)))) (plus (minus m p) p)) ((((plus::minus::m::m) (m)) (p)) (lepm)))) (plus (minus m p) (plus p (minus n m)))) ((((associative::plus) (minus m p)) (p)) (minus n m))))))

minus::minus::comm : _
minus::minus::comm = \(a : nat) -> \(b : nat) -> \(c : nat) -> ((((le::to::le::to::eq) (minus (minus a b) c)) (minus (minus a c) b)) (((((logic.eq::coerc) (le (minus (minus a b) c) (minus (plus (minus (minus a c) b) c) c))) (le (minus (minus a b) c) (minus (minus a c) b))) (((((monotonic::le::minus::l) (plus (minus (minus a c) b) c)) (minus a b)) (c)) (((((logic.eq::coerc) (le (minus a b) (plus (minus (minus a b) c) c))) (le (minus a b) (plus (minus (minus a c) b) c))) (((le::plus::minus::m::m) (minus a b)) (c))) (((((((logic.rewrite::r) (nat)) (minus a (plus b c))) (\(:::: : nat) -> logic.eq (Set) (le (minus a b) (plus :::: c)) (le (minus a b) (plus (minus (minus a c) b) c)))) (((((((logic.rewrite::r) (nat)) (plus c (minus a (plus b c)))) (\(:::: : nat) -> logic.eq (Set) (le (minus a b) ::::) (le (minus a b) (plus (minus (minus a c) b) c)))) (((((((logic.rewrite::r) (nat)) (plus c (minus (minus a c) b))) (\(:::: : nat) -> logic.eq (Set) (le (minus a b) (plus c (minus a (plus b c)))) (le (minus a b) ::::))) (((((((logic.rewrite::l) (nat)) (minus (minus a c) b)) (\(:::: : nat) -> logic.eq (Set) (le (minus a b) (plus c ::::)) (le (minus a b) (plus c (minus (minus a c) b))))) (((logic.refl) (Set)) (le (minus a b) (plus c (minus (minus a c) b))))) (minus a (plus b c))) (((((((logic.rewrite::l) (nat)) (plus c b)) (\(:::: : nat) -> logic.eq (nat) (minus (minus a c) b) (minus a ::::))) ((((minus::plus) (a)) (c)) (b))) (plus b c)) (((commutative::plus) (c)) (b))))) (plus (minus (minus a c) b) c)) (((commutative::plus) (minus (minus a c) b)) (c)))) (plus (minus a (plus b c)) c)) (((commutative::plus) (minus a (plus b c))) (c)))) (minus (minus a b) c)) ((((minus::plus) (a)) (b)) (c)))))) (((((((logic.rewrite::l) (nat)) (minus (minus a c) b)) (\(:::: : nat) -> logic.eq (Set) (le (minus (minus a b) c) ::::) (le (minus (minus a b) c) (minus (minus a c) b)))) (((logic.refl) (Set)) (le (minus (minus a b) c) (minus (minus a c) b)))) (minus (plus (minus (minus a c) b) c) c)) (((minus::plus::m::m) (minus (minus a c) b)) (c))))) (((((logic.eq::coerc) (le (minus (minus a c) b) (minus (plus (minus (minus a b) c) b) b))) (le (minus (minus a c) b) (minus (minus a b) c))) (((((monotonic::le::minus::l) (plus (minus (minus a b) c) b)) (minus a c)) (b)) (((((logic.eq::coerc) (le (minus a c) (plus (minus (minus a c) b) b))) (le (minus a c) (plus (minus (minus a b) c) b))) (((le::plus::minus::m::m) (minus a c)) (b))) (((((((logic.rewrite::r) (nat)) (minus a (plus c b))) (\(:::: : nat) -> logic.eq (Set) (le (minus a c) (plus :::: b)) (le (minus a c) (plus (minus (minus a b) c) b)))) (((((((logic.rewrite::r) (nat)) (plus b (minus a (plus c b)))) (\(:::: : nat) -> logic.eq (Set) (le (minus a c) ::::) (le (minus a c) (plus (minus (minus a b) c) b)))) (((((((logic.rewrite::r) (nat)) (plus b (minus (minus a b) c))) (\(:::: : nat) -> logic.eq (Set) (le (minus a c) (plus b (minus a (plus c b)))) (le (minus a c) ::::))) (((((((logic.rewrite::l) (nat)) (minus (minus a b) c)) (\(:::: : nat) -> logic.eq (Set) (le (minus a c) (plus b ::::)) (le (minus a c) (plus b (minus (minus a b) c))))) (((logic.refl) (Set)) (le (minus a c) (plus b (minus (minus a b) c))))) (minus a (plus c b))) (((((((logic.rewrite::l) (nat)) (plus b c)) (\(:::: : nat) -> logic.eq (nat) (minus (minus a b) c) (minus a ::::))) ((((minus::plus) (a)) (b)) (c))) (plus c b)) (((commutative::plus) (b)) (c))))) (plus (minus (minus a b) c) b)) (((commutative::plus) (minus (minus a b) c)) (b)))) (plus (minus a (plus c b)) b)) (((commutative::plus) (minus a (plus c b))) (b)))) (minus (minus a c) b)) ((((minus::plus) (a)) (c)) (b)))))) (((((((logic.rewrite::l) (nat)) (minus (minus a b) c)) (\(:::: : nat) -> logic.eq (Set) (le (minus (minus a c) b) ::::) (le (minus (minus a c) b) (minus (minus a b) c)))) (((logic.refl) (Set)) (le (minus (minus a c) b) (minus (minus a b) c)))) (minus (plus (minus (minus a b) c) b) b)) (((minus::plus::m::m) (minus (minus a b) c)) (b))))

minus::le::minus::minus::comm : _
minus::le::minus::minus::comm = \(b : nat) -> \(c : nat) -> \(a : nat) -> \(H : le c b) -> (((((((logic.eq::ind::r) (nat)) (plus (minus b c) c)) (\(x : nat) -> logic.eq (nat) (minus a (minus b c)) (minus (plus a c) x))) (((((((logic.rewrite::r) (nat)) (plus c a)) (\(:::: : nat) -> logic.eq (nat) (minus a (minus b c)) (minus :::: (plus (minus b c) c)))) (((((((logic.rewrite::r) (nat)) (plus c (minus b c))) (\(:::: : nat) -> logic.eq (nat) (minus a (minus b c)) (minus (plus c a) ::::))) (((((((logic.rewrite::l) (nat)) (minus (minus (plus c a) c) (minus b c))) (\(:::: : nat) -> logic.eq (nat) (minus a (minus b c)) ::::)) (((((((logic.rewrite::r) (nat)) (minus (plus c a) c)) (\(:::: : nat) -> logic.eq (nat) (minus :::: (minus b c)) (minus (minus (plus c a) c) (minus b c)))) (((logic.refl) (nat)) (minus (minus (plus c a) c) (minus b c)))) (a)) (((((((logic.rewrite::l) (nat)) (plus a c)) (\(:::: : nat) -> logic.eq (nat) a (minus :::: c))) (((minus::plus::m::m) (a)) (c))) (plus c a)) (((commutative::plus) (a)) (c))))) (minus (plus c a) (plus c (minus b c)))) ((((minus::plus) (plus c a)) (c)) (minus b c)))) (plus (minus b c) c)) (((commutative::plus) (minus b c)) (c)))) (plus a c)) (((commutative::plus) (a)) (c)))) (b)) ((((plus::minus::m::m) (b)) (c)) (H)))

minus::plus::plus::l : _
minus::plus::plus::l = \(x : nat) -> \(y : nat) -> \(h : nat) -> ((((((logic.rewrite::l) (nat)) (minus (minus (plus x h) y) h)) (\(:::: : nat) -> logic.eq (nat) :::: (minus x y))) (((((((logic.rewrite::r) (nat)) (minus x y)) (\(:::: : nat) -> logic.eq (nat) :::: (minus x y))) (((logic.refl) (nat)) (minus x y))) (minus (minus (plus x h) y) h)) (((((((logic.rewrite::r) (nat)) (minus (plus x h) h)) (\(:::: : nat) -> logic.eq (nat) (minus (minus (plus x h) y) h) (minus :::: y))) ((((minus::minus::comm) (plus x h)) (y)) (h))) (x)) (((minus::plus::m::m) (x)) (h))))) (minus (plus x h) (plus y h))) ((((minus::plus) (plus x h)) (y)) (h))

postulate eqb : nat -> nat -> bool.bool
postulate eqb::body : nat -> nat -> bool.bool
postulate axiom::eqb : forall (n : nat) -> connectives.equal (nat -> bool.bool) (eqb n) (filter::nat::type (nat -> bool.bool) eqb::body n)
eq::eqb : {i : Level} →  _
eq::eqb {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> bool.bool)) (eqb n)) (filter::nat::type (nat -> bool.bool) eqb::body n)) ((axiom::eqb) (n))

sym::eq::eqb : {i : Level} →  _
sym::eq::eqb {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> bool.bool)) (eqb n)) (filter::nat::type (nat -> bool.bool) eqb::body n)) ((eq::eqb) (n))

postulate axiom::eqb::body::O : connectives.equal (nat -> bool.bool) (eqb::body O) (\(m : nat) -> match::nat::type (bool.bool) bool.true (\(q : nat) -> bool.false) m)
eq::eqb::body::O : {i : Level} →  _
eq::eqb::body::O {i} = ((((connectives.equal::leibniz) {_} {i} (nat -> bool.bool)) (eqb::body O)) (\(m : nat) -> match::nat::type (bool.bool) bool.true (\(q : nat) -> bool.false) m)) (axiom::eqb::body::O)

sym::eq::eqb::body::O : {i : Level} →  _
sym::eq::eqb::body::O {i} = ((((leibniz.sym::leibniz) {_} {i} (nat -> bool.bool)) (eqb::body O)) (\(m : nat) -> match::nat::type (bool.bool) bool.true (\(q : nat) -> bool.false) m)) (eq::eqb::body::O)

postulate axiom::eqb::body::S : forall (n : nat) -> connectives.equal (nat -> bool.bool) (eqb::body (S n)) (\(m : nat) -> match::nat::type (bool.bool) bool.false (\(q : nat) -> eqb n q) m)
eq::eqb::body::S : {i : Level} →  _
eq::eqb::body::S {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> bool.bool)) (eqb::body (S n))) (\(m : nat) -> match::nat::type (bool.bool) bool.false (\(q : nat) -> eqb n q) m)) ((axiom::eqb::body::S) (n))

sym::eq::eqb::body::S : {i : Level} (n : nat) (P : (nat → bool) → Set i) → P (match::nat::type bool false (eqb n)) → P (eqb::body (S n))
sym::eq::eqb::body::S {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> bool.bool)) (eqb::body (S n))) (\(m : nat) -> match::nat::type (bool.bool) bool.false (\(q : nat) -> eqb n q) m)) ((eq::eqb::body::S) (n))

eqb::elim : _
eqb::elim = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) :::: ::0) -> P bool.true) -> ((connectives.Not (logic.eq (nat) :::: ::0)) -> P bool.false) -> P (eqb :::: ::0))) (\(n : nat) -> ((((match::nat::prop) (\(:::: : nat) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O ::::) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O ::::)) -> P bool.false) -> P (eqb O ::::))) ((((sym::eq::eqb) (O)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O O)) -> P bool.false) -> P (y O))) (((((sym::eq::filter::nat::type::O) (nat -> bool.bool)) (eqb::body)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O O)) -> P bool.false) -> P (y O))) (((sym::eq::eqb::body::O) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O O)) -> P bool.false) -> P (y O))) ((((((sym::eq::match::nat::type::O) (bool.bool)) (bool.true)) (\(q : nat) -> bool.false)) (\(y : bool.bool) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O O)) -> P bool.false) -> P y)) (\(P : bool.bool -> Set) -> \(auto : (logic.eq (nat) O O) -> P bool.true) -> (\(auto' : (connectives.Not (logic.eq (nat) O O)) -> P bool.false) -> ((auto) (((logic.refl) (nat)) (O)))))))))) (\(auto : nat) -> (((sym::eq::eqb) (O)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O (S auto)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O (S auto))) -> P bool.false) -> P (y (S auto)))) (((((sym::eq::filter::nat::type::O) (nat -> bool.bool)) (eqb::body)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O (S auto)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O (S auto))) -> P bool.false) -> P (y (S auto)))) (((sym::eq::eqb::body::O) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O (S auto)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O (S auto))) -> P bool.false) -> P (y (S auto)))) (((((((sym::eq::match::nat::type::S) (bool.bool)) (bool.true)) (\(q : nat) -> bool.false)) (auto)) (\(y : bool.bool) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) O (S auto)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) O (S auto))) -> P bool.false) -> P y)) (\(P : bool.bool -> Set) -> \(auto' : (logic.eq (nat) O (S auto)) -> P bool.true) -> (\(auto'' : (connectives.Not (logic.eq (nat) O (S auto))) -> P bool.false) -> ((auto'') ((not::eq::O::S) (auto)))))))))) (n))) (\(n : nat) -> (((sym::eq::eqb) (S n)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) O)) -> P bool.false) -> P (y O))) ((((((sym::eq::filter::nat::type::S) (nat -> bool.bool)) (eqb::body)) (n)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) O)) -> P bool.false) -> P (y O))) ((((sym::eq::eqb::body::S) (n)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) O)) -> P bool.false) -> P (y O))) ((((((sym::eq::match::nat::type::O) (bool.bool)) (bool.false)) (\(q : nat) -> eqb n q)) (\(y : bool.bool) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) O) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) O)) -> P bool.false) -> P y)) (\(P : bool.bool -> Set) -> \(auto : (logic.eq (nat) (S n) O) -> P bool.true) -> (\(auto' : (connectives.Not (logic.eq (nat) (S n) O)) -> P bool.false) -> ((auto') (((((logic.sym::not::eq) (nat)) (O)) (S n)) ((not::eq::O::S) (n))))))))))) (\(n : nat) -> \(m : nat) -> (((sym::eq::eqb) (S n)) (\(y : (nat -> bool.bool)) -> (forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) n m) -> P bool.true) -> ((connectives.Not (logic.eq (nat) n m)) -> P bool.false) -> P (eqb n m)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) (S m)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) (S m))) -> P bool.false) -> P (y (S m)))) ((((((sym::eq::filter::nat::type::S) (nat -> bool.bool)) (eqb::body)) (n)) (\(y : (nat -> bool.bool)) -> (forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) n m) -> P bool.true) -> ((connectives.Not (logic.eq (nat) n m)) -> P bool.false) -> P (eqb n m)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) (S m)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) (S m))) -> P bool.false) -> P (y (S m)))) ((((sym::eq::eqb::body::S) (n)) (\(y : (nat -> bool.bool)) -> (forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) n m) -> P bool.true) -> ((connectives.Not (logic.eq (nat) n m)) -> P bool.false) -> P (eqb n m)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) (S m)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) (S m))) -> P bool.false) -> P (y (S m)))) (((((((sym::eq::match::nat::type::S) (bool.bool)) (bool.false)) (\(q : nat) -> eqb n q)) (m)) (\(y : bool.bool) -> (forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) n m) -> P bool.true) -> ((connectives.Not (logic.eq (nat) n m)) -> P bool.false) -> P (eqb n m)) -> forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) (S n) (S m)) -> P bool.true) -> ((connectives.Not (logic.eq (nat) (S n) (S m))) -> P bool.false) -> P y)) (\(auto : forall (P : (bool.bool -> Set)) -> ((logic.eq (nat) n m) -> P bool.true) -> ((connectives.Not (logic.eq (nat) n m)) -> P bool.false) -> P (eqb n m)) -> (\(P : bool.bool -> Set) -> \(auto' : (logic.eq (nat) (S n) (S m)) -> P bool.true) -> (\(auto'' : (connectives.Not (logic.eq (nat) (S n) (S m))) -> P bool.false) -> ((((auto) (P)) (\(auto''' : logic.eq (nat) n m) -> ((auto') (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) (S n) (S ::::))) (((logic.refl) (nat)) (S n))) (m)) (auto'''))))) (\(auto''' : connectives.Not (logic.eq (nat) n m)) -> ((auto'') ((((not::eq::S) (n)) (m)) (auto'''))))))))))))

eqb::n::n : _
eqb::n::n = \(n : nat) -> ((((nat::ind) (\(::x::365 : nat) -> logic.eq (bool.bool) (eqb ::x::365 ::x::365) bool.true)) ((((sym::eq::eqb) (O)) (\(y : (nat -> bool.bool)) -> logic.eq (bool.bool) (y O) bool.true)) (((((sym::eq::filter::nat::type::O) (nat -> bool.bool)) (eqb::body)) (\(y : (nat -> bool.bool)) -> logic.eq (bool.bool) (y O) bool.true)) (((sym::eq::eqb::body::O) (\(y : (nat -> bool.bool)) -> logic.eq (bool.bool) (y O) bool.true)) ((((((sym::eq::match::nat::type::O) (bool.bool)) (bool.true)) (\(q : nat) -> bool.false)) (\(y : bool.bool) -> logic.eq (bool.bool) y bool.true)) (((logic.refl) (bool.bool)) (bool.true))))))) (\(x::366 : nat) -> (((sym::eq::eqb) (S x::366)) (\(y : (nat -> bool.bool)) -> (logic.eq (bool.bool) (eqb x::366 x::366) bool.true) -> logic.eq (bool.bool) (y (S x::366)) bool.true)) ((((((sym::eq::filter::nat::type::S) (nat -> bool.bool)) (eqb::body)) (x::366)) (\(y : (nat -> bool.bool)) -> (logic.eq (bool.bool) (eqb x::366 x::366) bool.true) -> logic.eq (bool.bool) (y (S x::366)) bool.true)) ((((sym::eq::eqb::body::S) (x::366)) (\(y : (nat -> bool.bool)) -> (logic.eq (bool.bool) (eqb x::366 x::366) bool.true) -> logic.eq (bool.bool) (y (S x::366)) bool.true)) (((((((sym::eq::match::nat::type::S) (bool.bool)) (bool.false)) (\(q : nat) -> eqb x::366 q)) (x::366)) (\(y : bool.bool) -> (logic.eq (bool.bool) (eqb x::366 x::366) bool.true) -> logic.eq (bool.bool) y bool.true)) (\(::x::368 : logic.eq (bool.bool) (eqb x::366 x::366) bool.true) -> (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (eqb x::366 x::366)) (::x::368)))))))) (n)

eqb::true::to::eq : _
eqb::true::to::eq = \(n : nat) -> \(m : nat) -> (((((eqb::elim) (n)) (m)) (\(:::: : bool.bool) -> (logic.eq (bool.bool) :::: bool.true) -> logic.eq (nat) n m)) (\(auto : logic.eq (nat) n m) -> (\(auto' : logic.eq (bool.bool) bool.true bool.true) -> (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) n ::::)) (((logic.refl) (nat)) (n))) (m)) (auto))))) (\(:::: : connectives.Not (logic.eq (nat) n m)) -> (\(abs : logic.eq (bool.bool) bool.false bool.true) -> (((connectives.falsity) (logic.eq (nat) n m)) ((((logic.absurd) (logic.eq (bool.bool) bool.true bool.false)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(::::1 : bool.bool) -> logic.eq (bool.bool) bool.true ::::1)) (((logic.refl) (bool.bool)) (bool.true))) (bool.false)) (abs))) (bool.not::eq::true::false)))))

eqb::false::to::not::eq : _
eqb::false::to::not::eq = \(n : nat) -> \(m : nat) -> (((((eqb::elim) (n)) (m)) (\(:::: : bool.bool) -> (logic.eq (bool.bool) :::: bool.false) -> connectives.Not (logic.eq (nat) n m))) (\(auto : logic.eq (nat) n m) -> (\(auto' : logic.eq (bool.bool) bool.true bool.false) -> (((((logic.not::to::not) (logic.eq (nat) n m)) (logic.eq (bool.bool) bool.true bool.false)) (\(auto'' : logic.eq (nat) n m) -> (((((((logic.rewrite::l) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) bool.true ::::)) (((logic.refl) (bool.bool)) (bool.true))) (bool.false)) (auto')))) (bool.not::eq::true::false))))) (\(auto : connectives.Not (logic.eq (nat) n m)) -> (\(auto' : logic.eq (bool.bool) bool.false bool.false) -> (auto)))

eq::to::eqb::true : _
eq::to::eqb::true = \(n : nat) -> \(m : nat) -> \(auto : logic.eq (nat) n m) -> (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (bool.bool) (eqb n ::::) bool.true)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.true)) (((logic.refl) (bool.bool)) (bool.true))) (eqb n n)) ((eqb::n::n) (n)))) (m)) (auto))

not::eq::to::eqb::false : _
not::eq::to::eqb::false = \(n : nat) -> \(m : nat) -> \(noteq : connectives.Not (logic.eq (nat) n m)) -> ((((((eqb::elim) (n)) (m)) (\(:::: : bool.bool) -> logic.eq (bool.bool) :::: bool.false)) (\(Heq : logic.eq (nat) n m) -> (((connectives.falsity) (logic.eq (bool.bool) bool.true bool.false)) ((((logic.absurd) (logic.eq (nat) n m)) (((((((logic.rewrite::l) (nat)) (n)) (\(:::: : nat) -> logic.eq (nat) n ::::)) (((logic.refl) (nat)) (n))) (m)) (Heq))) (noteq))))) (\(auto : connectives.Not (logic.eq (nat) n m)) -> (((logic.refl) (bool.bool)) (bool.false))))

postulate leb : nat -> nat -> bool.bool
postulate leb::body : nat -> nat -> bool.bool
postulate axiom::leb : forall (n : nat) -> connectives.equal (nat -> bool.bool) (leb n) (filter::nat::type (nat -> bool.bool) leb::body n)
eq::leb : {i : Level} →  _
eq::leb {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> bool.bool)) (leb n)) (filter::nat::type (nat -> bool.bool) leb::body n)) ((axiom::leb) (n))

sym::eq::leb : {i : Level} →  _
sym::eq::leb {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> bool.bool)) (leb n)) (filter::nat::type (nat -> bool.bool) leb::body n)) ((eq::leb) (n))

postulate axiom::leb::body::O : connectives.equal (nat -> bool.bool) (leb::body O) (\(m : nat) -> bool.true)
eq::leb::body::O : {i : Level} →  _
eq::leb::body::O {i} = ((((connectives.equal::leibniz) {_} {i} (nat -> bool.bool)) (leb::body O)) (\(m : nat) -> bool.true)) (axiom::leb::body::O)

sym::eq::leb::body::O : {i : Level} →  _
sym::eq::leb::body::O {i} = ((((leibniz.sym::leibniz) {_} {i} (nat -> bool.bool)) (leb::body O)) (\(m : nat) -> bool.true)) (eq::leb::body::O)

postulate axiom::leb::body::S : forall (n : nat) -> connectives.equal (nat -> bool.bool) (leb::body (S n)) (\(m : nat) -> match::nat::type (bool.bool) bool.false (\(q : nat) -> leb n q) m)
eq::leb::body::S : {i : Level} →  _
eq::leb::body::S {i} = \(n : nat) -> ((((connectives.equal::leibniz) {_} {i} (nat -> bool.bool)) (leb::body (S n))) (\(m : nat) -> match::nat::type (bool.bool) bool.false (\(q : nat) -> leb n q) m)) ((axiom::leb::body::S) (n))

sym::eq::leb::body::S : {i : Level} →  _
sym::eq::leb::body::S {i} = \(n : nat) -> ((((leibniz.sym::leibniz) {_} {i} (nat -> bool.bool)) (leb::body (S n))) (\(m : nat) -> match::nat::type (bool.bool) bool.false (\(q : nat) -> leb n q) m)) ((eq::leb::body::S) (n))

leb::elim : _
leb::elim = ((((nat::elim2) (\(:::: : nat) -> \(::0 : nat) -> forall (P : (bool.bool -> Set)) -> ((le :::: ::0) -> P bool.true) -> ((connectives.Not (le :::: ::0)) -> P bool.false) -> P (leb :::: ::0))) (\(n : nat) -> (((sym::eq::leb) (O)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((le O n) -> P bool.true) -> ((connectives.Not (le O n)) -> P bool.false) -> P (y n))) (((((sym::eq::filter::nat::type::O) (nat -> bool.bool)) (leb::body)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((le O n) -> P bool.true) -> ((connectives.Not (le O n)) -> P bool.false) -> P (y n))) (((sym::eq::leb::body::O) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((le O n) -> P bool.true) -> ((connectives.Not (le O n)) -> P bool.false) -> P (y n))) (\(P : bool.bool -> Set) -> \(auto : (le O n) -> P bool.true) -> (\(auto' : (connectives.Not (le O n)) -> P bool.false) -> ((auto) ((le::O::n) (n))))))))) (\(n : nat) -> (((sym::eq::leb) (S n)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) O) -> P bool.true) -> ((connectives.Not (le (S n) O)) -> P bool.false) -> P (y O))) ((((((sym::eq::filter::nat::type::S) (nat -> bool.bool)) (leb::body)) (n)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) O) -> P bool.true) -> ((connectives.Not (le (S n) O)) -> P bool.false) -> P (y O))) ((((sym::eq::leb::body::S) (n)) (\(y : (nat -> bool.bool)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) O) -> P bool.true) -> ((connectives.Not (le (S n) O)) -> P bool.false) -> P (y O))) ((((((sym::eq::match::nat::type::O) (bool.bool)) (bool.false)) (\(q : nat) -> leb n q)) (\(y : bool.bool) -> forall (P : (bool.bool -> Set)) -> ((le (S n) O) -> P bool.true) -> ((connectives.Not (le (S n) O)) -> P bool.false) -> P y)) (\(P : bool.bool -> Set) -> \(auto : (le (S n) O) -> P bool.true) -> (\(auto' : (connectives.Not (le (S n) O)) -> P bool.false) -> ((auto') ((not::le::Sn::O) (n)))))))))) (\(n : nat) -> \(m : nat) -> (((sym::eq::leb) (S n)) (\(y : (nat -> bool.bool)) -> (forall (P : (bool.bool -> Set)) -> ((le n m) -> P bool.true) -> ((connectives.Not (le n m)) -> P bool.false) -> P (leb n m)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) (S m)) -> P bool.true) -> ((connectives.Not (le (S n) (S m))) -> P bool.false) -> P (y (S m)))) ((((((sym::eq::filter::nat::type::S) (nat -> bool.bool)) (leb::body)) (n)) (\(y : (nat -> bool.bool)) -> (forall (P : (bool.bool -> Set)) -> ((le n m) -> P bool.true) -> ((connectives.Not (le n m)) -> P bool.false) -> P (leb n m)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) (S m)) -> P bool.true) -> ((connectives.Not (le (S n) (S m))) -> P bool.false) -> P (y (S m)))) ((((sym::eq::leb::body::S) (n)) (\(y : (nat -> bool.bool)) -> (forall (P : (bool.bool -> Set)) -> ((le n m) -> P bool.true) -> ((connectives.Not (le n m)) -> P bool.false) -> P (leb n m)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) (S m)) -> P bool.true) -> ((connectives.Not (le (S n) (S m))) -> P bool.false) -> P (y (S m)))) (((((((sym::eq::match::nat::type::S) (bool.bool)) (bool.false)) (\(q : nat) -> leb n q)) (m)) (\(y : bool.bool) -> (forall (P : (bool.bool -> Set)) -> ((le n m) -> P bool.true) -> ((connectives.Not (le n m)) -> P bool.false) -> P (leb n m)) -> forall (P : (bool.bool -> Set)) -> ((le (S n) (S m)) -> P bool.true) -> ((connectives.Not (le (S n) (S m))) -> P bool.false) -> P y)) (\(Hind : forall (P : (bool.bool -> Set)) -> ((le n m) -> P bool.true) -> ((connectives.Not (le n m)) -> P bool.false) -> P (leb n m)) -> (\(P : bool.bool -> Set) -> \(Pt : (le (S n) (S m)) -> P bool.true) -> (\(Pf : (connectives.Not (le (S n) (S m))) -> P bool.false) -> ((((Hind) (P)) (\(lenm : le n m) -> ((Pt) ((((le::S::S) (n)) (m)) (lenm))))) (\(nlenm : connectives.Not (le n m)) -> ((Pf) ((((not::le::to::not::le::S::S) (n)) (m)) (nlenm))))))))))))

leb::true::to::le : _
leb::true::to::le = \(n : nat) -> \(m : nat) -> (((((leb::elim) (n)) (m)) (\(:::: : bool.bool) -> (logic.eq (bool.bool) :::: bool.true) -> le n m)) (\(auto : le n m) -> (\(auto' : logic.eq (bool.bool) bool.true bool.true) -> (auto)))) (\(:::: : connectives.Not (le n m)) -> (\(abs : logic.eq (bool.bool) bool.false bool.true) -> (((connectives.falsity) (le n m)) ((((logic.absurd) (logic.eq (bool.bool) bool.true bool.false)) (((((((logic.rewrite::r) (bool.bool)) (bool.true)) (\(::::1 : bool.bool) -> logic.eq (bool.bool) bool.true ::::1)) (((logic.refl) (bool.bool)) (bool.true))) (bool.false)) (abs))) (bool.not::eq::true::false)))))

le::to::leb::true : _
le::to::leb::true = \(n : nat) -> \(m : nat) -> (((((leb::elim) (n)) (m)) (\(:::: : bool.bool) -> (le n m) -> logic.eq (bool.bool) :::: bool.true)) (\(auto : le n m) -> (\(auto' : le n m) -> (((logic.refl) (bool.bool)) (bool.true))))) (\(H : connectives.Not (le n m)) -> (\(H1 : le n m) -> (((connectives.falsity) (logic.eq (bool.bool) bool.false bool.true)) ((((logic.absurd) (le n m)) (H1)) (H)))))

not::le::to::leb::false : _
not::le::to::leb::false = \(n : nat) -> \(m : nat) -> (((((leb::elim) (n)) (m)) (\(:::: : bool.bool) -> (connectives.Not (le n m)) -> logic.eq (bool.bool) :::: bool.false)) (\(H : le n m) -> (\(H1 : connectives.Not (le n m)) -> (((connectives.falsity) (logic.eq (bool.bool) bool.true bool.false)) ((((logic.absurd) (le n m)) (H)) (H1)))))) (\(auto : connectives.Not (le n m)) -> (\(auto' : connectives.Not (le n m)) -> (((logic.refl) (bool.bool)) (bool.false))))

